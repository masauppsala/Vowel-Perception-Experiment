#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2022.2.5),
    on 3月 13, 2023, at 14:41
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

# --- Import packages ---
from psychopy import locale_setup
from psychopy import prefs
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors, layout
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

import psychopy.iohub as io
from psychopy.hardware import keyboard



# Ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
os.chdir(_thisDir)
# Store info about the experiment session
psychopyVersion = '2022.2.5'
expName = 'latest_sound_vowels'  # from the Builder filename that created this script
expInfo = {
    'participant': f"{randint(0, 999999):06.0f}",
    'session': '001',
}
# --- Show participant info dialog --
dlg = gui.DlgFromDict(dictionary=expInfo, sortKeys=False, title=expName)
if dlg.OK == False:
    core.quit()  # user pressed cancel
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
expInfo['psychopyVersion'] = psychopyVersion

# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
filename = _thisDir + os.sep + u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])

# An ExperimentHandler isn't essential but helps with data saving
thisExp = data.ExperimentHandler(name=expName, version='',
    extraInfo=expInfo, runtimeInfo=None,
    originPath='C:\\Users\\masak\\Desktop\\latest_sound_vowels_lastrun.py',
    savePickle=True, saveWideText=True,
    dataFileName=filename)
# save a log file for detail verbose info
logFile = logging.LogFile(filename+'.log', level=logging.EXP)
logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file

endExpNow = False  # flag for 'escape' or other condition => quit the exp
frameTolerance = 0.001  # how close to onset before 'same' frame

# Start Code - component code to be run after the window creation

# --- Setup the Window ---
win = visual.Window(
    size=[1280, 720], fullscr=True, screen=0, 
    winType='pyglet', allowStencil=False,
    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
    blendMode='avg', useFBO=True, 
    units='height')
win.mouseVisible = False
# store frame rate of monitor if we can measure it
expInfo['frameRate'] = win.getActualFrameRate()
if expInfo['frameRate'] != None:
    frameDur = 1.0 / round(expInfo['frameRate'])
else:
    frameDur = 1.0 / 60.0  # could not measure, so guess
# --- Setup input devices ---
ioConfig = {}

# Setup iohub keyboard
ioConfig['Keyboard'] = dict(use_keymap='psychopy')

ioSession = '1'
if 'session' in expInfo:
    ioSession = str(expInfo['session'])
ioServer = io.launchHubServer(window=win, **ioConfig)
eyetracker = None

# create a default keyboard (e.g. to check for escape)
defaultKeyboard = keyboard.Keyboard(backend='iohub')

# --- Initialize components for Routine "trial" ---
sound_vowels = sound.Sound('mainpairs/joja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels')
sound_vowels.setVolume(1.0)
text = visual.TextStim(win=win, name='text',
    text='Listen to a pair of vowels. Please answer whether they are the same vowels or not. It will be played in 3 seconds.',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_2 = visual.TextStim(win=win, name='text_2',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_3 = visual.TextStim(win=win, name='text_3',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_4 = visual.TextStim(win=win, name='text_4',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_5 = visual.TextStim(win=win, name='text_5',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp = keyboard.Keyboard()

# --- Initialize components for Routine "A_sa_A_sasecond" ---
A_saandA_sa = sound.Sound('mainpairs/A.sa+A.sa.wav', secs=-1, stereo=True, hamming=True,
    name='A_saandA_sa')
A_saandA_sa.setVolume(1.0)
text_6 = visual.TextStim(win=win, name='text_6',
    text='It was a trial. Now please answer whether the vowels are the same or not. It will take about 20 minutes\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_7 = visual.TextStim(win=win, name='text_7',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_8 = visual.TextStim(win=win, name='text_8',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_9 = visual.TextStim(win=win, name='text_9',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_10 = visual.TextStim(win=win, name='text_10',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_2 = keyboard.Keyboard()

# --- Initialize components for Routine "usousopu" ---
sound_vowels_91 = sound.Sound('mainpairs/usousopu.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_91')
sound_vowels_91.setVolume(1.0)
text_451 = visual.TextStim(win=win, name='text_451',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_452 = visual.TextStim(win=win, name='text_452',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_453 = visual.TextStim(win=win, name='text_453',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_454 = visual.TextStim(win=win, name='text_454',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_455 = visual.TextStim(win=win, name='text_455',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_91 = keyboard.Keyboard()

# --- Initialize components for Routine "uusopso" ---
sound_vowels_92 = sound.Sound('mainpairs/uusopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_92')
sound_vowels_92.setVolume(1.0)
text_456 = visual.TextStim(win=win, name='text_456',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_457 = visual.TextStim(win=win, name='text_457',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_458 = visual.TextStim(win=win, name='text_458',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_459 = visual.TextStim(win=win, name='text_459',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_460 = visual.TextStim(win=win, name='text_460',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_92 = keyboard.Keyboard()

# --- Initialize components for Routine "sousopu" ---
sound_vowels_85 = sound.Sound('mainpairs/sousopu.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_85')
sound_vowels_85.setVolume(1.0)
text_421 = visual.TextStim(win=win, name='text_421',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_422 = visual.TextStim(win=win, name='text_422',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_423 = visual.TextStim(win=win, name='text_423',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_424 = visual.TextStim(win=win, name='text_424',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_425 = visual.TextStim(win=win, name='text_425',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_85 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_sa" ---
sound_vowels_77 = sound.Sound('mainpairs/sa.ja+sa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_77')
sound_vowels_77.setVolume(1.0)
text_381 = visual.TextStim(win=win, name='text_381',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_382 = visual.TextStim(win=win, name='text_382',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_383 = visual.TextStim(win=win, name='text_383',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_384 = visual.TextStim(win=win, name='text_384',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_385 = visual.TextStim(win=win, name='text_385',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_77 = keyboard.Keyboard()

# --- Initialize components for Routine "u_so_so" ---
sound_vowels_86 = sound.Sound('mainpairs/u.so+so.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_86')
sound_vowels_86.setVolume(1.0)
text_426 = visual.TextStim(win=win, name='text_426',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_427 = visual.TextStim(win=win, name='text_427',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_428 = visual.TextStim(win=win, name='text_428',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_429 = visual.TextStim(win=win, name='text_429',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_430 = visual.TextStim(win=win, name='text_430',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_86 = keyboard.Keyboard()

# --- Initialize components for Routine "sojojopjo" ---
sound_vowels_45 = sound.Sound('mainpairs/sojojopjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_45')
sound_vowels_45.setVolume(1.0)
text_221 = visual.TextStim(win=win, name='text_221',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_222 = visual.TextStim(win=win, name='text_222',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_223 = visual.TextStim(win=win, name='text_223',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_224 = visual.TextStim(win=win, name='text_224',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_225 = visual.TextStim(win=win, name='text_225',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_45 = keyboard.Keyboard()

# --- Initialize components for Routine "u_so_u_so" ---
sound_vowels_87 = sound.Sound('mainpairs/u.so+u.so.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_87')
sound_vowels_87.setVolume(1.0)
text_431 = visual.TextStim(win=win, name='text_431',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_432 = visual.TextStim(win=win, name='text_432',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_433 = visual.TextStim(win=win, name='text_433',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_434 = visual.TextStim(win=win, name='text_434',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_435 = visual.TextStim(win=win, name='text_435',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_87 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_sa_ja" ---
sound_vowels_76 = sound.Sound('mainpairs/sa.ja+sa.ja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_76')
sound_vowels_76.setVolume(1.0)
text_376 = visual.TextStim(win=win, name='text_376',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_377 = visual.TextStim(win=win, name='text_377',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_378 = visual.TextStim(win=win, name='text_378',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_379 = visual.TextStim(win=win, name='text_379',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_380 = visual.TextStim(win=win, name='text_380',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_76 = keyboard.Keyboard()

# --- Initialize components for Routine "so_u_so" ---
sound_vowels_84 = sound.Sound('mainpairs/so+u.so.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_84')
sound_vowels_84.setVolume(1.0)
text_416 = visual.TextStim(win=win, name='text_416',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_417 = visual.TextStim(win=win, name='text_417',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_418 = visual.TextStim(win=win, name='text_418',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_419 = visual.TextStim(win=win, name='text_419',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_420 = visual.TextStim(win=win, name='text_420',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_84 = keyboard.Keyboard()

# --- Initialize components for Routine "jo_jo_A" ---
sound_vowels_73 = sound.Sound('mainpairs/jo+jo.A.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_73')
sound_vowels_73.setVolume(1.0)
text_361 = visual.TextStim(win=win, name='text_361',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_362 = visual.TextStim(win=win, name='text_362',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_363 = visual.TextStim(win=win, name='text_363',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_364 = visual.TextStim(win=win, name='text_364',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_365 = visual.TextStim(win=win, name='text_365',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_73 = keyboard.Keyboard()

# --- Initialize components for Routine "u_so_u" ---
sound_vowels_88 = sound.Sound('mainpairs/u.so+u.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_88')
sound_vowels_88.setVolume(1.0)
text_436 = visual.TextStim(win=win, name='text_436',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_437 = visual.TextStim(win=win, name='text_437',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_438 = visual.TextStim(win=win, name='text_438',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_439 = visual.TextStim(win=win, name='text_439',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_440 = visual.TextStim(win=win, name='text_440',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_88 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_ja" ---
sound_vowels_75 = sound.Sound('mainpairs/sa.ja+ja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_75')
sound_vowels_75.setVolume(1.0)
text_371 = visual.TextStim(win=win, name='text_371',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_372 = visual.TextStim(win=win, name='text_372',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_373 = visual.TextStim(win=win, name='text_373',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_374 = visual.TextStim(win=win, name='text_374',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_375 = visual.TextStim(win=win, name='text_375',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_75 = keyboard.Keyboard()

# --- Initialize components for Routine "usosopu" ---
sound_vowels_89 = sound.Sound('mainpairs/usosopu.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_89')
sound_vowels_89.setVolume(1.0)
text_441 = visual.TextStim(win=win, name='text_441',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_442 = visual.TextStim(win=win, name='text_442',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_443 = visual.TextStim(win=win, name='text_443',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_444 = visual.TextStim(win=win, name='text_444',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_445 = visual.TextStim(win=win, name='text_445',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_89 = keyboard.Keyboard()

# --- Initialize components for Routine "so_so_jo" ---
sound_vowels_83 = sound.Sound('mainpairs/so+so.jo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_83')
sound_vowels_83.setVolume(1.0)
text_411 = visual.TextStim(win=win, name='text_411',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_412 = visual.TextStim(win=win, name='text_412',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_413 = visual.TextStim(win=win, name='text_413',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_414 = visual.TextStim(win=win, name='text_414',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_415 = visual.TextStim(win=win, name='text_415',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_83 = keyboard.Keyboard()

# --- Initialize components for Routine "ja_sa_ja" ---
sound_vowels_69 = sound.Sound('mainpairs/ja+sa.ja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_69')
sound_vowels_69.setVolume(1.0)
text_341 = visual.TextStim(win=win, name='text_341',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_342 = visual.TextStim(win=win, name='text_342',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_343 = visual.TextStim(win=win, name='text_343',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_344 = visual.TextStim(win=win, name='text_344',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_345 = visual.TextStim(win=win, name='text_345',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_69 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_A_sapsa" ---
sound_vowels_68 = sound.Sound('mainpairs/sa+A.sapsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_68')
sound_vowels_68.setVolume(1.0)
text_336 = visual.TextStim(win=win, name='text_336',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_337 = visual.TextStim(win=win, name='text_337',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_338 = visual.TextStim(win=win, name='text_338',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_339 = visual.TextStim(win=win, name='text_339',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_340 = visual.TextStim(win=win, name='text_340',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_68 = keyboard.Keyboard()

# --- Initialize components for Routine "jo_A_A" ---
sound_vowels_70 = sound.Sound('mainpairs/jo.A+A.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_70')
sound_vowels_70.setVolume(1.0)
text_346 = visual.TextStim(win=win, name='text_346',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_347 = visual.TextStim(win=win, name='text_347',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_348 = visual.TextStim(win=win, name='text_348',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_349 = visual.TextStim(win=win, name='text_349',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_350 = visual.TextStim(win=win, name='text_350',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_70 = keyboard.Keyboard()

# --- Initialize components for Routine "usoupu" ---
sound_vowels_90 = sound.Sound('mainpairs/usoupu.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_90')
sound_vowels_90.setVolume(1.0)
text_446 = visual.TextStim(win=win, name='text_446',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_447 = visual.TextStim(win=win, name='text_447',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_448 = visual.TextStim(win=win, name='text_448',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_449 = visual.TextStim(win=win, name='text_449',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_450 = visual.TextStim(win=win, name='text_450',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_90 = keyboard.Keyboard()

# --- Initialize components for Routine "ja_sa_japja" ---
sound_vowels_58 = sound.Sound('mainpairs/ja+sa.japja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_58')
sound_vowels_58.setVolume(1.0)
text_286 = visual.TextStim(win=win, name='text_286',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_287 = visual.TextStim(win=win, name='text_287',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_288 = visual.TextStim(win=win, name='text_288',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_289 = visual.TextStim(win=win, name='text_289',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_290 = visual.TextStim(win=win, name='text_290',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_58 = keyboard.Keyboard()

# --- Initialize components for Routine "joAApjo" ---
sound_vowels_40 = sound.Sound('mainpairs/joAApjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_40')
sound_vowels_40.setVolume(1.0)
text_196 = visual.TextStim(win=win, name='text_196',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_197 = visual.TextStim(win=win, name='text_197',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_198 = visual.TextStim(win=win, name='text_198',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_199 = visual.TextStim(win=win, name='text_199',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_200 = visual.TextStim(win=win, name='text_200',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_40 = keyboard.Keyboard()

# --- Initialize components for Routine "saAsapA" ---
sound_vowels_44 = sound.Sound('mainpairs/saAsapA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_44')
sound_vowels_44.setVolume(1.0)
text_216 = visual.TextStim(win=win, name='text_216',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_217 = visual.TextStim(win=win, name='text_217',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_218 = visual.TextStim(win=win, name='text_218',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_219 = visual.TextStim(win=win, name='text_219',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_220 = visual.TextStim(win=win, name='text_220',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_44 = keyboard.Keyboard()

# --- Initialize components for Routine "ja_sa_japsa" ---
sound_vowels_59 = sound.Sound('mainpairs/ja+sa.japsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_59')
sound_vowels_59.setVolume(1.0)
text_291 = visual.TextStim(win=win, name='text_291',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_292 = visual.TextStim(win=win, name='text_292',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_293 = visual.TextStim(win=win, name='text_293',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_294 = visual.TextStim(win=win, name='text_294',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_295 = visual.TextStim(win=win, name='text_295',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_59 = keyboard.Keyboard()

# --- Initialize components for Routine "sopjo" ---
sound_vowels_39 = sound.Sound('mainpairs/sopjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_39')
sound_vowels_39.setVolume(1.0)
text_191 = visual.TextStim(win=win, name='text_191',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_192 = visual.TextStim(win=win, name='text_192',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_193 = visual.TextStim(win=win, name='text_193',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_194 = visual.TextStim(win=win, name='text_194',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_195 = visual.TextStim(win=win, name='text_195',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_39 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_A_sa" ---
sound_vowels_78 = sound.Sound('mainpairs/sa+A.sa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_78')
sound_vowels_78.setVolume(1.0)
text_386 = visual.TextStim(win=win, name='text_386',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_387 = visual.TextStim(win=win, name='text_387',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_388 = visual.TextStim(win=win, name='text_388',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_389 = visual.TextStim(win=win, name='text_389',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_390 = visual.TextStim(win=win, name='text_390',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_78 = keyboard.Keyboard()

# --- Initialize components for Routine "jojoApjo" ---
sound_vowels_48 = sound.Sound('mainpairs/jojoApjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_48')
sound_vowels_48.setVolume(1.0)
text_236 = visual.TextStim(win=win, name='text_236',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_237 = visual.TextStim(win=win, name='text_237',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_238 = visual.TextStim(win=win, name='text_238',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_239 = visual.TextStim(win=win, name='text_239',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_240 = visual.TextStim(win=win, name='text_240',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_48 = keyboard.Keyboard()

# --- Initialize components for Routine "uusopu" ---
sound_vowels_93 = sound.Sound('mainpairs/uusopu.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_93')
sound_vowels_93.setVolume(1.0)
text_461 = visual.TextStim(win=win, name='text_461',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_462 = visual.TextStim(win=win, name='text_462',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_463 = visual.TextStim(win=win, name='text_463',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_464 = visual.TextStim(win=win, name='text_464',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_465 = visual.TextStim(win=win, name='text_465',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_93 = keyboard.Keyboard()

# --- Initialize components for Routine "sojosojopjo" ---
sound_vowels_54 = sound.Sound('mainpairs/sojosojopjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_54')
sound_vowels_54.setVolume(1.0)
text_266 = visual.TextStim(win=win, name='text_266',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_267 = visual.TextStim(win=win, name='text_267',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_268 = visual.TextStim(win=win, name='text_268',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_269 = visual.TextStim(win=win, name='text_269',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_270 = visual.TextStim(win=win, name='text_270',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_54 = keyboard.Keyboard()

# --- Initialize components for Routine "sosojopso" ---
sound_vowels_50 = sound.Sound('mainpairs/sosojopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_50')
sound_vowels_50.setVolume(1.0)
text_246 = visual.TextStim(win=win, name='text_246',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_247 = visual.TextStim(win=win, name='text_247',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_248 = visual.TextStim(win=win, name='text_248',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_249 = visual.TextStim(win=win, name='text_249',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_250 = visual.TextStim(win=win, name='text_250',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_50 = keyboard.Keyboard()

# --- Initialize components for Routine "A_sa_sapsa" ---
sound_vowels_8 = sound.Sound('mainpairs/A.sa+sapsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_8')
sound_vowels_8.setVolume(1.0)
text_36 = visual.TextStim(win=win, name='text_36',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_37 = visual.TextStim(win=win, name='text_37',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_38 = visual.TextStim(win=win, name='text_38',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_39 = visual.TextStim(win=win, name='text_39',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_40 = visual.TextStim(win=win, name='text_40',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_8 = keyboard.Keyboard()

# --- Initialize components for Routine "jo_A_jo_A" ---
sound_vowels_71 = sound.Sound('mainpairs/jo.A+jo.A.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_71')
sound_vowels_71.setVolume(1.0)
text_351 = visual.TextStim(win=win, name='text_351',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_352 = visual.TextStim(win=win, name='text_352',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_353 = visual.TextStim(win=win, name='text_353',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_354 = visual.TextStim(win=win, name='text_354',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_355 = visual.TextStim(win=win, name='text_355',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_71 = keyboard.Keyboard()

# --- Initialize components for Routine "jo_so_jo" ---
sound_vowels_74 = sound.Sound('mainpairs/jo+so.jo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_74')
sound_vowels_74.setVolume(1.0)
text_366 = visual.TextStim(win=win, name='text_366',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_367 = visual.TextStim(win=win, name='text_367',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_368 = visual.TextStim(win=win, name='text_368',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_369 = visual.TextStim(win=win, name='text_369',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_370 = visual.TextStim(win=win, name='text_370',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_74 = keyboard.Keyboard()

# --- Initialize components for Routine "sojosojopso" ---
sound_vowels_51 = sound.Sound('mainpairs/sojosojopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_51')
sound_vowels_51.setVolume(1.0)
text_251 = visual.TextStim(win=win, name='text_251',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_252 = visual.TextStim(win=win, name='text_252',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_253 = visual.TextStim(win=win, name='text_253',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_254 = visual.TextStim(win=win, name='text_254',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_255 = visual.TextStim(win=win, name='text_255',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_51 = keyboard.Keyboard()

# --- Initialize components for Routine "josojopjo" ---
sound_vowels_49 = sound.Sound('mainpairs/josojopjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_49')
sound_vowels_49.setVolume(1.0)
text_241 = visual.TextStim(win=win, name='text_241',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_242 = visual.TextStim(win=win, name='text_242',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_243 = visual.TextStim(win=win, name='text_243',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_244 = visual.TextStim(win=win, name='text_244',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_245 = visual.TextStim(win=win, name='text_245',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_49 = keyboard.Keyboard()

# --- Initialize components for Routine "joAjoApjo" ---
sound_vowels_47 = sound.Sound('mainpairs/joAjoApjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_47')
sound_vowels_47.setVolume(1.0)
text_231 = visual.TextStim(win=win, name='text_231',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_232 = visual.TextStim(win=win, name='text_232',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_233 = visual.TextStim(win=win, name='text_233',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_234 = visual.TextStim(win=win, name='text_234',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_235 = visual.TextStim(win=win, name='text_235',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_47 = keyboard.Keyboard()

# --- Initialize components for Routine "so_jo_jo" ---
sound_vowels_80 = sound.Sound('mainpairs/so.jo+jo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_80')
sound_vowels_80.setVolume(1.0)
text_396 = visual.TextStim(win=win, name='text_396',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_397 = visual.TextStim(win=win, name='text_397',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_398 = visual.TextStim(win=win, name='text_398',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_399 = visual.TextStim(win=win, name='text_399',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_400 = visual.TextStim(win=win, name='text_400',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_80 = keyboard.Keyboard()

# --- Initialize components for Routine "sousopso" ---
sound_vowels_46 = sound.Sound('mainpairs/sousopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_46')
sound_vowels_46.setVolume(1.0)
text_226 = visual.TextStim(win=win, name='text_226',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_227 = visual.TextStim(win=win, name='text_227',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_228 = visual.TextStim(win=win, name='text_228',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_229 = visual.TextStim(win=win, name='text_229',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_230 = visual.TextStim(win=win, name='text_230',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_46 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_sa_ja" ---
sound_vowels_79 = sound.Sound('mainpairs/sa+sa.ja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_79')
sound_vowels_79.setVolume(1.0)
text_391 = visual.TextStim(win=win, name='text_391',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_392 = visual.TextStim(win=win, name='text_392',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_393 = visual.TextStim(win=win, name='text_393',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_394 = visual.TextStim(win=win, name='text_394',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_395 = visual.TextStim(win=win, name='text_395',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_79 = keyboard.Keyboard()

# --- Initialize components for Routine "joAjopjo" ---
sound_vowels_42 = sound.Sound('mainpairs/joAjopjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_42')
sound_vowels_42.setVolume(1.0)
text_206 = visual.TextStim(win=win, name='text_206',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_207 = visual.TextStim(win=win, name='text_207',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_208 = visual.TextStim(win=win, name='text_208',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_209 = visual.TextStim(win=win, name='text_209',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_210 = visual.TextStim(win=win, name='text_210',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_42 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_sa_japsa" ---
sound_vowels_60 = sound.Sound('mainpairs/sa+sa.japsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_60')
sound_vowels_60.setVolume(1.0)
text_296 = visual.TextStim(win=win, name='text_296',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_297 = visual.TextStim(win=win, name='text_297',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_298 = visual.TextStim(win=win, name='text_298',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_299 = visual.TextStim(win=win, name='text_299',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_300 = visual.TextStim(win=win, name='text_300',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_60 = keyboard.Keyboard()

# --- Initialize components for Routine "jo_A_jo" ---
sound_vowels_72 = sound.Sound('mainpairs/jo.A+jo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_72')
sound_vowels_72.setVolume(1.0)
text_356 = visual.TextStim(win=win, name='text_356',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_357 = visual.TextStim(win=win, name='text_357',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_358 = visual.TextStim(win=win, name='text_358',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_359 = visual.TextStim(win=win, name='text_359',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_360 = visual.TextStim(win=win, name='text_360',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_72 = keyboard.Keyboard()

# --- Initialize components for Routine "sojosopjo" ---
sound_vowels_53 = sound.Sound('mainpairs/sojosopjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_53')
sound_vowels_53.setVolume(1.0)
text_261 = visual.TextStim(win=win, name='text_261',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_262 = visual.TextStim(win=win, name='text_262',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_263 = visual.TextStim(win=win, name='text_263',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_264 = visual.TextStim(win=win, name='text_264',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_265 = visual.TextStim(win=win, name='text_265',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_53 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_japja" ---
sound_vowels_62 = sound.Sound('mainpairs/sa.ja+japja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_62')
sound_vowels_62.setVolume(1.0)
text_306 = visual.TextStim(win=win, name='text_306',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_307 = visual.TextStim(win=win, name='text_307',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_308 = visual.TextStim(win=win, name='text_308',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_309 = visual.TextStim(win=win, name='text_309',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_310 = visual.TextStim(win=win, name='text_310',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_62 = keyboard.Keyboard()

# --- Initialize components for Routine "joAjopA" ---
sound_vowels_41 = sound.Sound('mainpairs/joAjopA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_41')
sound_vowels_41.setVolume(1.0)
text_201 = visual.TextStim(win=win, name='text_201',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_202 = visual.TextStim(win=win, name='text_202',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_203 = visual.TextStim(win=win, name='text_203',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_204 = visual.TextStim(win=win, name='text_204',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_205 = visual.TextStim(win=win, name='text_205',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_41 = keyboard.Keyboard()

# --- Initialize components for Routine "sapja" ---
sound_vowels_37 = sound.Sound('mainpairs/sapja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_37')
sound_vowels_37.setVolume(1.0)
text_181 = visual.TextStim(win=win, name='text_181',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_182 = visual.TextStim(win=win, name='text_182',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_183 = visual.TextStim(win=win, name='text_183',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_184 = visual.TextStim(win=win, name='text_184',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_185 = visual.TextStim(win=win, name='text_185',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_37 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_sa_japja" ---
sound_vowels_64 = sound.Sound('mainpairs/sa.ja+sa.japja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_64')
sound_vowels_64.setVolume(1.0)
text_316 = visual.TextStim(win=win, name='text_316',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_317 = visual.TextStim(win=win, name='text_317',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_318 = visual.TextStim(win=win, name='text_318',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_319 = visual.TextStim(win=win, name='text_319',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_320 = visual.TextStim(win=win, name='text_320',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_64 = keyboard.Keyboard()

# --- Initialize components for Routine "josojopso" ---
sound_vowels_57 = sound.Sound('mainpairs/josojopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_57')
sound_vowels_57.setVolume(1.0)
text_281 = visual.TextStim(win=win, name='text_281',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_282 = visual.TextStim(win=win, name='text_282',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_283 = visual.TextStim(win=win, name='text_283',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_284 = visual.TextStim(win=win, name='text_284',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_285 = visual.TextStim(win=win, name='text_285',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_57 = keyboard.Keyboard()

# --- Initialize components for Routine "so_jo_so_jo" ---
sound_vowels_81 = sound.Sound('mainpairs/so.jo+so.jo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_81')
sound_vowels_81.setVolume(1.0)
text_401 = visual.TextStim(win=win, name='text_401',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_402 = visual.TextStim(win=win, name='text_402',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_403 = visual.TextStim(win=win, name='text_403',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_404 = visual.TextStim(win=win, name='text_404',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_405 = visual.TextStim(win=win, name='text_405',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_81 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_sa_japja" ---
sound_vowels_61 = sound.Sound('mainpairs/sa+sa.japja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_61')
sound_vowels_61.setVolume(1.0)
text_301 = visual.TextStim(win=win, name='text_301',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_302 = visual.TextStim(win=win, name='text_302',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_303 = visual.TextStim(win=win, name='text_303',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_304 = visual.TextStim(win=win, name='text_304',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_305 = visual.TextStim(win=win, name='text_305',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_61 = keyboard.Keyboard()

# --- Initialize components for Routine "sojojopso" ---
sound_vowels_52 = sound.Sound('mainpairs/sojojopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_52')
sound_vowels_52.setVolume(1.0)
text_256 = visual.TextStim(win=win, name='text_256',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_257 = visual.TextStim(win=win, name='text_257',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_258 = visual.TextStim(win=win, name='text_258',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_259 = visual.TextStim(win=win, name='text_259',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_260 = visual.TextStim(win=win, name='text_260',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_52 = keyboard.Keyboard()

# --- Initialize components for Routine "jojoApA" ---
sound_vowels_43 = sound.Sound('mainpairs/jojoApA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_43')
sound_vowels_43.setVolume(1.0)
text_211 = visual.TextStim(win=win, name='text_211',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_212 = visual.TextStim(win=win, name='text_212',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_213 = visual.TextStim(win=win, name='text_213',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_214 = visual.TextStim(win=win, name='text_214',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_215 = visual.TextStim(win=win, name='text_215',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_43 = keyboard.Keyboard()

# --- Initialize components for Routine "so_jo_so" ---
sound_vowels_82 = sound.Sound('mainpairs/so.jo+so.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_82')
sound_vowels_82.setVolume(1.0)
text_406 = visual.TextStim(win=win, name='text_406',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_407 = visual.TextStim(win=win, name='text_407',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_408 = visual.TextStim(win=win, name='text_408',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_409 = visual.TextStim(win=win, name='text_409',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_410 = visual.TextStim(win=win, name='text_410',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_82 = keyboard.Keyboard()

# --- Initialize components for Routine "joAApA" ---
sound_vowels_38 = sound.Sound('mainpairs/joAApA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_38')
sound_vowels_38.setVolume(1.0)
text_186 = visual.TextStim(win=win, name='text_186',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_187 = visual.TextStim(win=win, name='text_187',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_188 = visual.TextStim(win=win, name='text_188',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_189 = visual.TextStim(win=win, name='text_189',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_190 = visual.TextStim(win=win, name='text_190',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_38 = keyboard.Keyboard()

# --- Initialize components for Routine "sojosopso" ---
sound_vowels_55 = sound.Sound('mainpairs/sojosopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_55')
sound_vowels_55.setVolume(1.0)
text_271 = visual.TextStim(win=win, name='text_271',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_272 = visual.TextStim(win=win, name='text_272',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_273 = visual.TextStim(win=win, name='text_273',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_274 = visual.TextStim(win=win, name='text_274',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_275 = visual.TextStim(win=win, name='text_275',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_55 = keyboard.Keyboard()

# --- Initialize components for Routine "usa" ---
sound_vowels_33 = sound.Sound('mainpairs/usa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_33')
sound_vowels_33.setVolume(1.0)
text_161 = visual.TextStim(win=win, name='text_161',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_162 = visual.TextStim(win=win, name='text_162',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_163 = visual.TextStim(win=win, name='text_163',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_164 = visual.TextStim(win=win, name='text_164',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_165 = visual.TextStim(win=win, name='text_165',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_33 = keyboard.Keyboard()

# --- Initialize components for Routine "soja" ---
sound_vowels_36 = sound.Sound('mainpairs/soja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_36')
sound_vowels_36.setVolume(1.0)
text_176 = visual.TextStim(win=win, name='text_176',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_177 = visual.TextStim(win=win, name='text_177',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_178 = visual.TextStim(win=win, name='text_178',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_179 = visual.TextStim(win=win, name='text_179',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_180 = visual.TextStim(win=win, name='text_180',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_36 = keyboard.Keyboard()

# --- Initialize components for Routine "AsaAsapsa" ---
sound_vowels_24 = sound.Sound('mainpairs/AsaAsapsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_24')
sound_vowels_24.setVolume(1.0)
text_116 = visual.TextStim(win=win, name='text_116',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_117 = visual.TextStim(win=win, name='text_117',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_118 = visual.TextStim(win=win, name='text_118',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_119 = visual.TextStim(win=win, name='text_119',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_120 = visual.TextStim(win=win, name='text_120',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_24 = keyboard.Keyboard()

# --- Initialize components for Routine "uja" ---
sound_vowels_34 = sound.Sound('mainpairs/uja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_34')
sound_vowels_34.setVolume(1.0)
text_166 = visual.TextStim(win=win, name='text_166',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_167 = visual.TextStim(win=win, name='text_167',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_168 = visual.TextStim(win=win, name='text_168',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_169 = visual.TextStim(win=win, name='text_169',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_170 = visual.TextStim(win=win, name='text_170',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_34 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_sapsa" ---
sound_vowels_67 = sound.Sound('mainpairs/sa.ja+sapsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_67')
sound_vowels_67.setVolume(1.0)
text_331 = visual.TextStim(win=win, name='text_331',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_332 = visual.TextStim(win=win, name='text_332',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_333 = visual.TextStim(win=win, name='text_333',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_334 = visual.TextStim(win=win, name='text_334',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_335 = visual.TextStim(win=win, name='text_335',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_67 = keyboard.Keyboard()

# --- Initialize components for Routine "u" ---
sound_vowels_31 = sound.Sound('mainpairs/u.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_31')
sound_vowels_31.setVolume(1.0)
text_151 = visual.TextStim(win=win, name='text_151',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_152 = visual.TextStim(win=win, name='text_152',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_153 = visual.TextStim(win=win, name='text_153',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_154 = visual.TextStim(win=win, name='text_154',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_155 = visual.TextStim(win=win, name='text_155',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_31 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_sapja" ---
sound_vowels_66 = sound.Sound('mainpairs/sa.ja+sapja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_66')
sound_vowels_66.setVolume(1.0)
text_326 = visual.TextStim(win=win, name='text_326',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_327 = visual.TextStim(win=win, name='text_327',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_328 = visual.TextStim(win=win, name='text_328',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_329 = visual.TextStim(win=win, name='text_329',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_330 = visual.TextStim(win=win, name='text_330',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_66 = keyboard.Keyboard()

# --- Initialize components for Routine "jopA" ---
sound_vowels_32 = sound.Sound('mainpairs/jopA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_32')
sound_vowels_32.setVolume(1.0)
text_156 = visual.TextStim(win=win, name='text_156',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_157 = visual.TextStim(win=win, name='text_157',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_158 = visual.TextStim(win=win, name='text_158',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_159 = visual.TextStim(win=win, name='text_159',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_160 = visual.TextStim(win=win, name='text_160',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_32 = keyboard.Keyboard()

# --- Initialize components for Routine "usoupso" ---
sound_vowels_16 = sound.Sound('mainpairs/usoupso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_16')
sound_vowels_16.setVolume(1.0)
text_76 = visual.TextStim(win=win, name='text_76',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_77 = visual.TextStim(win=win, name='text_77',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_78 = visual.TextStim(win=win, name='text_78',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_79 = visual.TextStim(win=win, name='text_79',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_80 = visual.TextStim(win=win, name='text_80',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_16 = keyboard.Keyboard()

# --- Initialize components for Routine "sosojopjo" ---
sound_vowels_56 = sound.Sound('mainpairs/sosojopjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_56')
sound_vowels_56.setVolume(1.0)
text_276 = visual.TextStim(win=win, name='text_276',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_277 = visual.TextStim(win=win, name='text_277',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_278 = visual.TextStim(win=win, name='text_278',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_279 = visual.TextStim(win=win, name='text_279',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_280 = visual.TextStim(win=win, name='text_280',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_56 = keyboard.Keyboard()

# --- Initialize components for Routine "sosa" ---
sound_vowels_35 = sound.Sound('mainpairs/sosa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_35')
sound_vowels_35.setVolume(1.0)
text_171 = visual.TextStim(win=win, name='text_171',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_172 = visual.TextStim(win=win, name='text_172',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_173 = visual.TextStim(win=win, name='text_173',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_174 = visual.TextStim(win=win, name='text_174',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_175 = visual.TextStim(win=win, name='text_175',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_35 = keyboard.Keyboard()

# --- Initialize components for Routine "A" ---
sound_vowels_9 = sound.Sound('mainpairs/A.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_9')
sound_vowels_9.setVolume(1.0)
text_41 = visual.TextStim(win=win, name='text_41',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_42 = visual.TextStim(win=win, name='text_42',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_43 = visual.TextStim(win=win, name='text_43',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_44 = visual.TextStim(win=win, name='text_44',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_45 = visual.TextStim(win=win, name='text_45',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_9 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_japsa" ---
sound_vowels_63 = sound.Sound('mainpairs/sa.ja+japsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_63')
sound_vowels_63.setVolume(1.0)
text_311 = visual.TextStim(win=win, name='text_311',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_312 = visual.TextStim(win=win, name='text_312',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_313 = visual.TextStim(win=win, name='text_313',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_314 = visual.TextStim(win=win, name='text_314',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_315 = visual.TextStim(win=win, name='text_315',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_63 = keyboard.Keyboard()

# --- Initialize components for Routine "Apsa" ---
sound_vowels_20 = sound.Sound('mainpairs/Apsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_20')
sound_vowels_20.setVolume(1.0)
text_96 = visual.TextStim(win=win, name='text_96',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_97 = visual.TextStim(win=win, name='text_97',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_98 = visual.TextStim(win=win, name='text_98',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_99 = visual.TextStim(win=win, name='text_99',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_100 = visual.TextStim(win=win, name='text_100',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_20 = keyboard.Keyboard()

# --- Initialize components for Routine "sa_ja_sa_japsa" ---
sound_vowels_65 = sound.Sound('mainpairs/sa.ja+sa.japsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_65')
sound_vowels_65.setVolume(1.0)
text_321 = visual.TextStim(win=win, name='text_321',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_322 = visual.TextStim(win=win, name='text_322',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_323 = visual.TextStim(win=win, name='text_323',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_324 = visual.TextStim(win=win, name='text_324',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_325 = visual.TextStim(win=win, name='text_325',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_65 = keyboard.Keyboard()

# --- Initialize components for Routine "A_jo_A" ---
sound_vowels_11 = sound.Sound('mainpairs/A+jo.A.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_11')
sound_vowels_11.setVolume(1.0)
text_51 = visual.TextStim(win=win, name='text_51',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_52 = visual.TextStim(win=win, name='text_52',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_53 = visual.TextStim(win=win, name='text_53',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_54 = visual.TextStim(win=win, name='text_54',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_55 = visual.TextStim(win=win, name='text_55',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_11 = keyboard.Keyboard()

# --- Initialize components for Routine "jo" ---
sound_vowels_27 = sound.Sound('mainpairs/jo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_27')
sound_vowels_27.setVolume(1.0)
text_131 = visual.TextStim(win=win, name='text_131',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_132 = visual.TextStim(win=win, name='text_132',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_133 = visual.TextStim(win=win, name='text_133',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_134 = visual.TextStim(win=win, name='text_134',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_135 = visual.TextStim(win=win, name='text_135',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_27 = keyboard.Keyboard()

# --- Initialize components for Routine "so" ---
sound_vowels_29 = sound.Sound('mainpairs/so.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_29')
sound_vowels_29.setVolume(1.0)
text_141 = visual.TextStim(win=win, name='text_141',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_142 = visual.TextStim(win=win, name='text_142',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_143 = visual.TextStim(win=win, name='text_143',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_144 = visual.TextStim(win=win, name='text_144',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_145 = visual.TextStim(win=win, name='text_145',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_29 = keyboard.Keyboard()

# --- Initialize components for Routine "joja" ---
sound_vowels_28 = sound.Sound('mainpairs/joja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_28')
sound_vowels_28.setVolume(1.0)
text_136 = visual.TextStim(win=win, name='text_136',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_137 = visual.TextStim(win=win, name='text_137',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_138 = visual.TextStim(win=win, name='text_138',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_139 = visual.TextStim(win=win, name='text_139',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_140 = visual.TextStim(win=win, name='text_140',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_28 = keyboard.Keyboard()

# --- Initialize components for Routine "ja" ---
sound_vowels_26 = sound.Sound('mainpairs/ja.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_26')
sound_vowels_26.setVolume(1.0)
text_126 = visual.TextStim(win=win, name='text_126',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_127 = visual.TextStim(win=win, name='text_127',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_128 = visual.TextStim(win=win, name='text_128',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_129 = visual.TextStim(win=win, name='text_129',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_130 = visual.TextStim(win=win, name='text_130',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_26 = keyboard.Keyboard()

# --- Initialize components for Routine "AsasapA" ---
sound_vowels_25 = sound.Sound('mainpairs/AsasapA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_25')
sound_vowels_25.setVolume(1.0)
text_121 = visual.TextStim(win=win, name='text_121',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_122 = visual.TextStim(win=win, name='text_122',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_123 = visual.TextStim(win=win, name='text_123',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_124 = visual.TextStim(win=win, name='text_124',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_125 = visual.TextStim(win=win, name='text_125',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_25 = keyboard.Keyboard()

# --- Initialize components for Routine "AjoApA" ---
sound_vowels_14 = sound.Sound('mainpairs/AjoApA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_14')
sound_vowels_14.setVolume(1.0)
text_66 = visual.TextStim(win=win, name='text_66',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_67 = visual.TextStim(win=win, name='text_67',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_68 = visual.TextStim(win=win, name='text_68',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_69 = visual.TextStim(win=win, name='text_69',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_70 = visual.TextStim(win=win, name='text_70',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_14 = keyboard.Keyboard()

# --- Initialize components for Routine "A_A_sa" ---
sound_vowels_10 = sound.Sound('mainpairs/A+A.sa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_10')
sound_vowels_10.setVolume(1.0)
text_46 = visual.TextStim(win=win, name='text_46',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_47 = visual.TextStim(win=win, name='text_47',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_48 = visual.TextStim(win=win, name='text_48',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_49 = visual.TextStim(win=win, name='text_49',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_50 = visual.TextStim(win=win, name='text_50',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_10 = keyboard.Keyboard()

# --- Initialize components for Routine "sa" ---
sound_vowels_30 = sound.Sound('mainpairs/sa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_30')
sound_vowels_30.setVolume(1.0)
text_146 = visual.TextStim(win=win, name='text_146',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_147 = visual.TextStim(win=win, name='text_147',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_148 = visual.TextStim(win=win, name='text_148',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_149 = visual.TextStim(win=win, name='text_149',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_150 = visual.TextStim(win=win, name='text_150',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_30 = keyboard.Keyboard()

# --- Initialize components for Routine "AsaAsapA" ---
sound_vowels_23 = sound.Sound('mainpairs/AsaAsapA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_23')
sound_vowels_23.setVolume(1.0)
text_111 = visual.TextStim(win=win, name='text_111',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_112 = visual.TextStim(win=win, name='text_112',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_113 = visual.TextStim(win=win, name='text_113',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_114 = visual.TextStim(win=win, name='text_114',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_115 = visual.TextStim(win=win, name='text_115',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_23 = keyboard.Keyboard()

# --- Initialize components for Routine "usousopso" ---
sound_vowels_15 = sound.Sound('mainpairs/usousopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_15')
sound_vowels_15.setVolume(1.0)
text_71 = visual.TextStim(win=win, name='text_71',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_72 = visual.TextStim(win=win, name='text_72',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_73 = visual.TextStim(win=win, name='text_73',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_74 = visual.TextStim(win=win, name='text_74',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_75 = visual.TextStim(win=win, name='text_75',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_15 = keyboard.Keyboard()

# --- Initialize components for Routine "AAsapA" ---
sound_vowels_12 = sound.Sound('mainpairs/AAsapA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_12')
sound_vowels_12.setVolume(1.0)
text_56 = visual.TextStim(win=win, name='text_56',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_57 = visual.TextStim(win=win, name='text_57',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_58 = visual.TextStim(win=win, name='text_58',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_59 = visual.TextStim(win=win, name='text_59',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_60 = visual.TextStim(win=win, name='text_60',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_12 = keyboard.Keyboard()

# --- Initialize components for Routine "AjoApjo" ---
sound_vowels_19 = sound.Sound('mainpairs/AjoApjo.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_19')
sound_vowels_19.setVolume(1.0)
text_91 = visual.TextStim(win=win, name='text_91',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_92 = visual.TextStim(win=win, name='text_92',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_93 = visual.TextStim(win=win, name='text_93',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_94 = visual.TextStim(win=win, name='text_94',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_95 = visual.TextStim(win=win, name='text_95',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_19 = keyboard.Keyboard()

# --- Initialize components for Routine "AAsapsa" ---
sound_vowels_13 = sound.Sound('mainpairs/AAsapsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_13')
sound_vowels_13.setVolume(1.0)
text_61 = visual.TextStim(win=win, name='text_61',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_62 = visual.TextStim(win=win, name='text_62',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_63 = visual.TextStim(win=win, name='text_63',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_64 = visual.TextStim(win=win, name='text_64',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_65 = visual.TextStim(win=win, name='text_65',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_13 = keyboard.Keyboard()

# --- Initialize components for Routine "usosopso" ---
sound_vowels_17 = sound.Sound('mainpairs/usosopso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_17')
sound_vowels_17.setVolume(1.0)
text_81 = visual.TextStim(win=win, name='text_81',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_82 = visual.TextStim(win=win, name='text_82',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_83 = visual.TextStim(win=win, name='text_83',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_84 = visual.TextStim(win=win, name='text_84',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_85 = visual.TextStim(win=win, name='text_85',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_17 = keyboard.Keyboard()

# --- Initialize components for Routine "A_sa_A_" ---
sound_vowels_3 = sound.Sound('mainpairs/A.sa+A.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_3')
sound_vowels_3.setVolume(1.0)
text_11 = visual.TextStim(win=win, name='text_11',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_12 = visual.TextStim(win=win, name='text_12',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_13 = visual.TextStim(win=win, name='text_13',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_14 = visual.TextStim(win=win, name='text_14',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_15 = visual.TextStim(win=win, name='text_15',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_3 = keyboard.Keyboard()

# --- Initialize components for Routine "u_u_so" ---
sound_vowels_4 = sound.Sound('mainpairs/u+u.so.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_4')
sound_vowels_4.setVolume(1.0)
text_16 = visual.TextStim(win=win, name='text_16',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_17 = visual.TextStim(win=win, name='text_17',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_18 = visual.TextStim(win=win, name='text_18',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_19 = visual.TextStim(win=win, name='text_19',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_20 = visual.TextStim(win=win, name='text_20',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_4 = keyboard.Keyboard()

# --- Initialize components for Routine "AsaApA" ---
sound_vowels_21 = sound.Sound('mainpairs/AsaApA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_21')
sound_vowels_21.setVolume(1.0)
text_101 = visual.TextStim(win=win, name='text_101',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_102 = visual.TextStim(win=win, name='text_102',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_103 = visual.TextStim(win=win, name='text_103',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_104 = visual.TextStim(win=win, name='text_104',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_105 = visual.TextStim(win=win, name='text_105',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_21 = keyboard.Keyboard()

# --- Initialize components for Routine "upso" ---
sound_vowels_18 = sound.Sound('mainpairs/upso.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_18')
sound_vowels_18.setVolume(1.0)
text_86 = visual.TextStim(win=win, name='text_86',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_87 = visual.TextStim(win=win, name='text_87',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_88 = visual.TextStim(win=win, name='text_88',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_89 = visual.TextStim(win=win, name='text_89',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_90 = visual.TextStim(win=win, name='text_90',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_18 = keyboard.Keyboard()

# --- Initialize components for Routine "AsaApsa" ---
sound_vowels_22 = sound.Sound('mainpairs/AsaApsa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_22')
sound_vowels_22.setVolume(1.0)
text_106 = visual.TextStim(win=win, name='text_106',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_107 = visual.TextStim(win=win, name='text_107',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_108 = visual.TextStim(win=win, name='text_108',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_109 = visual.TextStim(win=win, name='text_109',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_110 = visual.TextStim(win=win, name='text_110',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_22 = keyboard.Keyboard()

# --- Initialize components for Routine "joAjoApA" ---
sound_vowels_5 = sound.Sound('mainpairs/joAjoApA.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_5')
sound_vowels_5.setVolume(1.0)
text_21 = visual.TextStim(win=win, name='text_21',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_22 = visual.TextStim(win=win, name='text_22',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_23 = visual.TextStim(win=win, name='text_23',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_24 = visual.TextStim(win=win, name='text_24',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_25 = visual.TextStim(win=win, name='text_25',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_5 = keyboard.Keyboard()

# --- Initialize components for Routine "A_sa_sa" ---
sound_vowels_7 = sound.Sound('mainpairs/A.sa+sa.wav', secs=-1, stereo=True, hamming=True,
    name='sound_vowels_7')
sound_vowels_7.setVolume(1.0)
text_31 = visual.TextStim(win=win, name='text_31',
    text='Next vowels will be played.\n\n',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-1.0);
text_32 = visual.TextStim(win=win, name='text_32',
    text='If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-2.0);
text_33 = visual.TextStim(win=win, name='text_33',
    text='3',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-3.0);
text_34 = visual.TextStim(win=win, name='text_34',
    text='2',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-4.0);
text_35 = visual.TextStim(win=win, name='text_35',
    text='1',
    font='Open Sans',
    pos=(0, 0), height=0.05, wrapWidth=None, ori=0.0, 
    color='white', colorSpace='rgb', opacity=None, 
    languageStyle='LTR',
    depth=-5.0);
key_resp_7 = keyboard.Keyboard()

# Create some handy timers
globalClock = core.Clock()  # to track the time since experiment started
routineTimer = core.Clock()  # to track time remaining of each (possibly non-slip) routine 

# --- Prepare to start Routine "trial" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels.setSound('mainpairs/joja.wav', secs=3.5, hamming=True)
sound_vowels.setVolume(1.0, log=False)
key_resp.keys = []
key_resp.rt = []
_key_resp_allKeys = []
# keep track of which components have finished
trialComponents = [sound_vowels, text, text_2, text_3, text_4, text_5, key_resp]
for thisComponent in trialComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "trial" ---
while continueRoutine and routineTimer.getTime() < 23.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels
    if sound_vowels.status == NOT_STARTED and tThisFlip >= 9-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels.frameNStart = frameN  # exact frame index
        sound_vowels.tStart = t  # local t and not account for scr refresh
        sound_vowels.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels.started', tThisFlipGlobal)
        sound_vowels.play(when=win)  # sync with win flip
    if sound_vowels.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels.tStop = t  # not accounting for scr refresh
            sound_vowels.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels.stopped')
            sound_vowels.stop()
    
    # *text* updates
    if text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text.frameNStart = frameN  # exact frame index
        text.tStart = t  # local t and not account for scr refresh
        text.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text.started')
        text.setAutoDraw(True)
    if text.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text.tStartRefresh + 5.0-frameTolerance:
            # keep track of stop time/frame for later
            text.tStop = t  # not accounting for scr refresh
            text.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text.stopped')
            text.setAutoDraw(False)
    
    # *text_2* updates
    if text_2.status == NOT_STARTED and tThisFlip >= 13.0-frameTolerance:
        # keep track of start time/frame for later
        text_2.frameNStart = frameN  # exact frame index
        text_2.tStart = t  # local t and not account for scr refresh
        text_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_2.started')
        text_2.setAutoDraw(True)
    if text_2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_2.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_2.tStop = t  # not accounting for scr refresh
            text_2.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_2.stopped')
            text_2.setAutoDraw(False)
    
    # *text_3* updates
    if text_3.status == NOT_STARTED and tThisFlip >= 6-frameTolerance:
        # keep track of start time/frame for later
        text_3.frameNStart = frameN  # exact frame index
        text_3.tStart = t  # local t and not account for scr refresh
        text_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_3, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_3.started')
        text_3.setAutoDraw(True)
    if text_3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_3.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_3.tStop = t  # not accounting for scr refresh
            text_3.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_3.stopped')
            text_3.setAutoDraw(False)
    
    # *text_4* updates
    if text_4.status == NOT_STARTED and tThisFlip >= 7.0-frameTolerance:
        # keep track of start time/frame for later
        text_4.frameNStart = frameN  # exact frame index
        text_4.tStart = t  # local t and not account for scr refresh
        text_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_4, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_4.started')
        text_4.setAutoDraw(True)
    if text_4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_4.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_4.tStop = t  # not accounting for scr refresh
            text_4.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_4.stopped')
            text_4.setAutoDraw(False)
    
    # *text_5* updates
    if text_5.status == NOT_STARTED and tThisFlip >= 8.0-frameTolerance:
        # keep track of start time/frame for later
        text_5.frameNStart = frameN  # exact frame index
        text_5.tStart = t  # local t and not account for scr refresh
        text_5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_5, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_5.started')
        text_5.setAutoDraw(True)
    if text_5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_5.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_5.tStop = t  # not accounting for scr refresh
            text_5.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_5.stopped')
            text_5.setAutoDraw(False)
    
    # *key_resp* updates
    waitOnFlip = False
    if key_resp.status == NOT_STARTED and tThisFlip >= 13.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp.frameNStart = frameN  # exact frame index
        key_resp.tStart = t  # local t and not account for scr refresh
        key_resp.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp.started')
        key_resp.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp.tStop = t  # not accounting for scr refresh
            key_resp.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp.stopped')
            key_resp.status = FINISHED
    if key_resp.status == STARTED and not waitOnFlip:
        theseKeys = key_resp.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_allKeys.extend(theseKeys)
        if len(_key_resp_allKeys):
            key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
            key_resp.rt = _key_resp_allKeys[-1].rt
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in trialComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "trial" ---
for thisComponent in trialComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp.keys in ['', [], None]:  # No response was made
    key_resp.keys = None
thisExp.addData('key_resp.keys',key_resp.keys)
if key_resp.keys != None:  # we had a response
    thisExp.addData('key_resp.rt', key_resp.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-23.000000)

# --- Prepare to start Routine "A_sa_A_sasecond" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
A_saandA_sa.setSound('mainpairs/A.sa+A.sa.wav', secs=3.5, hamming=True)
A_saandA_sa.setVolume(1.0, log=False)
key_resp_2.keys = []
key_resp_2.rt = []
_key_resp_2_allKeys = []
# keep track of which components have finished
A_sa_A_sasecondComponents = [A_saandA_sa, text_6, text_7, text_8, text_9, text_10, key_resp_2]
for thisComponent in A_sa_A_sasecondComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "A_sa_A_sasecond" ---
while continueRoutine and routineTimer.getTime() < 23.5:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop A_saandA_sa
    if A_saandA_sa.status == NOT_STARTED and tThisFlip >= 9-frameTolerance:
        # keep track of start time/frame for later
        A_saandA_sa.frameNStart = frameN  # exact frame index
        A_saandA_sa.tStart = t  # local t and not account for scr refresh
        A_saandA_sa.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('A_saandA_sa.started', tThisFlipGlobal)
        A_saandA_sa.play(when=win)  # sync with win flip
    if A_saandA_sa.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > A_saandA_sa.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            A_saandA_sa.tStop = t  # not accounting for scr refresh
            A_saandA_sa.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'A_saandA_sa.stopped')
            A_saandA_sa.stop()
    
    # *text_6* updates
    if text_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_6.frameNStart = frameN  # exact frame index
        text_6.tStart = t  # local t and not account for scr refresh
        text_6.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_6, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_6.started')
        text_6.setAutoDraw(True)
    if text_6.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_6.tStartRefresh + 5.0-frameTolerance:
            # keep track of stop time/frame for later
            text_6.tStop = t  # not accounting for scr refresh
            text_6.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_6.stopped')
            text_6.setAutoDraw(False)
    
    # *text_7* updates
    if text_7.status == NOT_STARTED and tThisFlip >= 13.5-frameTolerance:
        # keep track of start time/frame for later
        text_7.frameNStart = frameN  # exact frame index
        text_7.tStart = t  # local t and not account for scr refresh
        text_7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_7, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_7.started')
        text_7.setAutoDraw(True)
    if text_7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_7.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_7.tStop = t  # not accounting for scr refresh
            text_7.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_7.stopped')
            text_7.setAutoDraw(False)
    
    # *text_8* updates
    if text_8.status == NOT_STARTED and tThisFlip >= 6-frameTolerance:
        # keep track of start time/frame for later
        text_8.frameNStart = frameN  # exact frame index
        text_8.tStart = t  # local t and not account for scr refresh
        text_8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_8, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_8.started')
        text_8.setAutoDraw(True)
    if text_8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_8.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_8.tStop = t  # not accounting for scr refresh
            text_8.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_8.stopped')
            text_8.setAutoDraw(False)
    
    # *text_9* updates
    if text_9.status == NOT_STARTED and tThisFlip >= 7.0-frameTolerance:
        # keep track of start time/frame for later
        text_9.frameNStart = frameN  # exact frame index
        text_9.tStart = t  # local t and not account for scr refresh
        text_9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_9, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_9.started')
        text_9.setAutoDraw(True)
    if text_9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_9.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_9.tStop = t  # not accounting for scr refresh
            text_9.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_9.stopped')
            text_9.setAutoDraw(False)
    
    # *text_10* updates
    if text_10.status == NOT_STARTED and tThisFlip >= 8.0-frameTolerance:
        # keep track of start time/frame for later
        text_10.frameNStart = frameN  # exact frame index
        text_10.tStart = t  # local t and not account for scr refresh
        text_10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_10, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_10.started')
        text_10.setAutoDraw(True)
    if text_10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_10.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_10.tStop = t  # not accounting for scr refresh
            text_10.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_10.stopped')
            text_10.setAutoDraw(False)
    
    # *key_resp_2* updates
    waitOnFlip = False
    if key_resp_2.status == NOT_STARTED and tThisFlip >= 13.5-frameTolerance:
        # keep track of start time/frame for later
        key_resp_2.frameNStart = frameN  # exact frame index
        key_resp_2.tStart = t  # local t and not account for scr refresh
        key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_2.started')
        key_resp_2.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_2.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_2.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_2.tStop = t  # not accounting for scr refresh
            key_resp_2.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_2.stopped')
            key_resp_2.status = FINISHED
    if key_resp_2.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_2.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_2_allKeys.extend(theseKeys)
        if len(_key_resp_2_allKeys):
            key_resp_2.keys = _key_resp_2_allKeys[-1].name  # just the last key pressed
            key_resp_2.rt = _key_resp_2_allKeys[-1].rt
            # was this correct?
            if (key_resp_2.keys == str('y')) or (key_resp_2.keys == 'y'):
                key_resp_2.corr = 1
            else:
                key_resp_2.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in A_sa_A_sasecondComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "A_sa_A_sasecond" ---
for thisComponent in A_sa_A_sasecondComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
A_saandA_sa.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_2.keys in ['', [], None]:  # No response was made
    key_resp_2.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_2.corr = 1;  # correct non-response
    else:
       key_resp_2.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_2.keys',key_resp_2.keys)
thisExp.addData('key_resp_2.corr', key_resp_2.corr)
if key_resp_2.keys != None:  # we had a response
    thisExp.addData('key_resp_2.rt', key_resp_2.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-23.500000)

# --- Prepare to start Routine "usousopu" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_91.setSound('mainpairs/usousopu.wav', secs=3.5, hamming=True)
sound_vowels_91.setVolume(1.0, log=False)
key_resp_91.keys = []
key_resp_91.rt = []
_key_resp_91_allKeys = []
# keep track of which components have finished
usousopuComponents = [sound_vowels_91, text_451, text_452, text_453, text_454, text_455, key_resp_91]
for thisComponent in usousopuComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "usousopu" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_91
    if sound_vowels_91.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_91.frameNStart = frameN  # exact frame index
        sound_vowels_91.tStart = t  # local t and not account for scr refresh
        sound_vowels_91.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_91.started', tThisFlipGlobal)
        sound_vowels_91.play(when=win)  # sync with win flip
    if sound_vowels_91.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_91.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_91.tStop = t  # not accounting for scr refresh
            sound_vowels_91.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_91.stopped')
            sound_vowels_91.stop()
    
    # *text_451* updates
    if text_451.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_451.frameNStart = frameN  # exact frame index
        text_451.tStart = t  # local t and not account for scr refresh
        text_451.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_451, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_451.started')
        text_451.setAutoDraw(True)
    if text_451.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_451.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_451.tStop = t  # not accounting for scr refresh
            text_451.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_451.stopped')
            text_451.setAutoDraw(False)
    
    # *text_452* updates
    if text_452.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_452.frameNStart = frameN  # exact frame index
        text_452.tStart = t  # local t and not account for scr refresh
        text_452.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_452, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_452.started')
        text_452.setAutoDraw(True)
    if text_452.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_452.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_452.tStop = t  # not accounting for scr refresh
            text_452.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_452.stopped')
            text_452.setAutoDraw(False)
    
    # *text_453* updates
    if text_453.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_453.frameNStart = frameN  # exact frame index
        text_453.tStart = t  # local t and not account for scr refresh
        text_453.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_453, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_453.started')
        text_453.setAutoDraw(True)
    if text_453.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_453.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_453.tStop = t  # not accounting for scr refresh
            text_453.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_453.stopped')
            text_453.setAutoDraw(False)
    
    # *text_454* updates
    if text_454.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_454.frameNStart = frameN  # exact frame index
        text_454.tStart = t  # local t and not account for scr refresh
        text_454.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_454, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_454.started')
        text_454.setAutoDraw(True)
    if text_454.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_454.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_454.tStop = t  # not accounting for scr refresh
            text_454.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_454.stopped')
            text_454.setAutoDraw(False)
    
    # *text_455* updates
    if text_455.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_455.frameNStart = frameN  # exact frame index
        text_455.tStart = t  # local t and not account for scr refresh
        text_455.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_455, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_455.started')
        text_455.setAutoDraw(True)
    if text_455.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_455.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_455.tStop = t  # not accounting for scr refresh
            text_455.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_455.stopped')
            text_455.setAutoDraw(False)
    
    # *key_resp_91* updates
    waitOnFlip = False
    if key_resp_91.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_91.frameNStart = frameN  # exact frame index
        key_resp_91.tStart = t  # local t and not account for scr refresh
        key_resp_91.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_91, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_91.started')
        key_resp_91.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_91.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_91.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_91.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_91.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_91.tStop = t  # not accounting for scr refresh
            key_resp_91.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_91.stopped')
            key_resp_91.status = FINISHED
    if key_resp_91.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_91.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_91_allKeys.extend(theseKeys)
        if len(_key_resp_91_allKeys):
            key_resp_91.keys = _key_resp_91_allKeys[-1].name  # just the last key pressed
            key_resp_91.rt = _key_resp_91_allKeys[-1].rt
            # was this correct?
            if (key_resp_91.keys == str('n')) or (key_resp_91.keys == 'n'):
                key_resp_91.corr = 1
            else:
                key_resp_91.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in usousopuComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "usousopu" ---
for thisComponent in usousopuComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_91.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_91.keys in ['', [], None]:  # No response was made
    key_resp_91.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_91.corr = 1;  # correct non-response
    else:
       key_resp_91.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_91.keys',key_resp_91.keys)
thisExp.addData('key_resp_91.corr', key_resp_91.corr)
if key_resp_91.keys != None:  # we had a response
    thisExp.addData('key_resp_91.rt', key_resp_91.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "uusopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_92.setSound('mainpairs/uusopso.wav', secs=3.5, hamming=True)
sound_vowels_92.setVolume(1.0, log=False)
key_resp_92.keys = []
key_resp_92.rt = []
_key_resp_92_allKeys = []
# keep track of which components have finished
uusopsoComponents = [sound_vowels_92, text_456, text_457, text_458, text_459, text_460, key_resp_92]
for thisComponent in uusopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "uusopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_92
    if sound_vowels_92.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_92.frameNStart = frameN  # exact frame index
        sound_vowels_92.tStart = t  # local t and not account for scr refresh
        sound_vowels_92.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_92.started', tThisFlipGlobal)
        sound_vowels_92.play(when=win)  # sync with win flip
    if sound_vowels_92.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_92.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_92.tStop = t  # not accounting for scr refresh
            sound_vowels_92.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_92.stopped')
            sound_vowels_92.stop()
    
    # *text_456* updates
    if text_456.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_456.frameNStart = frameN  # exact frame index
        text_456.tStart = t  # local t and not account for scr refresh
        text_456.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_456, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_456.started')
        text_456.setAutoDraw(True)
    if text_456.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_456.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_456.tStop = t  # not accounting for scr refresh
            text_456.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_456.stopped')
            text_456.setAutoDraw(False)
    
    # *text_457* updates
    if text_457.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_457.frameNStart = frameN  # exact frame index
        text_457.tStart = t  # local t and not account for scr refresh
        text_457.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_457, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_457.started')
        text_457.setAutoDraw(True)
    if text_457.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_457.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_457.tStop = t  # not accounting for scr refresh
            text_457.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_457.stopped')
            text_457.setAutoDraw(False)
    
    # *text_458* updates
    if text_458.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_458.frameNStart = frameN  # exact frame index
        text_458.tStart = t  # local t and not account for scr refresh
        text_458.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_458, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_458.started')
        text_458.setAutoDraw(True)
    if text_458.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_458.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_458.tStop = t  # not accounting for scr refresh
            text_458.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_458.stopped')
            text_458.setAutoDraw(False)
    
    # *text_459* updates
    if text_459.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_459.frameNStart = frameN  # exact frame index
        text_459.tStart = t  # local t and not account for scr refresh
        text_459.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_459, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_459.started')
        text_459.setAutoDraw(True)
    if text_459.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_459.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_459.tStop = t  # not accounting for scr refresh
            text_459.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_459.stopped')
            text_459.setAutoDraw(False)
    
    # *text_460* updates
    if text_460.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_460.frameNStart = frameN  # exact frame index
        text_460.tStart = t  # local t and not account for scr refresh
        text_460.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_460, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_460.started')
        text_460.setAutoDraw(True)
    if text_460.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_460.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_460.tStop = t  # not accounting for scr refresh
            text_460.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_460.stopped')
            text_460.setAutoDraw(False)
    
    # *key_resp_92* updates
    waitOnFlip = False
    if key_resp_92.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_92.frameNStart = frameN  # exact frame index
        key_resp_92.tStart = t  # local t and not account for scr refresh
        key_resp_92.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_92, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_92.started')
        key_resp_92.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_92.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_92.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_92.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_92.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_92.tStop = t  # not accounting for scr refresh
            key_resp_92.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_92.stopped')
            key_resp_92.status = FINISHED
    if key_resp_92.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_92.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_92_allKeys.extend(theseKeys)
        if len(_key_resp_92_allKeys):
            key_resp_92.keys = _key_resp_92_allKeys[-1].name  # just the last key pressed
            key_resp_92.rt = _key_resp_92_allKeys[-1].rt
            # was this correct?
            if (key_resp_92.keys == str('n')) or (key_resp_92.keys == 'n'):
                key_resp_92.corr = 1
            else:
                key_resp_92.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in uusopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "uusopso" ---
for thisComponent in uusopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_92.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_92.keys in ['', [], None]:  # No response was made
    key_resp_92.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_92.corr = 1;  # correct non-response
    else:
       key_resp_92.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_92.keys',key_resp_92.keys)
thisExp.addData('key_resp_92.corr', key_resp_92.corr)
if key_resp_92.keys != None:  # we had a response
    thisExp.addData('key_resp_92.rt', key_resp_92.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sousopu" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_85.setSound('mainpairs/sousopu.wav', secs=3.5, hamming=True)
sound_vowels_85.setVolume(1.0, log=False)
key_resp_85.keys = []
key_resp_85.rt = []
_key_resp_85_allKeys = []
# keep track of which components have finished
sousopuComponents = [sound_vowels_85, text_421, text_422, text_423, text_424, text_425, key_resp_85]
for thisComponent in sousopuComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sousopu" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_85
    if sound_vowels_85.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_85.frameNStart = frameN  # exact frame index
        sound_vowels_85.tStart = t  # local t and not account for scr refresh
        sound_vowels_85.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_85.started', tThisFlipGlobal)
        sound_vowels_85.play(when=win)  # sync with win flip
    if sound_vowels_85.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_85.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_85.tStop = t  # not accounting for scr refresh
            sound_vowels_85.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_85.stopped')
            sound_vowels_85.stop()
    
    # *text_421* updates
    if text_421.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_421.frameNStart = frameN  # exact frame index
        text_421.tStart = t  # local t and not account for scr refresh
        text_421.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_421, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_421.started')
        text_421.setAutoDraw(True)
    if text_421.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_421.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_421.tStop = t  # not accounting for scr refresh
            text_421.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_421.stopped')
            text_421.setAutoDraw(False)
    
    # *text_422* updates
    if text_422.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_422.frameNStart = frameN  # exact frame index
        text_422.tStart = t  # local t and not account for scr refresh
        text_422.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_422, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_422.started')
        text_422.setAutoDraw(True)
    if text_422.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_422.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_422.tStop = t  # not accounting for scr refresh
            text_422.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_422.stopped')
            text_422.setAutoDraw(False)
    
    # *text_423* updates
    if text_423.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_423.frameNStart = frameN  # exact frame index
        text_423.tStart = t  # local t and not account for scr refresh
        text_423.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_423, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_423.started')
        text_423.setAutoDraw(True)
    if text_423.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_423.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_423.tStop = t  # not accounting for scr refresh
            text_423.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_423.stopped')
            text_423.setAutoDraw(False)
    
    # *text_424* updates
    if text_424.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_424.frameNStart = frameN  # exact frame index
        text_424.tStart = t  # local t and not account for scr refresh
        text_424.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_424, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_424.started')
        text_424.setAutoDraw(True)
    if text_424.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_424.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_424.tStop = t  # not accounting for scr refresh
            text_424.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_424.stopped')
            text_424.setAutoDraw(False)
    
    # *text_425* updates
    if text_425.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_425.frameNStart = frameN  # exact frame index
        text_425.tStart = t  # local t and not account for scr refresh
        text_425.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_425, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_425.started')
        text_425.setAutoDraw(True)
    if text_425.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_425.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_425.tStop = t  # not accounting for scr refresh
            text_425.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_425.stopped')
            text_425.setAutoDraw(False)
    
    # *key_resp_85* updates
    waitOnFlip = False
    if key_resp_85.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_85.frameNStart = frameN  # exact frame index
        key_resp_85.tStart = t  # local t and not account for scr refresh
        key_resp_85.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_85, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_85.started')
        key_resp_85.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_85.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_85.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_85.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_85.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_85.tStop = t  # not accounting for scr refresh
            key_resp_85.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_85.stopped')
            key_resp_85.status = FINISHED
    if key_resp_85.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_85.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_85_allKeys.extend(theseKeys)
        if len(_key_resp_85_allKeys):
            key_resp_85.keys = _key_resp_85_allKeys[-1].name  # just the last key pressed
            key_resp_85.rt = _key_resp_85_allKeys[-1].rt
            # was this correct?
            if (key_resp_85.keys == str('n')) or (key_resp_85.keys == 'n'):
                key_resp_85.corr = 1
            else:
                key_resp_85.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sousopuComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sousopu" ---
for thisComponent in sousopuComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_85.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_85.keys in ['', [], None]:  # No response was made
    key_resp_85.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_85.corr = 1;  # correct non-response
    else:
       key_resp_85.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_85.keys',key_resp_85.keys)
thisExp.addData('key_resp_85.corr', key_resp_85.corr)
if key_resp_85.keys != None:  # we had a response
    thisExp.addData('key_resp_85.rt', key_resp_85.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_sa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_77.setSound('mainpairs/sa.ja+sa.wav', secs=3.5, hamming=True)
sound_vowels_77.setVolume(1.0, log=False)
key_resp_77.keys = []
key_resp_77.rt = []
_key_resp_77_allKeys = []
# keep track of which components have finished
sa_ja_saComponents = [sound_vowels_77, text_381, text_382, text_383, text_384, text_385, key_resp_77]
for thisComponent in sa_ja_saComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_sa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_77
    if sound_vowels_77.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_77.frameNStart = frameN  # exact frame index
        sound_vowels_77.tStart = t  # local t and not account for scr refresh
        sound_vowels_77.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_77.started', tThisFlipGlobal)
        sound_vowels_77.play(when=win)  # sync with win flip
    if sound_vowels_77.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_77.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_77.tStop = t  # not accounting for scr refresh
            sound_vowels_77.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_77.stopped')
            sound_vowels_77.stop()
    
    # *text_381* updates
    if text_381.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_381.frameNStart = frameN  # exact frame index
        text_381.tStart = t  # local t and not account for scr refresh
        text_381.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_381, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_381.started')
        text_381.setAutoDraw(True)
    if text_381.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_381.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_381.tStop = t  # not accounting for scr refresh
            text_381.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_381.stopped')
            text_381.setAutoDraw(False)
    
    # *text_382* updates
    if text_382.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_382.frameNStart = frameN  # exact frame index
        text_382.tStart = t  # local t and not account for scr refresh
        text_382.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_382, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_382.started')
        text_382.setAutoDraw(True)
    if text_382.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_382.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_382.tStop = t  # not accounting for scr refresh
            text_382.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_382.stopped')
            text_382.setAutoDraw(False)
    
    # *text_383* updates
    if text_383.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_383.frameNStart = frameN  # exact frame index
        text_383.tStart = t  # local t and not account for scr refresh
        text_383.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_383, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_383.started')
        text_383.setAutoDraw(True)
    if text_383.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_383.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_383.tStop = t  # not accounting for scr refresh
            text_383.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_383.stopped')
            text_383.setAutoDraw(False)
    
    # *text_384* updates
    if text_384.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_384.frameNStart = frameN  # exact frame index
        text_384.tStart = t  # local t and not account for scr refresh
        text_384.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_384, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_384.started')
        text_384.setAutoDraw(True)
    if text_384.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_384.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_384.tStop = t  # not accounting for scr refresh
            text_384.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_384.stopped')
            text_384.setAutoDraw(False)
    
    # *text_385* updates
    if text_385.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_385.frameNStart = frameN  # exact frame index
        text_385.tStart = t  # local t and not account for scr refresh
        text_385.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_385, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_385.started')
        text_385.setAutoDraw(True)
    if text_385.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_385.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_385.tStop = t  # not accounting for scr refresh
            text_385.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_385.stopped')
            text_385.setAutoDraw(False)
    
    # *key_resp_77* updates
    waitOnFlip = False
    if key_resp_77.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_77.frameNStart = frameN  # exact frame index
        key_resp_77.tStart = t  # local t and not account for scr refresh
        key_resp_77.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_77, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_77.started')
        key_resp_77.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_77.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_77.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_77.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_77.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_77.tStop = t  # not accounting for scr refresh
            key_resp_77.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_77.stopped')
            key_resp_77.status = FINISHED
    if key_resp_77.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_77.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_77_allKeys.extend(theseKeys)
        if len(_key_resp_77_allKeys):
            key_resp_77.keys = _key_resp_77_allKeys[-1].name  # just the last key pressed
            key_resp_77.rt = _key_resp_77_allKeys[-1].rt
            # was this correct?
            if (key_resp_77.keys == str('y')) or (key_resp_77.keys == 'y'):
                key_resp_77.corr = 1
            else:
                key_resp_77.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_saComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_sa" ---
for thisComponent in sa_ja_saComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_77.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_77.keys in ['', [], None]:  # No response was made
    key_resp_77.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_77.corr = 1;  # correct non-response
    else:
       key_resp_77.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_77.keys',key_resp_77.keys)
thisExp.addData('key_resp_77.corr', key_resp_77.corr)
if key_resp_77.keys != None:  # we had a response
    thisExp.addData('key_resp_77.rt', key_resp_77.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "u_so_so" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_86.setSound('mainpairs/u.so+so.wav', secs=3.5, hamming=True)
sound_vowels_86.setVolume(1.0, log=False)
key_resp_86.keys = []
key_resp_86.rt = []
_key_resp_86_allKeys = []
# keep track of which components have finished
u_so_soComponents = [sound_vowels_86, text_426, text_427, text_428, text_429, text_430, key_resp_86]
for thisComponent in u_so_soComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "u_so_so" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_86
    if sound_vowels_86.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_86.frameNStart = frameN  # exact frame index
        sound_vowels_86.tStart = t  # local t and not account for scr refresh
        sound_vowels_86.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_86.started', tThisFlipGlobal)
        sound_vowels_86.play(when=win)  # sync with win flip
    if sound_vowels_86.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_86.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_86.tStop = t  # not accounting for scr refresh
            sound_vowels_86.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_86.stopped')
            sound_vowels_86.stop()
    
    # *text_426* updates
    if text_426.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_426.frameNStart = frameN  # exact frame index
        text_426.tStart = t  # local t and not account for scr refresh
        text_426.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_426, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_426.started')
        text_426.setAutoDraw(True)
    if text_426.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_426.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_426.tStop = t  # not accounting for scr refresh
            text_426.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_426.stopped')
            text_426.setAutoDraw(False)
    
    # *text_427* updates
    if text_427.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_427.frameNStart = frameN  # exact frame index
        text_427.tStart = t  # local t and not account for scr refresh
        text_427.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_427, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_427.started')
        text_427.setAutoDraw(True)
    if text_427.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_427.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_427.tStop = t  # not accounting for scr refresh
            text_427.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_427.stopped')
            text_427.setAutoDraw(False)
    
    # *text_428* updates
    if text_428.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_428.frameNStart = frameN  # exact frame index
        text_428.tStart = t  # local t and not account for scr refresh
        text_428.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_428, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_428.started')
        text_428.setAutoDraw(True)
    if text_428.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_428.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_428.tStop = t  # not accounting for scr refresh
            text_428.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_428.stopped')
            text_428.setAutoDraw(False)
    
    # *text_429* updates
    if text_429.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_429.frameNStart = frameN  # exact frame index
        text_429.tStart = t  # local t and not account for scr refresh
        text_429.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_429, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_429.started')
        text_429.setAutoDraw(True)
    if text_429.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_429.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_429.tStop = t  # not accounting for scr refresh
            text_429.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_429.stopped')
            text_429.setAutoDraw(False)
    
    # *text_430* updates
    if text_430.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_430.frameNStart = frameN  # exact frame index
        text_430.tStart = t  # local t and not account for scr refresh
        text_430.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_430, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_430.started')
        text_430.setAutoDraw(True)
    if text_430.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_430.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_430.tStop = t  # not accounting for scr refresh
            text_430.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_430.stopped')
            text_430.setAutoDraw(False)
    
    # *key_resp_86* updates
    waitOnFlip = False
    if key_resp_86.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_86.frameNStart = frameN  # exact frame index
        key_resp_86.tStart = t  # local t and not account for scr refresh
        key_resp_86.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_86, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_86.started')
        key_resp_86.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_86.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_86.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_86.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_86.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_86.tStop = t  # not accounting for scr refresh
            key_resp_86.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_86.stopped')
            key_resp_86.status = FINISHED
    if key_resp_86.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_86.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_86_allKeys.extend(theseKeys)
        if len(_key_resp_86_allKeys):
            key_resp_86.keys = _key_resp_86_allKeys[-1].name  # just the last key pressed
            key_resp_86.rt = _key_resp_86_allKeys[-1].rt
            # was this correct?
            if (key_resp_86.keys == str('y')) or (key_resp_86.keys == 'y'):
                key_resp_86.corr = 1
            else:
                key_resp_86.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in u_so_soComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "u_so_so" ---
for thisComponent in u_so_soComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_86.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_86.keys in ['', [], None]:  # No response was made
    key_resp_86.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_86.corr = 1;  # correct non-response
    else:
       key_resp_86.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_86.keys',key_resp_86.keys)
thisExp.addData('key_resp_86.corr', key_resp_86.corr)
if key_resp_86.keys != None:  # we had a response
    thisExp.addData('key_resp_86.rt', key_resp_86.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sojojopjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_45.setSound('mainpairs/sojojopjo.wav', secs=3.5, hamming=True)
sound_vowels_45.setVolume(1.0, log=False)
key_resp_45.keys = []
key_resp_45.rt = []
_key_resp_45_allKeys = []
# keep track of which components have finished
sojojopjoComponents = [sound_vowels_45, text_221, text_222, text_223, text_224, text_225, key_resp_45]
for thisComponent in sojojopjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sojojopjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_45
    if sound_vowels_45.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_45.frameNStart = frameN  # exact frame index
        sound_vowels_45.tStart = t  # local t and not account for scr refresh
        sound_vowels_45.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_45.started', tThisFlipGlobal)
        sound_vowels_45.play(when=win)  # sync with win flip
    if sound_vowels_45.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_45.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_45.tStop = t  # not accounting for scr refresh
            sound_vowels_45.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_45.stopped')
            sound_vowels_45.stop()
    
    # *text_221* updates
    if text_221.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_221.frameNStart = frameN  # exact frame index
        text_221.tStart = t  # local t and not account for scr refresh
        text_221.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_221, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_221.started')
        text_221.setAutoDraw(True)
    if text_221.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_221.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_221.tStop = t  # not accounting for scr refresh
            text_221.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_221.stopped')
            text_221.setAutoDraw(False)
    
    # *text_222* updates
    if text_222.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_222.frameNStart = frameN  # exact frame index
        text_222.tStart = t  # local t and not account for scr refresh
        text_222.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_222, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_222.started')
        text_222.setAutoDraw(True)
    if text_222.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_222.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_222.tStop = t  # not accounting for scr refresh
            text_222.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_222.stopped')
            text_222.setAutoDraw(False)
    
    # *text_223* updates
    if text_223.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_223.frameNStart = frameN  # exact frame index
        text_223.tStart = t  # local t and not account for scr refresh
        text_223.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_223, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_223.started')
        text_223.setAutoDraw(True)
    if text_223.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_223.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_223.tStop = t  # not accounting for scr refresh
            text_223.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_223.stopped')
            text_223.setAutoDraw(False)
    
    # *text_224* updates
    if text_224.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_224.frameNStart = frameN  # exact frame index
        text_224.tStart = t  # local t and not account for scr refresh
        text_224.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_224, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_224.started')
        text_224.setAutoDraw(True)
    if text_224.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_224.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_224.tStop = t  # not accounting for scr refresh
            text_224.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_224.stopped')
            text_224.setAutoDraw(False)
    
    # *text_225* updates
    if text_225.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_225.frameNStart = frameN  # exact frame index
        text_225.tStart = t  # local t and not account for scr refresh
        text_225.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_225, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_225.started')
        text_225.setAutoDraw(True)
    if text_225.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_225.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_225.tStop = t  # not accounting for scr refresh
            text_225.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_225.stopped')
            text_225.setAutoDraw(False)
    
    # *key_resp_45* updates
    waitOnFlip = False
    if key_resp_45.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_45.frameNStart = frameN  # exact frame index
        key_resp_45.tStart = t  # local t and not account for scr refresh
        key_resp_45.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_45, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_45.started')
        key_resp_45.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_45.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_45.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_45.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_45.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_45.tStop = t  # not accounting for scr refresh
            key_resp_45.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_45.stopped')
            key_resp_45.status = FINISHED
    if key_resp_45.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_45.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_45_allKeys.extend(theseKeys)
        if len(_key_resp_45_allKeys):
            key_resp_45.keys = _key_resp_45_allKeys[-1].name  # just the last key pressed
            key_resp_45.rt = _key_resp_45_allKeys[-1].rt
            # was this correct?
            if (key_resp_45.keys == str('n')) or (key_resp_45.keys == 'n'):
                key_resp_45.corr = 1
            else:
                key_resp_45.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sojojopjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sojojopjo" ---
for thisComponent in sojojopjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_45.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_45.keys in ['', [], None]:  # No response was made
    key_resp_45.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_45.corr = 1;  # correct non-response
    else:
       key_resp_45.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_45.keys',key_resp_45.keys)
thisExp.addData('key_resp_45.corr', key_resp_45.corr)
if key_resp_45.keys != None:  # we had a response
    thisExp.addData('key_resp_45.rt', key_resp_45.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "u_so_u_so" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_87.setSound('mainpairs/u.so+u.so.wav', secs=3.5, hamming=True)
sound_vowels_87.setVolume(1.0, log=False)
key_resp_87.keys = []
key_resp_87.rt = []
_key_resp_87_allKeys = []
# keep track of which components have finished
u_so_u_soComponents = [sound_vowels_87, text_431, text_432, text_433, text_434, text_435, key_resp_87]
for thisComponent in u_so_u_soComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "u_so_u_so" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_87
    if sound_vowels_87.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_87.frameNStart = frameN  # exact frame index
        sound_vowels_87.tStart = t  # local t and not account for scr refresh
        sound_vowels_87.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_87.started', tThisFlipGlobal)
        sound_vowels_87.play(when=win)  # sync with win flip
    if sound_vowels_87.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_87.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_87.tStop = t  # not accounting for scr refresh
            sound_vowels_87.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_87.stopped')
            sound_vowels_87.stop()
    
    # *text_431* updates
    if text_431.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_431.frameNStart = frameN  # exact frame index
        text_431.tStart = t  # local t and not account for scr refresh
        text_431.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_431, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_431.started')
        text_431.setAutoDraw(True)
    if text_431.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_431.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_431.tStop = t  # not accounting for scr refresh
            text_431.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_431.stopped')
            text_431.setAutoDraw(False)
    
    # *text_432* updates
    if text_432.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_432.frameNStart = frameN  # exact frame index
        text_432.tStart = t  # local t and not account for scr refresh
        text_432.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_432, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_432.started')
        text_432.setAutoDraw(True)
    if text_432.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_432.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_432.tStop = t  # not accounting for scr refresh
            text_432.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_432.stopped')
            text_432.setAutoDraw(False)
    
    # *text_433* updates
    if text_433.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_433.frameNStart = frameN  # exact frame index
        text_433.tStart = t  # local t and not account for scr refresh
        text_433.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_433, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_433.started')
        text_433.setAutoDraw(True)
    if text_433.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_433.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_433.tStop = t  # not accounting for scr refresh
            text_433.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_433.stopped')
            text_433.setAutoDraw(False)
    
    # *text_434* updates
    if text_434.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_434.frameNStart = frameN  # exact frame index
        text_434.tStart = t  # local t and not account for scr refresh
        text_434.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_434, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_434.started')
        text_434.setAutoDraw(True)
    if text_434.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_434.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_434.tStop = t  # not accounting for scr refresh
            text_434.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_434.stopped')
            text_434.setAutoDraw(False)
    
    # *text_435* updates
    if text_435.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_435.frameNStart = frameN  # exact frame index
        text_435.tStart = t  # local t and not account for scr refresh
        text_435.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_435, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_435.started')
        text_435.setAutoDraw(True)
    if text_435.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_435.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_435.tStop = t  # not accounting for scr refresh
            text_435.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_435.stopped')
            text_435.setAutoDraw(False)
    
    # *key_resp_87* updates
    waitOnFlip = False
    if key_resp_87.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_87.frameNStart = frameN  # exact frame index
        key_resp_87.tStart = t  # local t and not account for scr refresh
        key_resp_87.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_87, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_87.started')
        key_resp_87.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_87.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_87.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_87.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_87.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_87.tStop = t  # not accounting for scr refresh
            key_resp_87.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_87.stopped')
            key_resp_87.status = FINISHED
    if key_resp_87.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_87.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_87_allKeys.extend(theseKeys)
        if len(_key_resp_87_allKeys):
            key_resp_87.keys = _key_resp_87_allKeys[-1].name  # just the last key pressed
            key_resp_87.rt = _key_resp_87_allKeys[-1].rt
            # was this correct?
            if (key_resp_87.keys == str('y')) or (key_resp_87.keys == 'y'):
                key_resp_87.corr = 1
            else:
                key_resp_87.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in u_so_u_soComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "u_so_u_so" ---
for thisComponent in u_so_u_soComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_87.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_87.keys in ['', [], None]:  # No response was made
    key_resp_87.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_87.corr = 1;  # correct non-response
    else:
       key_resp_87.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_87.keys',key_resp_87.keys)
thisExp.addData('key_resp_87.corr', key_resp_87.corr)
if key_resp_87.keys != None:  # we had a response
    thisExp.addData('key_resp_87.rt', key_resp_87.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_sa_ja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_76.setSound('mainpairs/sa.ja+sa.ja.wav', secs=3.5, hamming=True)
sound_vowels_76.setVolume(1.0, log=False)
key_resp_76.keys = []
key_resp_76.rt = []
_key_resp_76_allKeys = []
# keep track of which components have finished
sa_ja_sa_jaComponents = [sound_vowels_76, text_376, text_377, text_378, text_379, text_380, key_resp_76]
for thisComponent in sa_ja_sa_jaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_sa_ja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_76
    if sound_vowels_76.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_76.frameNStart = frameN  # exact frame index
        sound_vowels_76.tStart = t  # local t and not account for scr refresh
        sound_vowels_76.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_76.started', tThisFlipGlobal)
        sound_vowels_76.play(when=win)  # sync with win flip
    if sound_vowels_76.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_76.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_76.tStop = t  # not accounting for scr refresh
            sound_vowels_76.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_76.stopped')
            sound_vowels_76.stop()
    
    # *text_376* updates
    if text_376.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_376.frameNStart = frameN  # exact frame index
        text_376.tStart = t  # local t and not account for scr refresh
        text_376.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_376, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_376.started')
        text_376.setAutoDraw(True)
    if text_376.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_376.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_376.tStop = t  # not accounting for scr refresh
            text_376.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_376.stopped')
            text_376.setAutoDraw(False)
    
    # *text_377* updates
    if text_377.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_377.frameNStart = frameN  # exact frame index
        text_377.tStart = t  # local t and not account for scr refresh
        text_377.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_377, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_377.started')
        text_377.setAutoDraw(True)
    if text_377.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_377.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_377.tStop = t  # not accounting for scr refresh
            text_377.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_377.stopped')
            text_377.setAutoDraw(False)
    
    # *text_378* updates
    if text_378.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_378.frameNStart = frameN  # exact frame index
        text_378.tStart = t  # local t and not account for scr refresh
        text_378.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_378, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_378.started')
        text_378.setAutoDraw(True)
    if text_378.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_378.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_378.tStop = t  # not accounting for scr refresh
            text_378.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_378.stopped')
            text_378.setAutoDraw(False)
    
    # *text_379* updates
    if text_379.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_379.frameNStart = frameN  # exact frame index
        text_379.tStart = t  # local t and not account for scr refresh
        text_379.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_379, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_379.started')
        text_379.setAutoDraw(True)
    if text_379.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_379.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_379.tStop = t  # not accounting for scr refresh
            text_379.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_379.stopped')
            text_379.setAutoDraw(False)
    
    # *text_380* updates
    if text_380.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_380.frameNStart = frameN  # exact frame index
        text_380.tStart = t  # local t and not account for scr refresh
        text_380.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_380, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_380.started')
        text_380.setAutoDraw(True)
    if text_380.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_380.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_380.tStop = t  # not accounting for scr refresh
            text_380.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_380.stopped')
            text_380.setAutoDraw(False)
    
    # *key_resp_76* updates
    waitOnFlip = False
    if key_resp_76.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_76.frameNStart = frameN  # exact frame index
        key_resp_76.tStart = t  # local t and not account for scr refresh
        key_resp_76.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_76, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_76.started')
        key_resp_76.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_76.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_76.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_76.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_76.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_76.tStop = t  # not accounting for scr refresh
            key_resp_76.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_76.stopped')
            key_resp_76.status = FINISHED
    if key_resp_76.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_76.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_76_allKeys.extend(theseKeys)
        if len(_key_resp_76_allKeys):
            key_resp_76.keys = _key_resp_76_allKeys[-1].name  # just the last key pressed
            key_resp_76.rt = _key_resp_76_allKeys[-1].rt
            # was this correct?
            if (key_resp_76.keys == str('y')) or (key_resp_76.keys == 'y'):
                key_resp_76.corr = 1
            else:
                key_resp_76.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_sa_jaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_sa_ja" ---
for thisComponent in sa_ja_sa_jaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_76.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_76.keys in ['', [], None]:  # No response was made
    key_resp_76.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_76.corr = 1;  # correct non-response
    else:
       key_resp_76.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_76.keys',key_resp_76.keys)
thisExp.addData('key_resp_76.corr', key_resp_76.corr)
if key_resp_76.keys != None:  # we had a response
    thisExp.addData('key_resp_76.rt', key_resp_76.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "so_u_so" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_84.setSound('mainpairs/so+u.so.wav', secs=3.5, hamming=True)
sound_vowels_84.setVolume(1.0, log=False)
key_resp_84.keys = []
key_resp_84.rt = []
_key_resp_84_allKeys = []
# keep track of which components have finished
so_u_soComponents = [sound_vowels_84, text_416, text_417, text_418, text_419, text_420, key_resp_84]
for thisComponent in so_u_soComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "so_u_so" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_84
    if sound_vowels_84.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_84.frameNStart = frameN  # exact frame index
        sound_vowels_84.tStart = t  # local t and not account for scr refresh
        sound_vowels_84.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_84.started', tThisFlipGlobal)
        sound_vowels_84.play(when=win)  # sync with win flip
    if sound_vowels_84.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_84.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_84.tStop = t  # not accounting for scr refresh
            sound_vowels_84.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_84.stopped')
            sound_vowels_84.stop()
    
    # *text_416* updates
    if text_416.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_416.frameNStart = frameN  # exact frame index
        text_416.tStart = t  # local t and not account for scr refresh
        text_416.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_416, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_416.started')
        text_416.setAutoDraw(True)
    if text_416.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_416.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_416.tStop = t  # not accounting for scr refresh
            text_416.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_416.stopped')
            text_416.setAutoDraw(False)
    
    # *text_417* updates
    if text_417.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_417.frameNStart = frameN  # exact frame index
        text_417.tStart = t  # local t and not account for scr refresh
        text_417.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_417, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_417.started')
        text_417.setAutoDraw(True)
    if text_417.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_417.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_417.tStop = t  # not accounting for scr refresh
            text_417.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_417.stopped')
            text_417.setAutoDraw(False)
    
    # *text_418* updates
    if text_418.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_418.frameNStart = frameN  # exact frame index
        text_418.tStart = t  # local t and not account for scr refresh
        text_418.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_418, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_418.started')
        text_418.setAutoDraw(True)
    if text_418.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_418.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_418.tStop = t  # not accounting for scr refresh
            text_418.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_418.stopped')
            text_418.setAutoDraw(False)
    
    # *text_419* updates
    if text_419.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_419.frameNStart = frameN  # exact frame index
        text_419.tStart = t  # local t and not account for scr refresh
        text_419.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_419, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_419.started')
        text_419.setAutoDraw(True)
    if text_419.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_419.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_419.tStop = t  # not accounting for scr refresh
            text_419.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_419.stopped')
            text_419.setAutoDraw(False)
    
    # *text_420* updates
    if text_420.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_420.frameNStart = frameN  # exact frame index
        text_420.tStart = t  # local t and not account for scr refresh
        text_420.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_420, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_420.started')
        text_420.setAutoDraw(True)
    if text_420.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_420.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_420.tStop = t  # not accounting for scr refresh
            text_420.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_420.stopped')
            text_420.setAutoDraw(False)
    
    # *key_resp_84* updates
    waitOnFlip = False
    if key_resp_84.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_84.frameNStart = frameN  # exact frame index
        key_resp_84.tStart = t  # local t and not account for scr refresh
        key_resp_84.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_84, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_84.started')
        key_resp_84.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_84.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_84.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_84.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_84.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_84.tStop = t  # not accounting for scr refresh
            key_resp_84.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_84.stopped')
            key_resp_84.status = FINISHED
    if key_resp_84.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_84.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_84_allKeys.extend(theseKeys)
        if len(_key_resp_84_allKeys):
            key_resp_84.keys = _key_resp_84_allKeys[-1].name  # just the last key pressed
            key_resp_84.rt = _key_resp_84_allKeys[-1].rt
            # was this correct?
            if (key_resp_84.keys == str('y')) or (key_resp_84.keys == 'y'):
                key_resp_84.corr = 1
            else:
                key_resp_84.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in so_u_soComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "so_u_so" ---
for thisComponent in so_u_soComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_84.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_84.keys in ['', [], None]:  # No response was made
    key_resp_84.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_84.corr = 1;  # correct non-response
    else:
       key_resp_84.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_84.keys',key_resp_84.keys)
thisExp.addData('key_resp_84.corr', key_resp_84.corr)
if key_resp_84.keys != None:  # we had a response
    thisExp.addData('key_resp_84.rt', key_resp_84.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jo_jo_A" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_73.setSound('mainpairs/jo+jo.A.wav', secs=3.5, hamming=True)
sound_vowels_73.setVolume(1.0, log=False)
key_resp_73.keys = []
key_resp_73.rt = []
_key_resp_73_allKeys = []
# keep track of which components have finished
jo_jo_AComponents = [sound_vowels_73, text_361, text_362, text_363, text_364, text_365, key_resp_73]
for thisComponent in jo_jo_AComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jo_jo_A" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_73
    if sound_vowels_73.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_73.frameNStart = frameN  # exact frame index
        sound_vowels_73.tStart = t  # local t and not account for scr refresh
        sound_vowels_73.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_73.started', tThisFlipGlobal)
        sound_vowels_73.play(when=win)  # sync with win flip
    if sound_vowels_73.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_73.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_73.tStop = t  # not accounting for scr refresh
            sound_vowels_73.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_73.stopped')
            sound_vowels_73.stop()
    
    # *text_361* updates
    if text_361.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_361.frameNStart = frameN  # exact frame index
        text_361.tStart = t  # local t and not account for scr refresh
        text_361.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_361, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_361.started')
        text_361.setAutoDraw(True)
    if text_361.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_361.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_361.tStop = t  # not accounting for scr refresh
            text_361.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_361.stopped')
            text_361.setAutoDraw(False)
    
    # *text_362* updates
    if text_362.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_362.frameNStart = frameN  # exact frame index
        text_362.tStart = t  # local t and not account for scr refresh
        text_362.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_362, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_362.started')
        text_362.setAutoDraw(True)
    if text_362.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_362.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_362.tStop = t  # not accounting for scr refresh
            text_362.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_362.stopped')
            text_362.setAutoDraw(False)
    
    # *text_363* updates
    if text_363.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_363.frameNStart = frameN  # exact frame index
        text_363.tStart = t  # local t and not account for scr refresh
        text_363.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_363, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_363.started')
        text_363.setAutoDraw(True)
    if text_363.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_363.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_363.tStop = t  # not accounting for scr refresh
            text_363.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_363.stopped')
            text_363.setAutoDraw(False)
    
    # *text_364* updates
    if text_364.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_364.frameNStart = frameN  # exact frame index
        text_364.tStart = t  # local t and not account for scr refresh
        text_364.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_364, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_364.started')
        text_364.setAutoDraw(True)
    if text_364.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_364.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_364.tStop = t  # not accounting for scr refresh
            text_364.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_364.stopped')
            text_364.setAutoDraw(False)
    
    # *text_365* updates
    if text_365.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_365.frameNStart = frameN  # exact frame index
        text_365.tStart = t  # local t and not account for scr refresh
        text_365.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_365, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_365.started')
        text_365.setAutoDraw(True)
    if text_365.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_365.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_365.tStop = t  # not accounting for scr refresh
            text_365.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_365.stopped')
            text_365.setAutoDraw(False)
    
    # *key_resp_73* updates
    waitOnFlip = False
    if key_resp_73.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_73.frameNStart = frameN  # exact frame index
        key_resp_73.tStart = t  # local t and not account for scr refresh
        key_resp_73.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_73, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_73.started')
        key_resp_73.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_73.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_73.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_73.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_73.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_73.tStop = t  # not accounting for scr refresh
            key_resp_73.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_73.stopped')
            key_resp_73.status = FINISHED
    if key_resp_73.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_73.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_73_allKeys.extend(theseKeys)
        if len(_key_resp_73_allKeys):
            key_resp_73.keys = _key_resp_73_allKeys[-1].name  # just the last key pressed
            key_resp_73.rt = _key_resp_73_allKeys[-1].rt
            # was this correct?
            if (key_resp_73.keys == str('y')) or (key_resp_73.keys == 'y'):
                key_resp_73.corr = 1
            else:
                key_resp_73.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jo_jo_AComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jo_jo_A" ---
for thisComponent in jo_jo_AComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_73.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_73.keys in ['', [], None]:  # No response was made
    key_resp_73.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_73.corr = 1;  # correct non-response
    else:
       key_resp_73.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_73.keys',key_resp_73.keys)
thisExp.addData('key_resp_73.corr', key_resp_73.corr)
if key_resp_73.keys != None:  # we had a response
    thisExp.addData('key_resp_73.rt', key_resp_73.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "u_so_u" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_88.setSound('mainpairs/u.so+u.wav', secs=3.5, hamming=True)
sound_vowels_88.setVolume(1.0, log=False)
key_resp_88.keys = []
key_resp_88.rt = []
_key_resp_88_allKeys = []
# keep track of which components have finished
u_so_uComponents = [sound_vowels_88, text_436, text_437, text_438, text_439, text_440, key_resp_88]
for thisComponent in u_so_uComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "u_so_u" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_88
    if sound_vowels_88.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_88.frameNStart = frameN  # exact frame index
        sound_vowels_88.tStart = t  # local t and not account for scr refresh
        sound_vowels_88.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_88.started', tThisFlipGlobal)
        sound_vowels_88.play(when=win)  # sync with win flip
    if sound_vowels_88.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_88.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_88.tStop = t  # not accounting for scr refresh
            sound_vowels_88.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_88.stopped')
            sound_vowels_88.stop()
    
    # *text_436* updates
    if text_436.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_436.frameNStart = frameN  # exact frame index
        text_436.tStart = t  # local t and not account for scr refresh
        text_436.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_436, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_436.started')
        text_436.setAutoDraw(True)
    if text_436.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_436.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_436.tStop = t  # not accounting for scr refresh
            text_436.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_436.stopped')
            text_436.setAutoDraw(False)
    
    # *text_437* updates
    if text_437.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_437.frameNStart = frameN  # exact frame index
        text_437.tStart = t  # local t and not account for scr refresh
        text_437.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_437, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_437.started')
        text_437.setAutoDraw(True)
    if text_437.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_437.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_437.tStop = t  # not accounting for scr refresh
            text_437.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_437.stopped')
            text_437.setAutoDraw(False)
    
    # *text_438* updates
    if text_438.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_438.frameNStart = frameN  # exact frame index
        text_438.tStart = t  # local t and not account for scr refresh
        text_438.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_438, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_438.started')
        text_438.setAutoDraw(True)
    if text_438.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_438.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_438.tStop = t  # not accounting for scr refresh
            text_438.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_438.stopped')
            text_438.setAutoDraw(False)
    
    # *text_439* updates
    if text_439.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_439.frameNStart = frameN  # exact frame index
        text_439.tStart = t  # local t and not account for scr refresh
        text_439.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_439, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_439.started')
        text_439.setAutoDraw(True)
    if text_439.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_439.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_439.tStop = t  # not accounting for scr refresh
            text_439.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_439.stopped')
            text_439.setAutoDraw(False)
    
    # *text_440* updates
    if text_440.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_440.frameNStart = frameN  # exact frame index
        text_440.tStart = t  # local t and not account for scr refresh
        text_440.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_440, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_440.started')
        text_440.setAutoDraw(True)
    if text_440.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_440.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_440.tStop = t  # not accounting for scr refresh
            text_440.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_440.stopped')
            text_440.setAutoDraw(False)
    
    # *key_resp_88* updates
    waitOnFlip = False
    if key_resp_88.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_88.frameNStart = frameN  # exact frame index
        key_resp_88.tStart = t  # local t and not account for scr refresh
        key_resp_88.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_88, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_88.started')
        key_resp_88.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_88.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_88.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_88.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_88.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_88.tStop = t  # not accounting for scr refresh
            key_resp_88.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_88.stopped')
            key_resp_88.status = FINISHED
    if key_resp_88.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_88.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_88_allKeys.extend(theseKeys)
        if len(_key_resp_88_allKeys):
            key_resp_88.keys = _key_resp_88_allKeys[-1].name  # just the last key pressed
            key_resp_88.rt = _key_resp_88_allKeys[-1].rt
            # was this correct?
            if (key_resp_88.keys == str('y')) or (key_resp_88.keys == 'y'):
                key_resp_88.corr = 1
            else:
                key_resp_88.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in u_so_uComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "u_so_u" ---
for thisComponent in u_so_uComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_88.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_88.keys in ['', [], None]:  # No response was made
    key_resp_88.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_88.corr = 1;  # correct non-response
    else:
       key_resp_88.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_88.keys',key_resp_88.keys)
thisExp.addData('key_resp_88.corr', key_resp_88.corr)
if key_resp_88.keys != None:  # we had a response
    thisExp.addData('key_resp_88.rt', key_resp_88.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_ja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_75.setSound('mainpairs/sa.ja+ja.wav', secs=3.5, hamming=True)
sound_vowels_75.setVolume(1.0, log=False)
key_resp_75.keys = []
key_resp_75.rt = []
_key_resp_75_allKeys = []
# keep track of which components have finished
sa_ja_jaComponents = [sound_vowels_75, text_371, text_372, text_373, text_374, text_375, key_resp_75]
for thisComponent in sa_ja_jaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_ja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_75
    if sound_vowels_75.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_75.frameNStart = frameN  # exact frame index
        sound_vowels_75.tStart = t  # local t and not account for scr refresh
        sound_vowels_75.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_75.started', tThisFlipGlobal)
        sound_vowels_75.play(when=win)  # sync with win flip
    if sound_vowels_75.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_75.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_75.tStop = t  # not accounting for scr refresh
            sound_vowels_75.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_75.stopped')
            sound_vowels_75.stop()
    
    # *text_371* updates
    if text_371.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_371.frameNStart = frameN  # exact frame index
        text_371.tStart = t  # local t and not account for scr refresh
        text_371.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_371, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_371.started')
        text_371.setAutoDraw(True)
    if text_371.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_371.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_371.tStop = t  # not accounting for scr refresh
            text_371.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_371.stopped')
            text_371.setAutoDraw(False)
    
    # *text_372* updates
    if text_372.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_372.frameNStart = frameN  # exact frame index
        text_372.tStart = t  # local t and not account for scr refresh
        text_372.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_372, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_372.started')
        text_372.setAutoDraw(True)
    if text_372.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_372.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_372.tStop = t  # not accounting for scr refresh
            text_372.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_372.stopped')
            text_372.setAutoDraw(False)
    
    # *text_373* updates
    if text_373.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_373.frameNStart = frameN  # exact frame index
        text_373.tStart = t  # local t and not account for scr refresh
        text_373.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_373, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_373.started')
        text_373.setAutoDraw(True)
    if text_373.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_373.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_373.tStop = t  # not accounting for scr refresh
            text_373.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_373.stopped')
            text_373.setAutoDraw(False)
    
    # *text_374* updates
    if text_374.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_374.frameNStart = frameN  # exact frame index
        text_374.tStart = t  # local t and not account for scr refresh
        text_374.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_374, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_374.started')
        text_374.setAutoDraw(True)
    if text_374.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_374.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_374.tStop = t  # not accounting for scr refresh
            text_374.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_374.stopped')
            text_374.setAutoDraw(False)
    
    # *text_375* updates
    if text_375.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_375.frameNStart = frameN  # exact frame index
        text_375.tStart = t  # local t and not account for scr refresh
        text_375.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_375, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_375.started')
        text_375.setAutoDraw(True)
    if text_375.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_375.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_375.tStop = t  # not accounting for scr refresh
            text_375.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_375.stopped')
            text_375.setAutoDraw(False)
    
    # *key_resp_75* updates
    waitOnFlip = False
    if key_resp_75.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_75.frameNStart = frameN  # exact frame index
        key_resp_75.tStart = t  # local t and not account for scr refresh
        key_resp_75.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_75, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_75.started')
        key_resp_75.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_75.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_75.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_75.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_75.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_75.tStop = t  # not accounting for scr refresh
            key_resp_75.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_75.stopped')
            key_resp_75.status = FINISHED
    if key_resp_75.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_75.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_75_allKeys.extend(theseKeys)
        if len(_key_resp_75_allKeys):
            key_resp_75.keys = _key_resp_75_allKeys[-1].name  # just the last key pressed
            key_resp_75.rt = _key_resp_75_allKeys[-1].rt
            # was this correct?
            if (key_resp_75.keys == str('y')) or (key_resp_75.keys == 'y'):
                key_resp_75.corr = 1
            else:
                key_resp_75.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_jaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_ja" ---
for thisComponent in sa_ja_jaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_75.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_75.keys in ['', [], None]:  # No response was made
    key_resp_75.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_75.corr = 1;  # correct non-response
    else:
       key_resp_75.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_75.keys',key_resp_75.keys)
thisExp.addData('key_resp_75.corr', key_resp_75.corr)
if key_resp_75.keys != None:  # we had a response
    thisExp.addData('key_resp_75.rt', key_resp_75.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "usosopu" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_89.setSound('mainpairs/usosopu.wav', secs=3.5, hamming=True)
sound_vowels_89.setVolume(1.0, log=False)
key_resp_89.keys = []
key_resp_89.rt = []
_key_resp_89_allKeys = []
# keep track of which components have finished
usosopuComponents = [sound_vowels_89, text_441, text_442, text_443, text_444, text_445, key_resp_89]
for thisComponent in usosopuComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "usosopu" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_89
    if sound_vowels_89.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_89.frameNStart = frameN  # exact frame index
        sound_vowels_89.tStart = t  # local t and not account for scr refresh
        sound_vowels_89.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_89.started', tThisFlipGlobal)
        sound_vowels_89.play(when=win)  # sync with win flip
    if sound_vowels_89.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_89.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_89.tStop = t  # not accounting for scr refresh
            sound_vowels_89.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_89.stopped')
            sound_vowels_89.stop()
    
    # *text_441* updates
    if text_441.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_441.frameNStart = frameN  # exact frame index
        text_441.tStart = t  # local t and not account for scr refresh
        text_441.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_441, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_441.started')
        text_441.setAutoDraw(True)
    if text_441.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_441.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_441.tStop = t  # not accounting for scr refresh
            text_441.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_441.stopped')
            text_441.setAutoDraw(False)
    
    # *text_442* updates
    if text_442.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_442.frameNStart = frameN  # exact frame index
        text_442.tStart = t  # local t and not account for scr refresh
        text_442.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_442, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_442.started')
        text_442.setAutoDraw(True)
    if text_442.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_442.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_442.tStop = t  # not accounting for scr refresh
            text_442.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_442.stopped')
            text_442.setAutoDraw(False)
    
    # *text_443* updates
    if text_443.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_443.frameNStart = frameN  # exact frame index
        text_443.tStart = t  # local t and not account for scr refresh
        text_443.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_443, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_443.started')
        text_443.setAutoDraw(True)
    if text_443.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_443.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_443.tStop = t  # not accounting for scr refresh
            text_443.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_443.stopped')
            text_443.setAutoDraw(False)
    
    # *text_444* updates
    if text_444.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_444.frameNStart = frameN  # exact frame index
        text_444.tStart = t  # local t and not account for scr refresh
        text_444.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_444, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_444.started')
        text_444.setAutoDraw(True)
    if text_444.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_444.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_444.tStop = t  # not accounting for scr refresh
            text_444.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_444.stopped')
            text_444.setAutoDraw(False)
    
    # *text_445* updates
    if text_445.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_445.frameNStart = frameN  # exact frame index
        text_445.tStart = t  # local t and not account for scr refresh
        text_445.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_445, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_445.started')
        text_445.setAutoDraw(True)
    if text_445.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_445.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_445.tStop = t  # not accounting for scr refresh
            text_445.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_445.stopped')
            text_445.setAutoDraw(False)
    
    # *key_resp_89* updates
    waitOnFlip = False
    if key_resp_89.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_89.frameNStart = frameN  # exact frame index
        key_resp_89.tStart = t  # local t and not account for scr refresh
        key_resp_89.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_89, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_89.started')
        key_resp_89.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_89.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_89.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_89.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_89.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_89.tStop = t  # not accounting for scr refresh
            key_resp_89.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_89.stopped')
            key_resp_89.status = FINISHED
    if key_resp_89.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_89.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_89_allKeys.extend(theseKeys)
        if len(_key_resp_89_allKeys):
            key_resp_89.keys = _key_resp_89_allKeys[-1].name  # just the last key pressed
            key_resp_89.rt = _key_resp_89_allKeys[-1].rt
            # was this correct?
            if (key_resp_89.keys == str('n')) or (key_resp_89.keys == 'n'):
                key_resp_89.corr = 1
            else:
                key_resp_89.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in usosopuComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "usosopu" ---
for thisComponent in usosopuComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_89.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_89.keys in ['', [], None]:  # No response was made
    key_resp_89.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_89.corr = 1;  # correct non-response
    else:
       key_resp_89.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_89.keys',key_resp_89.keys)
thisExp.addData('key_resp_89.corr', key_resp_89.corr)
if key_resp_89.keys != None:  # we had a response
    thisExp.addData('key_resp_89.rt', key_resp_89.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "so_so_jo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_83.setSound('mainpairs/so+so.jo.wav', secs=3.5, hamming=True)
sound_vowels_83.setVolume(1.0, log=False)
key_resp_83.keys = []
key_resp_83.rt = []
_key_resp_83_allKeys = []
# keep track of which components have finished
so_so_joComponents = [sound_vowels_83, text_411, text_412, text_413, text_414, text_415, key_resp_83]
for thisComponent in so_so_joComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "so_so_jo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_83
    if sound_vowels_83.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_83.frameNStart = frameN  # exact frame index
        sound_vowels_83.tStart = t  # local t and not account for scr refresh
        sound_vowels_83.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_83.started', tThisFlipGlobal)
        sound_vowels_83.play(when=win)  # sync with win flip
    if sound_vowels_83.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_83.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_83.tStop = t  # not accounting for scr refresh
            sound_vowels_83.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_83.stopped')
            sound_vowels_83.stop()
    
    # *text_411* updates
    if text_411.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_411.frameNStart = frameN  # exact frame index
        text_411.tStart = t  # local t and not account for scr refresh
        text_411.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_411, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_411.started')
        text_411.setAutoDraw(True)
    if text_411.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_411.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_411.tStop = t  # not accounting for scr refresh
            text_411.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_411.stopped')
            text_411.setAutoDraw(False)
    
    # *text_412* updates
    if text_412.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_412.frameNStart = frameN  # exact frame index
        text_412.tStart = t  # local t and not account for scr refresh
        text_412.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_412, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_412.started')
        text_412.setAutoDraw(True)
    if text_412.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_412.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_412.tStop = t  # not accounting for scr refresh
            text_412.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_412.stopped')
            text_412.setAutoDraw(False)
    
    # *text_413* updates
    if text_413.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_413.frameNStart = frameN  # exact frame index
        text_413.tStart = t  # local t and not account for scr refresh
        text_413.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_413, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_413.started')
        text_413.setAutoDraw(True)
    if text_413.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_413.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_413.tStop = t  # not accounting for scr refresh
            text_413.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_413.stopped')
            text_413.setAutoDraw(False)
    
    # *text_414* updates
    if text_414.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_414.frameNStart = frameN  # exact frame index
        text_414.tStart = t  # local t and not account for scr refresh
        text_414.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_414, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_414.started')
        text_414.setAutoDraw(True)
    if text_414.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_414.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_414.tStop = t  # not accounting for scr refresh
            text_414.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_414.stopped')
            text_414.setAutoDraw(False)
    
    # *text_415* updates
    if text_415.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_415.frameNStart = frameN  # exact frame index
        text_415.tStart = t  # local t and not account for scr refresh
        text_415.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_415, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_415.started')
        text_415.setAutoDraw(True)
    if text_415.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_415.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_415.tStop = t  # not accounting for scr refresh
            text_415.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_415.stopped')
            text_415.setAutoDraw(False)
    
    # *key_resp_83* updates
    waitOnFlip = False
    if key_resp_83.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_83.frameNStart = frameN  # exact frame index
        key_resp_83.tStart = t  # local t and not account for scr refresh
        key_resp_83.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_83, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_83.started')
        key_resp_83.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_83.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_83.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_83.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_83.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_83.tStop = t  # not accounting for scr refresh
            key_resp_83.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_83.stopped')
            key_resp_83.status = FINISHED
    if key_resp_83.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_83.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_83_allKeys.extend(theseKeys)
        if len(_key_resp_83_allKeys):
            key_resp_83.keys = _key_resp_83_allKeys[-1].name  # just the last key pressed
            key_resp_83.rt = _key_resp_83_allKeys[-1].rt
            # was this correct?
            if (key_resp_83.keys == str('y')) or (key_resp_83.keys == 'y'):
                key_resp_83.corr = 1
            else:
                key_resp_83.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in so_so_joComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "so_so_jo" ---
for thisComponent in so_so_joComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_83.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_83.keys in ['', [], None]:  # No response was made
    key_resp_83.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_83.corr = 1;  # correct non-response
    else:
       key_resp_83.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_83.keys',key_resp_83.keys)
thisExp.addData('key_resp_83.corr', key_resp_83.corr)
if key_resp_83.keys != None:  # we had a response
    thisExp.addData('key_resp_83.rt', key_resp_83.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "ja_sa_ja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_69.setSound('mainpairs/ja+sa.ja.wav', secs=3.5, hamming=True)
sound_vowels_69.setVolume(1.0, log=False)
key_resp_69.keys = []
key_resp_69.rt = []
_key_resp_69_allKeys = []
# keep track of which components have finished
ja_sa_jaComponents = [sound_vowels_69, text_341, text_342, text_343, text_344, text_345, key_resp_69]
for thisComponent in ja_sa_jaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "ja_sa_ja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_69
    if sound_vowels_69.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_69.frameNStart = frameN  # exact frame index
        sound_vowels_69.tStart = t  # local t and not account for scr refresh
        sound_vowels_69.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_69.started', tThisFlipGlobal)
        sound_vowels_69.play(when=win)  # sync with win flip
    if sound_vowels_69.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_69.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_69.tStop = t  # not accounting for scr refresh
            sound_vowels_69.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_69.stopped')
            sound_vowels_69.stop()
    
    # *text_341* updates
    if text_341.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_341.frameNStart = frameN  # exact frame index
        text_341.tStart = t  # local t and not account for scr refresh
        text_341.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_341, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_341.started')
        text_341.setAutoDraw(True)
    if text_341.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_341.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_341.tStop = t  # not accounting for scr refresh
            text_341.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_341.stopped')
            text_341.setAutoDraw(False)
    
    # *text_342* updates
    if text_342.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_342.frameNStart = frameN  # exact frame index
        text_342.tStart = t  # local t and not account for scr refresh
        text_342.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_342, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_342.started')
        text_342.setAutoDraw(True)
    if text_342.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_342.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_342.tStop = t  # not accounting for scr refresh
            text_342.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_342.stopped')
            text_342.setAutoDraw(False)
    
    # *text_343* updates
    if text_343.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_343.frameNStart = frameN  # exact frame index
        text_343.tStart = t  # local t and not account for scr refresh
        text_343.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_343, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_343.started')
        text_343.setAutoDraw(True)
    if text_343.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_343.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_343.tStop = t  # not accounting for scr refresh
            text_343.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_343.stopped')
            text_343.setAutoDraw(False)
    
    # *text_344* updates
    if text_344.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_344.frameNStart = frameN  # exact frame index
        text_344.tStart = t  # local t and not account for scr refresh
        text_344.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_344, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_344.started')
        text_344.setAutoDraw(True)
    if text_344.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_344.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_344.tStop = t  # not accounting for scr refresh
            text_344.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_344.stopped')
            text_344.setAutoDraw(False)
    
    # *text_345* updates
    if text_345.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_345.frameNStart = frameN  # exact frame index
        text_345.tStart = t  # local t and not account for scr refresh
        text_345.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_345, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_345.started')
        text_345.setAutoDraw(True)
    if text_345.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_345.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_345.tStop = t  # not accounting for scr refresh
            text_345.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_345.stopped')
            text_345.setAutoDraw(False)
    
    # *key_resp_69* updates
    waitOnFlip = False
    if key_resp_69.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_69.frameNStart = frameN  # exact frame index
        key_resp_69.tStart = t  # local t and not account for scr refresh
        key_resp_69.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_69, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_69.started')
        key_resp_69.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_69.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_69.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_69.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_69.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_69.tStop = t  # not accounting for scr refresh
            key_resp_69.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_69.stopped')
            key_resp_69.status = FINISHED
    if key_resp_69.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_69.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_69_allKeys.extend(theseKeys)
        if len(_key_resp_69_allKeys):
            key_resp_69.keys = _key_resp_69_allKeys[-1].name  # just the last key pressed
            key_resp_69.rt = _key_resp_69_allKeys[-1].rt
            # was this correct?
            if (key_resp_69.keys == str('y')) or (key_resp_69.keys == 'y'):
                key_resp_69.corr = 1
            else:
                key_resp_69.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in ja_sa_jaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "ja_sa_ja" ---
for thisComponent in ja_sa_jaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_69.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_69.keys in ['', [], None]:  # No response was made
    key_resp_69.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_69.corr = 1;  # correct non-response
    else:
       key_resp_69.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_69.keys',key_resp_69.keys)
thisExp.addData('key_resp_69.corr', key_resp_69.corr)
if key_resp_69.keys != None:  # we had a response
    thisExp.addData('key_resp_69.rt', key_resp_69.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_A_sapsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_68.setSound('mainpairs/sa+A.sapsa.wav', secs=3.5, hamming=True)
sound_vowels_68.setVolume(1.0, log=False)
key_resp_68.keys = []
key_resp_68.rt = []
_key_resp_68_allKeys = []
# keep track of which components have finished
sa_A_sapsaComponents = [sound_vowels_68, text_336, text_337, text_338, text_339, text_340, key_resp_68]
for thisComponent in sa_A_sapsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_A_sapsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_68
    if sound_vowels_68.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_68.frameNStart = frameN  # exact frame index
        sound_vowels_68.tStart = t  # local t and not account for scr refresh
        sound_vowels_68.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_68.started', tThisFlipGlobal)
        sound_vowels_68.play(when=win)  # sync with win flip
    if sound_vowels_68.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_68.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_68.tStop = t  # not accounting for scr refresh
            sound_vowels_68.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_68.stopped')
            sound_vowels_68.stop()
    
    # *text_336* updates
    if text_336.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_336.frameNStart = frameN  # exact frame index
        text_336.tStart = t  # local t and not account for scr refresh
        text_336.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_336, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_336.started')
        text_336.setAutoDraw(True)
    if text_336.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_336.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_336.tStop = t  # not accounting for scr refresh
            text_336.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_336.stopped')
            text_336.setAutoDraw(False)
    
    # *text_337* updates
    if text_337.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_337.frameNStart = frameN  # exact frame index
        text_337.tStart = t  # local t and not account for scr refresh
        text_337.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_337, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_337.started')
        text_337.setAutoDraw(True)
    if text_337.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_337.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_337.tStop = t  # not accounting for scr refresh
            text_337.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_337.stopped')
            text_337.setAutoDraw(False)
    
    # *text_338* updates
    if text_338.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_338.frameNStart = frameN  # exact frame index
        text_338.tStart = t  # local t and not account for scr refresh
        text_338.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_338, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_338.started')
        text_338.setAutoDraw(True)
    if text_338.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_338.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_338.tStop = t  # not accounting for scr refresh
            text_338.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_338.stopped')
            text_338.setAutoDraw(False)
    
    # *text_339* updates
    if text_339.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_339.frameNStart = frameN  # exact frame index
        text_339.tStart = t  # local t and not account for scr refresh
        text_339.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_339, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_339.started')
        text_339.setAutoDraw(True)
    if text_339.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_339.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_339.tStop = t  # not accounting for scr refresh
            text_339.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_339.stopped')
            text_339.setAutoDraw(False)
    
    # *text_340* updates
    if text_340.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_340.frameNStart = frameN  # exact frame index
        text_340.tStart = t  # local t and not account for scr refresh
        text_340.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_340, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_340.started')
        text_340.setAutoDraw(True)
    if text_340.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_340.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_340.tStop = t  # not accounting for scr refresh
            text_340.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_340.stopped')
            text_340.setAutoDraw(False)
    
    # *key_resp_68* updates
    waitOnFlip = False
    if key_resp_68.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_68.frameNStart = frameN  # exact frame index
        key_resp_68.tStart = t  # local t and not account for scr refresh
        key_resp_68.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_68, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_68.started')
        key_resp_68.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_68.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_68.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_68.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_68.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_68.tStop = t  # not accounting for scr refresh
            key_resp_68.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_68.stopped')
            key_resp_68.status = FINISHED
    if key_resp_68.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_68.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_68_allKeys.extend(theseKeys)
        if len(_key_resp_68_allKeys):
            key_resp_68.keys = _key_resp_68_allKeys[-1].name  # just the last key pressed
            key_resp_68.rt = _key_resp_68_allKeys[-1].rt
            # was this correct?
            if (key_resp_68.keys == str('n')) or (key_resp_68.keys == 'n'):
                key_resp_68.corr = 1
            else:
                key_resp_68.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_A_sapsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_A_sapsa" ---
for thisComponent in sa_A_sapsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_68.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_68.keys in ['', [], None]:  # No response was made
    key_resp_68.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_68.corr = 1;  # correct non-response
    else:
       key_resp_68.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_68.keys',key_resp_68.keys)
thisExp.addData('key_resp_68.corr', key_resp_68.corr)
if key_resp_68.keys != None:  # we had a response
    thisExp.addData('key_resp_68.rt', key_resp_68.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jo_A_A" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_70.setSound('mainpairs/jo.A+A.wav', secs=3.5, hamming=True)
sound_vowels_70.setVolume(1.0, log=False)
key_resp_70.keys = []
key_resp_70.rt = []
_key_resp_70_allKeys = []
# keep track of which components have finished
jo_A_AComponents = [sound_vowels_70, text_346, text_347, text_348, text_349, text_350, key_resp_70]
for thisComponent in jo_A_AComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jo_A_A" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_70
    if sound_vowels_70.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_70.frameNStart = frameN  # exact frame index
        sound_vowels_70.tStart = t  # local t and not account for scr refresh
        sound_vowels_70.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_70.started', tThisFlipGlobal)
        sound_vowels_70.play(when=win)  # sync with win flip
    if sound_vowels_70.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_70.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_70.tStop = t  # not accounting for scr refresh
            sound_vowels_70.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_70.stopped')
            sound_vowels_70.stop()
    
    # *text_346* updates
    if text_346.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_346.frameNStart = frameN  # exact frame index
        text_346.tStart = t  # local t and not account for scr refresh
        text_346.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_346, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_346.started')
        text_346.setAutoDraw(True)
    if text_346.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_346.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_346.tStop = t  # not accounting for scr refresh
            text_346.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_346.stopped')
            text_346.setAutoDraw(False)
    
    # *text_347* updates
    if text_347.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_347.frameNStart = frameN  # exact frame index
        text_347.tStart = t  # local t and not account for scr refresh
        text_347.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_347, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_347.started')
        text_347.setAutoDraw(True)
    if text_347.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_347.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_347.tStop = t  # not accounting for scr refresh
            text_347.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_347.stopped')
            text_347.setAutoDraw(False)
    
    # *text_348* updates
    if text_348.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_348.frameNStart = frameN  # exact frame index
        text_348.tStart = t  # local t and not account for scr refresh
        text_348.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_348, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_348.started')
        text_348.setAutoDraw(True)
    if text_348.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_348.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_348.tStop = t  # not accounting for scr refresh
            text_348.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_348.stopped')
            text_348.setAutoDraw(False)
    
    # *text_349* updates
    if text_349.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_349.frameNStart = frameN  # exact frame index
        text_349.tStart = t  # local t and not account for scr refresh
        text_349.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_349, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_349.started')
        text_349.setAutoDraw(True)
    if text_349.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_349.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_349.tStop = t  # not accounting for scr refresh
            text_349.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_349.stopped')
            text_349.setAutoDraw(False)
    
    # *text_350* updates
    if text_350.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_350.frameNStart = frameN  # exact frame index
        text_350.tStart = t  # local t and not account for scr refresh
        text_350.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_350, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_350.started')
        text_350.setAutoDraw(True)
    if text_350.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_350.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_350.tStop = t  # not accounting for scr refresh
            text_350.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_350.stopped')
            text_350.setAutoDraw(False)
    
    # *key_resp_70* updates
    waitOnFlip = False
    if key_resp_70.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_70.frameNStart = frameN  # exact frame index
        key_resp_70.tStart = t  # local t and not account for scr refresh
        key_resp_70.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_70, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_70.started')
        key_resp_70.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_70.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_70.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_70.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_70.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_70.tStop = t  # not accounting for scr refresh
            key_resp_70.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_70.stopped')
            key_resp_70.status = FINISHED
    if key_resp_70.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_70.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_70_allKeys.extend(theseKeys)
        if len(_key_resp_70_allKeys):
            key_resp_70.keys = _key_resp_70_allKeys[-1].name  # just the last key pressed
            key_resp_70.rt = _key_resp_70_allKeys[-1].rt
            # was this correct?
            if (key_resp_70.keys == str('y')) or (key_resp_70.keys == 'y'):
                key_resp_70.corr = 1
            else:
                key_resp_70.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jo_A_AComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jo_A_A" ---
for thisComponent in jo_A_AComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_70.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_70.keys in ['', [], None]:  # No response was made
    key_resp_70.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_70.corr = 1;  # correct non-response
    else:
       key_resp_70.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_70.keys',key_resp_70.keys)
thisExp.addData('key_resp_70.corr', key_resp_70.corr)
if key_resp_70.keys != None:  # we had a response
    thisExp.addData('key_resp_70.rt', key_resp_70.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "usoupu" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_90.setSound('mainpairs/usoupu.wav', secs=3.5, hamming=True)
sound_vowels_90.setVolume(1.0, log=False)
key_resp_90.keys = []
key_resp_90.rt = []
_key_resp_90_allKeys = []
# keep track of which components have finished
usoupuComponents = [sound_vowels_90, text_446, text_447, text_448, text_449, text_450, key_resp_90]
for thisComponent in usoupuComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "usoupu" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_90
    if sound_vowels_90.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_90.frameNStart = frameN  # exact frame index
        sound_vowels_90.tStart = t  # local t and not account for scr refresh
        sound_vowels_90.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_90.started', tThisFlipGlobal)
        sound_vowels_90.play(when=win)  # sync with win flip
    if sound_vowels_90.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_90.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_90.tStop = t  # not accounting for scr refresh
            sound_vowels_90.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_90.stopped')
            sound_vowels_90.stop()
    
    # *text_446* updates
    if text_446.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_446.frameNStart = frameN  # exact frame index
        text_446.tStart = t  # local t and not account for scr refresh
        text_446.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_446, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_446.started')
        text_446.setAutoDraw(True)
    if text_446.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_446.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_446.tStop = t  # not accounting for scr refresh
            text_446.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_446.stopped')
            text_446.setAutoDraw(False)
    
    # *text_447* updates
    if text_447.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_447.frameNStart = frameN  # exact frame index
        text_447.tStart = t  # local t and not account for scr refresh
        text_447.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_447, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_447.started')
        text_447.setAutoDraw(True)
    if text_447.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_447.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_447.tStop = t  # not accounting for scr refresh
            text_447.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_447.stopped')
            text_447.setAutoDraw(False)
    
    # *text_448* updates
    if text_448.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_448.frameNStart = frameN  # exact frame index
        text_448.tStart = t  # local t and not account for scr refresh
        text_448.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_448, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_448.started')
        text_448.setAutoDraw(True)
    if text_448.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_448.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_448.tStop = t  # not accounting for scr refresh
            text_448.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_448.stopped')
            text_448.setAutoDraw(False)
    
    # *text_449* updates
    if text_449.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_449.frameNStart = frameN  # exact frame index
        text_449.tStart = t  # local t and not account for scr refresh
        text_449.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_449, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_449.started')
        text_449.setAutoDraw(True)
    if text_449.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_449.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_449.tStop = t  # not accounting for scr refresh
            text_449.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_449.stopped')
            text_449.setAutoDraw(False)
    
    # *text_450* updates
    if text_450.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_450.frameNStart = frameN  # exact frame index
        text_450.tStart = t  # local t and not account for scr refresh
        text_450.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_450, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_450.started')
        text_450.setAutoDraw(True)
    if text_450.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_450.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_450.tStop = t  # not accounting for scr refresh
            text_450.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_450.stopped')
            text_450.setAutoDraw(False)
    
    # *key_resp_90* updates
    waitOnFlip = False
    if key_resp_90.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_90.frameNStart = frameN  # exact frame index
        key_resp_90.tStart = t  # local t and not account for scr refresh
        key_resp_90.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_90, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_90.started')
        key_resp_90.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_90.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_90.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_90.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_90.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_90.tStop = t  # not accounting for scr refresh
            key_resp_90.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_90.stopped')
            key_resp_90.status = FINISHED
    if key_resp_90.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_90.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_90_allKeys.extend(theseKeys)
        if len(_key_resp_90_allKeys):
            key_resp_90.keys = _key_resp_90_allKeys[-1].name  # just the last key pressed
            key_resp_90.rt = _key_resp_90_allKeys[-1].rt
            # was this correct?
            if (key_resp_90.keys == str('n')) or (key_resp_90.keys == 'n'):
                key_resp_90.corr = 1
            else:
                key_resp_90.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in usoupuComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "usoupu" ---
for thisComponent in usoupuComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_90.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_90.keys in ['', [], None]:  # No response was made
    key_resp_90.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_90.corr = 1;  # correct non-response
    else:
       key_resp_90.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_90.keys',key_resp_90.keys)
thisExp.addData('key_resp_90.corr', key_resp_90.corr)
if key_resp_90.keys != None:  # we had a response
    thisExp.addData('key_resp_90.rt', key_resp_90.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "ja_sa_japja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_58.setSound('mainpairs/ja+sa.japja.wav', secs=3.5, hamming=True)
sound_vowels_58.setVolume(1.0, log=False)
key_resp_58.keys = []
key_resp_58.rt = []
_key_resp_58_allKeys = []
# keep track of which components have finished
ja_sa_japjaComponents = [sound_vowels_58, text_286, text_287, text_288, text_289, text_290, key_resp_58]
for thisComponent in ja_sa_japjaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "ja_sa_japja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_58
    if sound_vowels_58.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_58.frameNStart = frameN  # exact frame index
        sound_vowels_58.tStart = t  # local t and not account for scr refresh
        sound_vowels_58.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_58.started', tThisFlipGlobal)
        sound_vowels_58.play(when=win)  # sync with win flip
    if sound_vowels_58.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_58.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_58.tStop = t  # not accounting for scr refresh
            sound_vowels_58.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_58.stopped')
            sound_vowels_58.stop()
    
    # *text_286* updates
    if text_286.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_286.frameNStart = frameN  # exact frame index
        text_286.tStart = t  # local t and not account for scr refresh
        text_286.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_286, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_286.started')
        text_286.setAutoDraw(True)
    if text_286.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_286.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_286.tStop = t  # not accounting for scr refresh
            text_286.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_286.stopped')
            text_286.setAutoDraw(False)
    
    # *text_287* updates
    if text_287.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_287.frameNStart = frameN  # exact frame index
        text_287.tStart = t  # local t and not account for scr refresh
        text_287.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_287, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_287.started')
        text_287.setAutoDraw(True)
    if text_287.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_287.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_287.tStop = t  # not accounting for scr refresh
            text_287.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_287.stopped')
            text_287.setAutoDraw(False)
    
    # *text_288* updates
    if text_288.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_288.frameNStart = frameN  # exact frame index
        text_288.tStart = t  # local t and not account for scr refresh
        text_288.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_288, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_288.started')
        text_288.setAutoDraw(True)
    if text_288.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_288.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_288.tStop = t  # not accounting for scr refresh
            text_288.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_288.stopped')
            text_288.setAutoDraw(False)
    
    # *text_289* updates
    if text_289.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_289.frameNStart = frameN  # exact frame index
        text_289.tStart = t  # local t and not account for scr refresh
        text_289.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_289, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_289.started')
        text_289.setAutoDraw(True)
    if text_289.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_289.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_289.tStop = t  # not accounting for scr refresh
            text_289.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_289.stopped')
            text_289.setAutoDraw(False)
    
    # *text_290* updates
    if text_290.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_290.frameNStart = frameN  # exact frame index
        text_290.tStart = t  # local t and not account for scr refresh
        text_290.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_290, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_290.started')
        text_290.setAutoDraw(True)
    if text_290.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_290.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_290.tStop = t  # not accounting for scr refresh
            text_290.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_290.stopped')
            text_290.setAutoDraw(False)
    
    # *key_resp_58* updates
    waitOnFlip = False
    if key_resp_58.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_58.frameNStart = frameN  # exact frame index
        key_resp_58.tStart = t  # local t and not account for scr refresh
        key_resp_58.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_58, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_58.started')
        key_resp_58.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_58.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_58.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_58.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_58.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_58.tStop = t  # not accounting for scr refresh
            key_resp_58.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_58.stopped')
            key_resp_58.status = FINISHED
    if key_resp_58.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_58.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_58_allKeys.extend(theseKeys)
        if len(_key_resp_58_allKeys):
            key_resp_58.keys = _key_resp_58_allKeys[-1].name  # just the last key pressed
            key_resp_58.rt = _key_resp_58_allKeys[-1].rt
            # was this correct?
            if (key_resp_58.keys == str('n')) or (key_resp_58.keys == 'n'):
                key_resp_58.corr = 1
            else:
                key_resp_58.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in ja_sa_japjaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "ja_sa_japja" ---
for thisComponent in ja_sa_japjaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_58.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_58.keys in ['', [], None]:  # No response was made
    key_resp_58.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_58.corr = 1;  # correct non-response
    else:
       key_resp_58.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_58.keys',key_resp_58.keys)
thisExp.addData('key_resp_58.corr', key_resp_58.corr)
if key_resp_58.keys != None:  # we had a response
    thisExp.addData('key_resp_58.rt', key_resp_58.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "joAApjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_40.setSound('mainpairs/joAApjo.wav', secs=3.5, hamming=True)
sound_vowels_40.setVolume(1.0, log=False)
key_resp_40.keys = []
key_resp_40.rt = []
_key_resp_40_allKeys = []
# keep track of which components have finished
joAApjoComponents = [sound_vowels_40, text_196, text_197, text_198, text_199, text_200, key_resp_40]
for thisComponent in joAApjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "joAApjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_40
    if sound_vowels_40.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_40.frameNStart = frameN  # exact frame index
        sound_vowels_40.tStart = t  # local t and not account for scr refresh
        sound_vowels_40.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_40.started', tThisFlipGlobal)
        sound_vowels_40.play(when=win)  # sync with win flip
    if sound_vowels_40.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_40.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_40.tStop = t  # not accounting for scr refresh
            sound_vowels_40.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_40.stopped')
            sound_vowels_40.stop()
    
    # *text_196* updates
    if text_196.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_196.frameNStart = frameN  # exact frame index
        text_196.tStart = t  # local t and not account for scr refresh
        text_196.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_196, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_196.started')
        text_196.setAutoDraw(True)
    if text_196.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_196.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_196.tStop = t  # not accounting for scr refresh
            text_196.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_196.stopped')
            text_196.setAutoDraw(False)
    
    # *text_197* updates
    if text_197.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_197.frameNStart = frameN  # exact frame index
        text_197.tStart = t  # local t and not account for scr refresh
        text_197.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_197, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_197.started')
        text_197.setAutoDraw(True)
    if text_197.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_197.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_197.tStop = t  # not accounting for scr refresh
            text_197.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_197.stopped')
            text_197.setAutoDraw(False)
    
    # *text_198* updates
    if text_198.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_198.frameNStart = frameN  # exact frame index
        text_198.tStart = t  # local t and not account for scr refresh
        text_198.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_198, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_198.started')
        text_198.setAutoDraw(True)
    if text_198.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_198.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_198.tStop = t  # not accounting for scr refresh
            text_198.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_198.stopped')
            text_198.setAutoDraw(False)
    
    # *text_199* updates
    if text_199.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_199.frameNStart = frameN  # exact frame index
        text_199.tStart = t  # local t and not account for scr refresh
        text_199.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_199, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_199.started')
        text_199.setAutoDraw(True)
    if text_199.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_199.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_199.tStop = t  # not accounting for scr refresh
            text_199.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_199.stopped')
            text_199.setAutoDraw(False)
    
    # *text_200* updates
    if text_200.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_200.frameNStart = frameN  # exact frame index
        text_200.tStart = t  # local t and not account for scr refresh
        text_200.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_200, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_200.started')
        text_200.setAutoDraw(True)
    if text_200.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_200.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_200.tStop = t  # not accounting for scr refresh
            text_200.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_200.stopped')
            text_200.setAutoDraw(False)
    
    # *key_resp_40* updates
    waitOnFlip = False
    if key_resp_40.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_40.frameNStart = frameN  # exact frame index
        key_resp_40.tStart = t  # local t and not account for scr refresh
        key_resp_40.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_40, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_40.started')
        key_resp_40.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_40.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_40.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_40.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_40.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_40.tStop = t  # not accounting for scr refresh
            key_resp_40.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_40.stopped')
            key_resp_40.status = FINISHED
    if key_resp_40.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_40.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_40_allKeys.extend(theseKeys)
        if len(_key_resp_40_allKeys):
            key_resp_40.keys = _key_resp_40_allKeys[-1].name  # just the last key pressed
            key_resp_40.rt = _key_resp_40_allKeys[-1].rt
            # was this correct?
            if (key_resp_40.keys == str('n')) or (key_resp_40.keys == 'n'):
                key_resp_40.corr = 1
            else:
                key_resp_40.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in joAApjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "joAApjo" ---
for thisComponent in joAApjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_40.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_40.keys in ['', [], None]:  # No response was made
    key_resp_40.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_40.corr = 1;  # correct non-response
    else:
       key_resp_40.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_40.keys',key_resp_40.keys)
thisExp.addData('key_resp_40.corr', key_resp_40.corr)
if key_resp_40.keys != None:  # we had a response
    thisExp.addData('key_resp_40.rt', key_resp_40.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "saAsapA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_44.setSound('mainpairs/saAsapA.wav', secs=3.5, hamming=True)
sound_vowels_44.setVolume(1.0, log=False)
key_resp_44.keys = []
key_resp_44.rt = []
_key_resp_44_allKeys = []
# keep track of which components have finished
saAsapAComponents = [sound_vowels_44, text_216, text_217, text_218, text_219, text_220, key_resp_44]
for thisComponent in saAsapAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "saAsapA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_44
    if sound_vowels_44.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_44.frameNStart = frameN  # exact frame index
        sound_vowels_44.tStart = t  # local t and not account for scr refresh
        sound_vowels_44.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_44.started', tThisFlipGlobal)
        sound_vowels_44.play(when=win)  # sync with win flip
    if sound_vowels_44.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_44.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_44.tStop = t  # not accounting for scr refresh
            sound_vowels_44.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_44.stopped')
            sound_vowels_44.stop()
    
    # *text_216* updates
    if text_216.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_216.frameNStart = frameN  # exact frame index
        text_216.tStart = t  # local t and not account for scr refresh
        text_216.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_216, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_216.started')
        text_216.setAutoDraw(True)
    if text_216.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_216.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_216.tStop = t  # not accounting for scr refresh
            text_216.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_216.stopped')
            text_216.setAutoDraw(False)
    
    # *text_217* updates
    if text_217.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_217.frameNStart = frameN  # exact frame index
        text_217.tStart = t  # local t and not account for scr refresh
        text_217.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_217, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_217.started')
        text_217.setAutoDraw(True)
    if text_217.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_217.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_217.tStop = t  # not accounting for scr refresh
            text_217.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_217.stopped')
            text_217.setAutoDraw(False)
    
    # *text_218* updates
    if text_218.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_218.frameNStart = frameN  # exact frame index
        text_218.tStart = t  # local t and not account for scr refresh
        text_218.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_218, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_218.started')
        text_218.setAutoDraw(True)
    if text_218.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_218.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_218.tStop = t  # not accounting for scr refresh
            text_218.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_218.stopped')
            text_218.setAutoDraw(False)
    
    # *text_219* updates
    if text_219.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_219.frameNStart = frameN  # exact frame index
        text_219.tStart = t  # local t and not account for scr refresh
        text_219.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_219, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_219.started')
        text_219.setAutoDraw(True)
    if text_219.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_219.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_219.tStop = t  # not accounting for scr refresh
            text_219.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_219.stopped')
            text_219.setAutoDraw(False)
    
    # *text_220* updates
    if text_220.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_220.frameNStart = frameN  # exact frame index
        text_220.tStart = t  # local t and not account for scr refresh
        text_220.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_220, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_220.started')
        text_220.setAutoDraw(True)
    if text_220.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_220.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_220.tStop = t  # not accounting for scr refresh
            text_220.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_220.stopped')
            text_220.setAutoDraw(False)
    
    # *key_resp_44* updates
    waitOnFlip = False
    if key_resp_44.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_44.frameNStart = frameN  # exact frame index
        key_resp_44.tStart = t  # local t and not account for scr refresh
        key_resp_44.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_44, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_44.started')
        key_resp_44.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_44.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_44.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_44.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_44.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_44.tStop = t  # not accounting for scr refresh
            key_resp_44.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_44.stopped')
            key_resp_44.status = FINISHED
    if key_resp_44.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_44.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_44_allKeys.extend(theseKeys)
        if len(_key_resp_44_allKeys):
            key_resp_44.keys = _key_resp_44_allKeys[-1].name  # just the last key pressed
            key_resp_44.rt = _key_resp_44_allKeys[-1].rt
            # was this correct?
            if (key_resp_44.keys == str('n')) or (key_resp_44.keys == 'n'):
                key_resp_44.corr = 1
            else:
                key_resp_44.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in saAsapAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "saAsapA" ---
for thisComponent in saAsapAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_44.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_44.keys in ['', [], None]:  # No response was made
    key_resp_44.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_44.corr = 1;  # correct non-response
    else:
       key_resp_44.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_44.keys',key_resp_44.keys)
thisExp.addData('key_resp_44.corr', key_resp_44.corr)
if key_resp_44.keys != None:  # we had a response
    thisExp.addData('key_resp_44.rt', key_resp_44.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "ja_sa_japsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_59.setSound('mainpairs/ja+sa.japsa.wav', secs=3.5, hamming=True)
sound_vowels_59.setVolume(1.0, log=False)
key_resp_59.keys = []
key_resp_59.rt = []
_key_resp_59_allKeys = []
# keep track of which components have finished
ja_sa_japsaComponents = [sound_vowels_59, text_291, text_292, text_293, text_294, text_295, key_resp_59]
for thisComponent in ja_sa_japsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "ja_sa_japsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_59
    if sound_vowels_59.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_59.frameNStart = frameN  # exact frame index
        sound_vowels_59.tStart = t  # local t and not account for scr refresh
        sound_vowels_59.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_59.started', tThisFlipGlobal)
        sound_vowels_59.play(when=win)  # sync with win flip
    if sound_vowels_59.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_59.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_59.tStop = t  # not accounting for scr refresh
            sound_vowels_59.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_59.stopped')
            sound_vowels_59.stop()
    
    # *text_291* updates
    if text_291.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_291.frameNStart = frameN  # exact frame index
        text_291.tStart = t  # local t and not account for scr refresh
        text_291.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_291, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_291.started')
        text_291.setAutoDraw(True)
    if text_291.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_291.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_291.tStop = t  # not accounting for scr refresh
            text_291.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_291.stopped')
            text_291.setAutoDraw(False)
    
    # *text_292* updates
    if text_292.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_292.frameNStart = frameN  # exact frame index
        text_292.tStart = t  # local t and not account for scr refresh
        text_292.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_292, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_292.started')
        text_292.setAutoDraw(True)
    if text_292.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_292.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_292.tStop = t  # not accounting for scr refresh
            text_292.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_292.stopped')
            text_292.setAutoDraw(False)
    
    # *text_293* updates
    if text_293.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_293.frameNStart = frameN  # exact frame index
        text_293.tStart = t  # local t and not account for scr refresh
        text_293.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_293, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_293.started')
        text_293.setAutoDraw(True)
    if text_293.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_293.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_293.tStop = t  # not accounting for scr refresh
            text_293.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_293.stopped')
            text_293.setAutoDraw(False)
    
    # *text_294* updates
    if text_294.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_294.frameNStart = frameN  # exact frame index
        text_294.tStart = t  # local t and not account for scr refresh
        text_294.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_294, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_294.started')
        text_294.setAutoDraw(True)
    if text_294.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_294.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_294.tStop = t  # not accounting for scr refresh
            text_294.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_294.stopped')
            text_294.setAutoDraw(False)
    
    # *text_295* updates
    if text_295.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_295.frameNStart = frameN  # exact frame index
        text_295.tStart = t  # local t and not account for scr refresh
        text_295.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_295, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_295.started')
        text_295.setAutoDraw(True)
    if text_295.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_295.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_295.tStop = t  # not accounting for scr refresh
            text_295.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_295.stopped')
            text_295.setAutoDraw(False)
    
    # *key_resp_59* updates
    waitOnFlip = False
    if key_resp_59.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_59.frameNStart = frameN  # exact frame index
        key_resp_59.tStart = t  # local t and not account for scr refresh
        key_resp_59.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_59, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_59.started')
        key_resp_59.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_59.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_59.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_59.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_59.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_59.tStop = t  # not accounting for scr refresh
            key_resp_59.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_59.stopped')
            key_resp_59.status = FINISHED
    if key_resp_59.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_59.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_59_allKeys.extend(theseKeys)
        if len(_key_resp_59_allKeys):
            key_resp_59.keys = _key_resp_59_allKeys[-1].name  # just the last key pressed
            key_resp_59.rt = _key_resp_59_allKeys[-1].rt
            # was this correct?
            if (key_resp_59.keys == str('n')) or (key_resp_59.keys == 'n'):
                key_resp_59.corr = 1
            else:
                key_resp_59.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in ja_sa_japsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "ja_sa_japsa" ---
for thisComponent in ja_sa_japsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_59.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_59.keys in ['', [], None]:  # No response was made
    key_resp_59.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_59.corr = 1;  # correct non-response
    else:
       key_resp_59.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_59.keys',key_resp_59.keys)
thisExp.addData('key_resp_59.corr', key_resp_59.corr)
if key_resp_59.keys != None:  # we had a response
    thisExp.addData('key_resp_59.rt', key_resp_59.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sopjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_39.setSound('mainpairs/sopjo.wav', secs=3.5, hamming=True)
sound_vowels_39.setVolume(1.0, log=False)
key_resp_39.keys = []
key_resp_39.rt = []
_key_resp_39_allKeys = []
# keep track of which components have finished
sopjoComponents = [sound_vowels_39, text_191, text_192, text_193, text_194, text_195, key_resp_39]
for thisComponent in sopjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sopjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_39
    if sound_vowels_39.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_39.frameNStart = frameN  # exact frame index
        sound_vowels_39.tStart = t  # local t and not account for scr refresh
        sound_vowels_39.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_39.started', tThisFlipGlobal)
        sound_vowels_39.play(when=win)  # sync with win flip
    if sound_vowels_39.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_39.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_39.tStop = t  # not accounting for scr refresh
            sound_vowels_39.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_39.stopped')
            sound_vowels_39.stop()
    
    # *text_191* updates
    if text_191.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_191.frameNStart = frameN  # exact frame index
        text_191.tStart = t  # local t and not account for scr refresh
        text_191.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_191, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_191.started')
        text_191.setAutoDraw(True)
    if text_191.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_191.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_191.tStop = t  # not accounting for scr refresh
            text_191.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_191.stopped')
            text_191.setAutoDraw(False)
    
    # *text_192* updates
    if text_192.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_192.frameNStart = frameN  # exact frame index
        text_192.tStart = t  # local t and not account for scr refresh
        text_192.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_192, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_192.started')
        text_192.setAutoDraw(True)
    if text_192.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_192.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_192.tStop = t  # not accounting for scr refresh
            text_192.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_192.stopped')
            text_192.setAutoDraw(False)
    
    # *text_193* updates
    if text_193.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_193.frameNStart = frameN  # exact frame index
        text_193.tStart = t  # local t and not account for scr refresh
        text_193.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_193, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_193.started')
        text_193.setAutoDraw(True)
    if text_193.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_193.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_193.tStop = t  # not accounting for scr refresh
            text_193.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_193.stopped')
            text_193.setAutoDraw(False)
    
    # *text_194* updates
    if text_194.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_194.frameNStart = frameN  # exact frame index
        text_194.tStart = t  # local t and not account for scr refresh
        text_194.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_194, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_194.started')
        text_194.setAutoDraw(True)
    if text_194.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_194.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_194.tStop = t  # not accounting for scr refresh
            text_194.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_194.stopped')
            text_194.setAutoDraw(False)
    
    # *text_195* updates
    if text_195.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_195.frameNStart = frameN  # exact frame index
        text_195.tStart = t  # local t and not account for scr refresh
        text_195.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_195, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_195.started')
        text_195.setAutoDraw(True)
    if text_195.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_195.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_195.tStop = t  # not accounting for scr refresh
            text_195.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_195.stopped')
            text_195.setAutoDraw(False)
    
    # *key_resp_39* updates
    waitOnFlip = False
    if key_resp_39.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_39.frameNStart = frameN  # exact frame index
        key_resp_39.tStart = t  # local t and not account for scr refresh
        key_resp_39.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_39, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_39.started')
        key_resp_39.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_39.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_39.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_39.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_39.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_39.tStop = t  # not accounting for scr refresh
            key_resp_39.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_39.stopped')
            key_resp_39.status = FINISHED
    if key_resp_39.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_39.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_39_allKeys.extend(theseKeys)
        if len(_key_resp_39_allKeys):
            key_resp_39.keys = _key_resp_39_allKeys[-1].name  # just the last key pressed
            key_resp_39.rt = _key_resp_39_allKeys[-1].rt
            # was this correct?
            if (key_resp_39.keys == str('n')) or (key_resp_39.keys == 'n'):
                key_resp_39.corr = 1
            else:
                key_resp_39.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sopjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sopjo" ---
for thisComponent in sopjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_39.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_39.keys in ['', [], None]:  # No response was made
    key_resp_39.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_39.corr = 1;  # correct non-response
    else:
       key_resp_39.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_39.keys',key_resp_39.keys)
thisExp.addData('key_resp_39.corr', key_resp_39.corr)
if key_resp_39.keys != None:  # we had a response
    thisExp.addData('key_resp_39.rt', key_resp_39.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_A_sa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_78.setSound('mainpairs/sa+A.sa.wav', secs=3.5, hamming=True)
sound_vowels_78.setVolume(1.0, log=False)
key_resp_78.keys = []
key_resp_78.rt = []
_key_resp_78_allKeys = []
# keep track of which components have finished
sa_A_saComponents = [sound_vowels_78, text_386, text_387, text_388, text_389, text_390, key_resp_78]
for thisComponent in sa_A_saComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_A_sa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_78
    if sound_vowels_78.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_78.frameNStart = frameN  # exact frame index
        sound_vowels_78.tStart = t  # local t and not account for scr refresh
        sound_vowels_78.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_78.started', tThisFlipGlobal)
        sound_vowels_78.play(when=win)  # sync with win flip
    if sound_vowels_78.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_78.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_78.tStop = t  # not accounting for scr refresh
            sound_vowels_78.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_78.stopped')
            sound_vowels_78.stop()
    
    # *text_386* updates
    if text_386.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_386.frameNStart = frameN  # exact frame index
        text_386.tStart = t  # local t and not account for scr refresh
        text_386.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_386, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_386.started')
        text_386.setAutoDraw(True)
    if text_386.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_386.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_386.tStop = t  # not accounting for scr refresh
            text_386.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_386.stopped')
            text_386.setAutoDraw(False)
    
    # *text_387* updates
    if text_387.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_387.frameNStart = frameN  # exact frame index
        text_387.tStart = t  # local t and not account for scr refresh
        text_387.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_387, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_387.started')
        text_387.setAutoDraw(True)
    if text_387.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_387.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_387.tStop = t  # not accounting for scr refresh
            text_387.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_387.stopped')
            text_387.setAutoDraw(False)
    
    # *text_388* updates
    if text_388.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_388.frameNStart = frameN  # exact frame index
        text_388.tStart = t  # local t and not account for scr refresh
        text_388.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_388, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_388.started')
        text_388.setAutoDraw(True)
    if text_388.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_388.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_388.tStop = t  # not accounting for scr refresh
            text_388.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_388.stopped')
            text_388.setAutoDraw(False)
    
    # *text_389* updates
    if text_389.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_389.frameNStart = frameN  # exact frame index
        text_389.tStart = t  # local t and not account for scr refresh
        text_389.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_389, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_389.started')
        text_389.setAutoDraw(True)
    if text_389.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_389.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_389.tStop = t  # not accounting for scr refresh
            text_389.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_389.stopped')
            text_389.setAutoDraw(False)
    
    # *text_390* updates
    if text_390.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_390.frameNStart = frameN  # exact frame index
        text_390.tStart = t  # local t and not account for scr refresh
        text_390.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_390, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_390.started')
        text_390.setAutoDraw(True)
    if text_390.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_390.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_390.tStop = t  # not accounting for scr refresh
            text_390.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_390.stopped')
            text_390.setAutoDraw(False)
    
    # *key_resp_78* updates
    waitOnFlip = False
    if key_resp_78.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_78.frameNStart = frameN  # exact frame index
        key_resp_78.tStart = t  # local t and not account for scr refresh
        key_resp_78.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_78, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_78.started')
        key_resp_78.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_78.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_78.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_78.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_78.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_78.tStop = t  # not accounting for scr refresh
            key_resp_78.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_78.stopped')
            key_resp_78.status = FINISHED
    if key_resp_78.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_78.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_78_allKeys.extend(theseKeys)
        if len(_key_resp_78_allKeys):
            key_resp_78.keys = _key_resp_78_allKeys[-1].name  # just the last key pressed
            key_resp_78.rt = _key_resp_78_allKeys[-1].rt
            # was this correct?
            if (key_resp_78.keys == str('y')) or (key_resp_78.keys == 'y'):
                key_resp_78.corr = 1
            else:
                key_resp_78.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_A_saComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_A_sa" ---
for thisComponent in sa_A_saComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_78.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_78.keys in ['', [], None]:  # No response was made
    key_resp_78.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_78.corr = 1;  # correct non-response
    else:
       key_resp_78.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_78.keys',key_resp_78.keys)
thisExp.addData('key_resp_78.corr', key_resp_78.corr)
if key_resp_78.keys != None:  # we had a response
    thisExp.addData('key_resp_78.rt', key_resp_78.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jojoApjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_48.setSound('mainpairs/jojoApjo.wav', secs=3.5, hamming=True)
sound_vowels_48.setVolume(1.0, log=False)
key_resp_48.keys = []
key_resp_48.rt = []
_key_resp_48_allKeys = []
# keep track of which components have finished
jojoApjoComponents = [sound_vowels_48, text_236, text_237, text_238, text_239, text_240, key_resp_48]
for thisComponent in jojoApjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jojoApjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_48
    if sound_vowels_48.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_48.frameNStart = frameN  # exact frame index
        sound_vowels_48.tStart = t  # local t and not account for scr refresh
        sound_vowels_48.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_48.started', tThisFlipGlobal)
        sound_vowels_48.play(when=win)  # sync with win flip
    if sound_vowels_48.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_48.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_48.tStop = t  # not accounting for scr refresh
            sound_vowels_48.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_48.stopped')
            sound_vowels_48.stop()
    
    # *text_236* updates
    if text_236.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_236.frameNStart = frameN  # exact frame index
        text_236.tStart = t  # local t and not account for scr refresh
        text_236.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_236, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_236.started')
        text_236.setAutoDraw(True)
    if text_236.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_236.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_236.tStop = t  # not accounting for scr refresh
            text_236.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_236.stopped')
            text_236.setAutoDraw(False)
    
    # *text_237* updates
    if text_237.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_237.frameNStart = frameN  # exact frame index
        text_237.tStart = t  # local t and not account for scr refresh
        text_237.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_237, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_237.started')
        text_237.setAutoDraw(True)
    if text_237.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_237.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_237.tStop = t  # not accounting for scr refresh
            text_237.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_237.stopped')
            text_237.setAutoDraw(False)
    
    # *text_238* updates
    if text_238.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_238.frameNStart = frameN  # exact frame index
        text_238.tStart = t  # local t and not account for scr refresh
        text_238.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_238, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_238.started')
        text_238.setAutoDraw(True)
    if text_238.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_238.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_238.tStop = t  # not accounting for scr refresh
            text_238.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_238.stopped')
            text_238.setAutoDraw(False)
    
    # *text_239* updates
    if text_239.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_239.frameNStart = frameN  # exact frame index
        text_239.tStart = t  # local t and not account for scr refresh
        text_239.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_239, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_239.started')
        text_239.setAutoDraw(True)
    if text_239.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_239.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_239.tStop = t  # not accounting for scr refresh
            text_239.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_239.stopped')
            text_239.setAutoDraw(False)
    
    # *text_240* updates
    if text_240.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_240.frameNStart = frameN  # exact frame index
        text_240.tStart = t  # local t and not account for scr refresh
        text_240.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_240, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_240.started')
        text_240.setAutoDraw(True)
    if text_240.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_240.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_240.tStop = t  # not accounting for scr refresh
            text_240.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_240.stopped')
            text_240.setAutoDraw(False)
    
    # *key_resp_48* updates
    waitOnFlip = False
    if key_resp_48.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_48.frameNStart = frameN  # exact frame index
        key_resp_48.tStart = t  # local t and not account for scr refresh
        key_resp_48.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_48, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_48.started')
        key_resp_48.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_48.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_48.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_48.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_48.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_48.tStop = t  # not accounting for scr refresh
            key_resp_48.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_48.stopped')
            key_resp_48.status = FINISHED
    if key_resp_48.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_48.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_48_allKeys.extend(theseKeys)
        if len(_key_resp_48_allKeys):
            key_resp_48.keys = _key_resp_48_allKeys[-1].name  # just the last key pressed
            key_resp_48.rt = _key_resp_48_allKeys[-1].rt
            # was this correct?
            if (key_resp_48.keys == str('n')) or (key_resp_48.keys == 'n'):
                key_resp_48.corr = 1
            else:
                key_resp_48.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jojoApjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jojoApjo" ---
for thisComponent in jojoApjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_48.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_48.keys in ['', [], None]:  # No response was made
    key_resp_48.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_48.corr = 1;  # correct non-response
    else:
       key_resp_48.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_48.keys',key_resp_48.keys)
thisExp.addData('key_resp_48.corr', key_resp_48.corr)
if key_resp_48.keys != None:  # we had a response
    thisExp.addData('key_resp_48.rt', key_resp_48.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "uusopu" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_93.setSound('mainpairs/uusopu.wav', secs=3.5, hamming=True)
sound_vowels_93.setVolume(1.0, log=False)
key_resp_93.keys = []
key_resp_93.rt = []
_key_resp_93_allKeys = []
# keep track of which components have finished
uusopuComponents = [sound_vowels_93, text_461, text_462, text_463, text_464, text_465, key_resp_93]
for thisComponent in uusopuComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "uusopu" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_93
    if sound_vowels_93.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_93.frameNStart = frameN  # exact frame index
        sound_vowels_93.tStart = t  # local t and not account for scr refresh
        sound_vowels_93.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_93.started', tThisFlipGlobal)
        sound_vowels_93.play(when=win)  # sync with win flip
    if sound_vowels_93.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_93.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_93.tStop = t  # not accounting for scr refresh
            sound_vowels_93.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_93.stopped')
            sound_vowels_93.stop()
    
    # *text_461* updates
    if text_461.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_461.frameNStart = frameN  # exact frame index
        text_461.tStart = t  # local t and not account for scr refresh
        text_461.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_461, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_461.started')
        text_461.setAutoDraw(True)
    if text_461.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_461.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_461.tStop = t  # not accounting for scr refresh
            text_461.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_461.stopped')
            text_461.setAutoDraw(False)
    
    # *text_462* updates
    if text_462.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_462.frameNStart = frameN  # exact frame index
        text_462.tStart = t  # local t and not account for scr refresh
        text_462.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_462, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_462.started')
        text_462.setAutoDraw(True)
    if text_462.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_462.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_462.tStop = t  # not accounting for scr refresh
            text_462.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_462.stopped')
            text_462.setAutoDraw(False)
    
    # *text_463* updates
    if text_463.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_463.frameNStart = frameN  # exact frame index
        text_463.tStart = t  # local t and not account for scr refresh
        text_463.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_463, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_463.started')
        text_463.setAutoDraw(True)
    if text_463.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_463.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_463.tStop = t  # not accounting for scr refresh
            text_463.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_463.stopped')
            text_463.setAutoDraw(False)
    
    # *text_464* updates
    if text_464.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_464.frameNStart = frameN  # exact frame index
        text_464.tStart = t  # local t and not account for scr refresh
        text_464.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_464, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_464.started')
        text_464.setAutoDraw(True)
    if text_464.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_464.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_464.tStop = t  # not accounting for scr refresh
            text_464.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_464.stopped')
            text_464.setAutoDraw(False)
    
    # *text_465* updates
    if text_465.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_465.frameNStart = frameN  # exact frame index
        text_465.tStart = t  # local t and not account for scr refresh
        text_465.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_465, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_465.started')
        text_465.setAutoDraw(True)
    if text_465.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_465.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_465.tStop = t  # not accounting for scr refresh
            text_465.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_465.stopped')
            text_465.setAutoDraw(False)
    
    # *key_resp_93* updates
    waitOnFlip = False
    if key_resp_93.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_93.frameNStart = frameN  # exact frame index
        key_resp_93.tStart = t  # local t and not account for scr refresh
        key_resp_93.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_93, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_93.started')
        key_resp_93.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_93.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_93.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_93.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_93.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_93.tStop = t  # not accounting for scr refresh
            key_resp_93.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_93.stopped')
            key_resp_93.status = FINISHED
    if key_resp_93.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_93.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_93_allKeys.extend(theseKeys)
        if len(_key_resp_93_allKeys):
            key_resp_93.keys = _key_resp_93_allKeys[-1].name  # just the last key pressed
            key_resp_93.rt = _key_resp_93_allKeys[-1].rt
            # was this correct?
            if (key_resp_93.keys == str('n')) or (key_resp_93.keys == 'n'):
                key_resp_93.corr = 1
            else:
                key_resp_93.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in uusopuComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "uusopu" ---
for thisComponent in uusopuComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_93.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_93.keys in ['', [], None]:  # No response was made
    key_resp_93.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_93.corr = 1;  # correct non-response
    else:
       key_resp_93.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_93.keys',key_resp_93.keys)
thisExp.addData('key_resp_93.corr', key_resp_93.corr)
if key_resp_93.keys != None:  # we had a response
    thisExp.addData('key_resp_93.rt', key_resp_93.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sojosojopjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_54.setSound('mainpairs/sojosojopjo.wav', secs=3.5, hamming=True)
sound_vowels_54.setVolume(1.0, log=False)
key_resp_54.keys = []
key_resp_54.rt = []
_key_resp_54_allKeys = []
# keep track of which components have finished
sojosojopjoComponents = [sound_vowels_54, text_266, text_267, text_268, text_269, text_270, key_resp_54]
for thisComponent in sojosojopjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sojosojopjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_54
    if sound_vowels_54.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_54.frameNStart = frameN  # exact frame index
        sound_vowels_54.tStart = t  # local t and not account for scr refresh
        sound_vowels_54.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_54.started', tThisFlipGlobal)
        sound_vowels_54.play(when=win)  # sync with win flip
    if sound_vowels_54.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_54.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_54.tStop = t  # not accounting for scr refresh
            sound_vowels_54.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_54.stopped')
            sound_vowels_54.stop()
    
    # *text_266* updates
    if text_266.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_266.frameNStart = frameN  # exact frame index
        text_266.tStart = t  # local t and not account for scr refresh
        text_266.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_266, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_266.started')
        text_266.setAutoDraw(True)
    if text_266.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_266.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_266.tStop = t  # not accounting for scr refresh
            text_266.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_266.stopped')
            text_266.setAutoDraw(False)
    
    # *text_267* updates
    if text_267.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_267.frameNStart = frameN  # exact frame index
        text_267.tStart = t  # local t and not account for scr refresh
        text_267.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_267, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_267.started')
        text_267.setAutoDraw(True)
    if text_267.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_267.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_267.tStop = t  # not accounting for scr refresh
            text_267.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_267.stopped')
            text_267.setAutoDraw(False)
    
    # *text_268* updates
    if text_268.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_268.frameNStart = frameN  # exact frame index
        text_268.tStart = t  # local t and not account for scr refresh
        text_268.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_268, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_268.started')
        text_268.setAutoDraw(True)
    if text_268.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_268.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_268.tStop = t  # not accounting for scr refresh
            text_268.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_268.stopped')
            text_268.setAutoDraw(False)
    
    # *text_269* updates
    if text_269.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_269.frameNStart = frameN  # exact frame index
        text_269.tStart = t  # local t and not account for scr refresh
        text_269.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_269, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_269.started')
        text_269.setAutoDraw(True)
    if text_269.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_269.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_269.tStop = t  # not accounting for scr refresh
            text_269.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_269.stopped')
            text_269.setAutoDraw(False)
    
    # *text_270* updates
    if text_270.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_270.frameNStart = frameN  # exact frame index
        text_270.tStart = t  # local t and not account for scr refresh
        text_270.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_270, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_270.started')
        text_270.setAutoDraw(True)
    if text_270.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_270.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_270.tStop = t  # not accounting for scr refresh
            text_270.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_270.stopped')
            text_270.setAutoDraw(False)
    
    # *key_resp_54* updates
    waitOnFlip = False
    if key_resp_54.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_54.frameNStart = frameN  # exact frame index
        key_resp_54.tStart = t  # local t and not account for scr refresh
        key_resp_54.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_54, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_54.started')
        key_resp_54.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_54.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_54.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_54.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_54.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_54.tStop = t  # not accounting for scr refresh
            key_resp_54.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_54.stopped')
            key_resp_54.status = FINISHED
    if key_resp_54.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_54.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_54_allKeys.extend(theseKeys)
        if len(_key_resp_54_allKeys):
            key_resp_54.keys = _key_resp_54_allKeys[-1].name  # just the last key pressed
            key_resp_54.rt = _key_resp_54_allKeys[-1].rt
            # was this correct?
            if (key_resp_54.keys == str('n')) or (key_resp_54.keys == 'n'):
                key_resp_54.corr = 1
            else:
                key_resp_54.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sojosojopjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sojosojopjo" ---
for thisComponent in sojosojopjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_54.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_54.keys in ['', [], None]:  # No response was made
    key_resp_54.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_54.corr = 1;  # correct non-response
    else:
       key_resp_54.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_54.keys',key_resp_54.keys)
thisExp.addData('key_resp_54.corr', key_resp_54.corr)
if key_resp_54.keys != None:  # we had a response
    thisExp.addData('key_resp_54.rt', key_resp_54.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sosojopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_50.setSound('mainpairs/sosojopso.wav', secs=3.5, hamming=True)
sound_vowels_50.setVolume(1.0, log=False)
key_resp_50.keys = []
key_resp_50.rt = []
_key_resp_50_allKeys = []
# keep track of which components have finished
sosojopsoComponents = [sound_vowels_50, text_246, text_247, text_248, text_249, text_250, key_resp_50]
for thisComponent in sosojopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sosojopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_50
    if sound_vowels_50.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_50.frameNStart = frameN  # exact frame index
        sound_vowels_50.tStart = t  # local t and not account for scr refresh
        sound_vowels_50.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_50.started', tThisFlipGlobal)
        sound_vowels_50.play(when=win)  # sync with win flip
    if sound_vowels_50.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_50.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_50.tStop = t  # not accounting for scr refresh
            sound_vowels_50.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_50.stopped')
            sound_vowels_50.stop()
    
    # *text_246* updates
    if text_246.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_246.frameNStart = frameN  # exact frame index
        text_246.tStart = t  # local t and not account for scr refresh
        text_246.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_246, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_246.started')
        text_246.setAutoDraw(True)
    if text_246.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_246.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_246.tStop = t  # not accounting for scr refresh
            text_246.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_246.stopped')
            text_246.setAutoDraw(False)
    
    # *text_247* updates
    if text_247.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_247.frameNStart = frameN  # exact frame index
        text_247.tStart = t  # local t and not account for scr refresh
        text_247.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_247, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_247.started')
        text_247.setAutoDraw(True)
    if text_247.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_247.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_247.tStop = t  # not accounting for scr refresh
            text_247.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_247.stopped')
            text_247.setAutoDraw(False)
    
    # *text_248* updates
    if text_248.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_248.frameNStart = frameN  # exact frame index
        text_248.tStart = t  # local t and not account for scr refresh
        text_248.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_248, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_248.started')
        text_248.setAutoDraw(True)
    if text_248.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_248.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_248.tStop = t  # not accounting for scr refresh
            text_248.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_248.stopped')
            text_248.setAutoDraw(False)
    
    # *text_249* updates
    if text_249.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_249.frameNStart = frameN  # exact frame index
        text_249.tStart = t  # local t and not account for scr refresh
        text_249.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_249, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_249.started')
        text_249.setAutoDraw(True)
    if text_249.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_249.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_249.tStop = t  # not accounting for scr refresh
            text_249.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_249.stopped')
            text_249.setAutoDraw(False)
    
    # *text_250* updates
    if text_250.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_250.frameNStart = frameN  # exact frame index
        text_250.tStart = t  # local t and not account for scr refresh
        text_250.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_250, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_250.started')
        text_250.setAutoDraw(True)
    if text_250.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_250.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_250.tStop = t  # not accounting for scr refresh
            text_250.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_250.stopped')
            text_250.setAutoDraw(False)
    
    # *key_resp_50* updates
    waitOnFlip = False
    if key_resp_50.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_50.frameNStart = frameN  # exact frame index
        key_resp_50.tStart = t  # local t and not account for scr refresh
        key_resp_50.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_50, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_50.started')
        key_resp_50.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_50.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_50.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_50.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_50.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_50.tStop = t  # not accounting for scr refresh
            key_resp_50.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_50.stopped')
            key_resp_50.status = FINISHED
    if key_resp_50.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_50.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_50_allKeys.extend(theseKeys)
        if len(_key_resp_50_allKeys):
            key_resp_50.keys = _key_resp_50_allKeys[-1].name  # just the last key pressed
            key_resp_50.rt = _key_resp_50_allKeys[-1].rt
            # was this correct?
            if (key_resp_50.keys == str('n')) or (key_resp_50.keys == 'n'):
                key_resp_50.corr = 1
            else:
                key_resp_50.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sosojopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sosojopso" ---
for thisComponent in sosojopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_50.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_50.keys in ['', [], None]:  # No response was made
    key_resp_50.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_50.corr = 1;  # correct non-response
    else:
       key_resp_50.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_50.keys',key_resp_50.keys)
thisExp.addData('key_resp_50.corr', key_resp_50.corr)
if key_resp_50.keys != None:  # we had a response
    thisExp.addData('key_resp_50.rt', key_resp_50.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "A_sa_sapsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_8.setSound('mainpairs/A.sa+sapsa.wav', secs=3.5, hamming=True)
sound_vowels_8.setVolume(1.0, log=False)
key_resp_8.keys = []
key_resp_8.rt = []
_key_resp_8_allKeys = []
# keep track of which components have finished
A_sa_sapsaComponents = [sound_vowels_8, text_36, text_37, text_38, text_39, text_40, key_resp_8]
for thisComponent in A_sa_sapsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "A_sa_sapsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_8
    if sound_vowels_8.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_8.frameNStart = frameN  # exact frame index
        sound_vowels_8.tStart = t  # local t and not account for scr refresh
        sound_vowels_8.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_8.started', tThisFlipGlobal)
        sound_vowels_8.play(when=win)  # sync with win flip
    if sound_vowels_8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_8.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_8.tStop = t  # not accounting for scr refresh
            sound_vowels_8.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_8.stopped')
            sound_vowels_8.stop()
    
    # *text_36* updates
    if text_36.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_36.frameNStart = frameN  # exact frame index
        text_36.tStart = t  # local t and not account for scr refresh
        text_36.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_36, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_36.started')
        text_36.setAutoDraw(True)
    if text_36.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_36.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_36.tStop = t  # not accounting for scr refresh
            text_36.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_36.stopped')
            text_36.setAutoDraw(False)
    
    # *text_37* updates
    if text_37.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_37.frameNStart = frameN  # exact frame index
        text_37.tStart = t  # local t and not account for scr refresh
        text_37.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_37, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_37.started')
        text_37.setAutoDraw(True)
    if text_37.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_37.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_37.tStop = t  # not accounting for scr refresh
            text_37.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_37.stopped')
            text_37.setAutoDraw(False)
    
    # *text_38* updates
    if text_38.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_38.frameNStart = frameN  # exact frame index
        text_38.tStart = t  # local t and not account for scr refresh
        text_38.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_38, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_38.started')
        text_38.setAutoDraw(True)
    if text_38.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_38.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_38.tStop = t  # not accounting for scr refresh
            text_38.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_38.stopped')
            text_38.setAutoDraw(False)
    
    # *text_39* updates
    if text_39.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_39.frameNStart = frameN  # exact frame index
        text_39.tStart = t  # local t and not account for scr refresh
        text_39.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_39, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_39.started')
        text_39.setAutoDraw(True)
    if text_39.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_39.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_39.tStop = t  # not accounting for scr refresh
            text_39.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_39.stopped')
            text_39.setAutoDraw(False)
    
    # *text_40* updates
    if text_40.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_40.frameNStart = frameN  # exact frame index
        text_40.tStart = t  # local t and not account for scr refresh
        text_40.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_40, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_40.started')
        text_40.setAutoDraw(True)
    if text_40.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_40.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_40.tStop = t  # not accounting for scr refresh
            text_40.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_40.stopped')
            text_40.setAutoDraw(False)
    
    # *key_resp_8* updates
    waitOnFlip = False
    if key_resp_8.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_8.frameNStart = frameN  # exact frame index
        key_resp_8.tStart = t  # local t and not account for scr refresh
        key_resp_8.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_8, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_8.started')
        key_resp_8.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_8.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_8.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_8.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_8.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_8.tStop = t  # not accounting for scr refresh
            key_resp_8.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_8.stopped')
            key_resp_8.status = FINISHED
    if key_resp_8.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_8.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_8_allKeys.extend(theseKeys)
        if len(_key_resp_8_allKeys):
            key_resp_8.keys = _key_resp_8_allKeys[-1].name  # just the last key pressed
            key_resp_8.rt = _key_resp_8_allKeys[-1].rt
            # was this correct?
            if (key_resp_8.keys == str('y')) or (key_resp_8.keys == 'y'):
                key_resp_8.corr = 1
            else:
                key_resp_8.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in A_sa_sapsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "A_sa_sapsa" ---
for thisComponent in A_sa_sapsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_8.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_8.keys in ['', [], None]:  # No response was made
    key_resp_8.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_8.corr = 1;  # correct non-response
    else:
       key_resp_8.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_8.keys',key_resp_8.keys)
thisExp.addData('key_resp_8.corr', key_resp_8.corr)
if key_resp_8.keys != None:  # we had a response
    thisExp.addData('key_resp_8.rt', key_resp_8.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jo_A_jo_A" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_71.setSound('mainpairs/jo.A+jo.A.wav', secs=3.5, hamming=True)
sound_vowels_71.setVolume(1.0, log=False)
key_resp_71.keys = []
key_resp_71.rt = []
_key_resp_71_allKeys = []
# keep track of which components have finished
jo_A_jo_AComponents = [sound_vowels_71, text_351, text_352, text_353, text_354, text_355, key_resp_71]
for thisComponent in jo_A_jo_AComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jo_A_jo_A" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_71
    if sound_vowels_71.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_71.frameNStart = frameN  # exact frame index
        sound_vowels_71.tStart = t  # local t and not account for scr refresh
        sound_vowels_71.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_71.started', tThisFlipGlobal)
        sound_vowels_71.play(when=win)  # sync with win flip
    if sound_vowels_71.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_71.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_71.tStop = t  # not accounting for scr refresh
            sound_vowels_71.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_71.stopped')
            sound_vowels_71.stop()
    
    # *text_351* updates
    if text_351.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_351.frameNStart = frameN  # exact frame index
        text_351.tStart = t  # local t and not account for scr refresh
        text_351.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_351, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_351.started')
        text_351.setAutoDraw(True)
    if text_351.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_351.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_351.tStop = t  # not accounting for scr refresh
            text_351.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_351.stopped')
            text_351.setAutoDraw(False)
    
    # *text_352* updates
    if text_352.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_352.frameNStart = frameN  # exact frame index
        text_352.tStart = t  # local t and not account for scr refresh
        text_352.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_352, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_352.started')
        text_352.setAutoDraw(True)
    if text_352.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_352.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_352.tStop = t  # not accounting for scr refresh
            text_352.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_352.stopped')
            text_352.setAutoDraw(False)
    
    # *text_353* updates
    if text_353.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_353.frameNStart = frameN  # exact frame index
        text_353.tStart = t  # local t and not account for scr refresh
        text_353.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_353, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_353.started')
        text_353.setAutoDraw(True)
    if text_353.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_353.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_353.tStop = t  # not accounting for scr refresh
            text_353.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_353.stopped')
            text_353.setAutoDraw(False)
    
    # *text_354* updates
    if text_354.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_354.frameNStart = frameN  # exact frame index
        text_354.tStart = t  # local t and not account for scr refresh
        text_354.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_354, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_354.started')
        text_354.setAutoDraw(True)
    if text_354.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_354.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_354.tStop = t  # not accounting for scr refresh
            text_354.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_354.stopped')
            text_354.setAutoDraw(False)
    
    # *text_355* updates
    if text_355.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_355.frameNStart = frameN  # exact frame index
        text_355.tStart = t  # local t and not account for scr refresh
        text_355.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_355, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_355.started')
        text_355.setAutoDraw(True)
    if text_355.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_355.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_355.tStop = t  # not accounting for scr refresh
            text_355.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_355.stopped')
            text_355.setAutoDraw(False)
    
    # *key_resp_71* updates
    waitOnFlip = False
    if key_resp_71.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_71.frameNStart = frameN  # exact frame index
        key_resp_71.tStart = t  # local t and not account for scr refresh
        key_resp_71.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_71, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_71.started')
        key_resp_71.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_71.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_71.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_71.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_71.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_71.tStop = t  # not accounting for scr refresh
            key_resp_71.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_71.stopped')
            key_resp_71.status = FINISHED
    if key_resp_71.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_71.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_71_allKeys.extend(theseKeys)
        if len(_key_resp_71_allKeys):
            key_resp_71.keys = _key_resp_71_allKeys[-1].name  # just the last key pressed
            key_resp_71.rt = _key_resp_71_allKeys[-1].rt
            # was this correct?
            if (key_resp_71.keys == str('y')) or (key_resp_71.keys == 'y'):
                key_resp_71.corr = 1
            else:
                key_resp_71.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jo_A_jo_AComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jo_A_jo_A" ---
for thisComponent in jo_A_jo_AComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_71.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_71.keys in ['', [], None]:  # No response was made
    key_resp_71.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_71.corr = 1;  # correct non-response
    else:
       key_resp_71.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_71.keys',key_resp_71.keys)
thisExp.addData('key_resp_71.corr', key_resp_71.corr)
if key_resp_71.keys != None:  # we had a response
    thisExp.addData('key_resp_71.rt', key_resp_71.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jo_so_jo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_74.setSound('mainpairs/jo+so.jo.wav', secs=3.5, hamming=True)
sound_vowels_74.setVolume(1.0, log=False)
key_resp_74.keys = []
key_resp_74.rt = []
_key_resp_74_allKeys = []
# keep track of which components have finished
jo_so_joComponents = [sound_vowels_74, text_366, text_367, text_368, text_369, text_370, key_resp_74]
for thisComponent in jo_so_joComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jo_so_jo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_74
    if sound_vowels_74.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_74.frameNStart = frameN  # exact frame index
        sound_vowels_74.tStart = t  # local t and not account for scr refresh
        sound_vowels_74.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_74.started', tThisFlipGlobal)
        sound_vowels_74.play(when=win)  # sync with win flip
    if sound_vowels_74.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_74.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_74.tStop = t  # not accounting for scr refresh
            sound_vowels_74.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_74.stopped')
            sound_vowels_74.stop()
    
    # *text_366* updates
    if text_366.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_366.frameNStart = frameN  # exact frame index
        text_366.tStart = t  # local t and not account for scr refresh
        text_366.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_366, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_366.started')
        text_366.setAutoDraw(True)
    if text_366.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_366.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_366.tStop = t  # not accounting for scr refresh
            text_366.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_366.stopped')
            text_366.setAutoDraw(False)
    
    # *text_367* updates
    if text_367.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_367.frameNStart = frameN  # exact frame index
        text_367.tStart = t  # local t and not account for scr refresh
        text_367.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_367, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_367.started')
        text_367.setAutoDraw(True)
    if text_367.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_367.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_367.tStop = t  # not accounting for scr refresh
            text_367.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_367.stopped')
            text_367.setAutoDraw(False)
    
    # *text_368* updates
    if text_368.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_368.frameNStart = frameN  # exact frame index
        text_368.tStart = t  # local t and not account for scr refresh
        text_368.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_368, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_368.started')
        text_368.setAutoDraw(True)
    if text_368.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_368.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_368.tStop = t  # not accounting for scr refresh
            text_368.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_368.stopped')
            text_368.setAutoDraw(False)
    
    # *text_369* updates
    if text_369.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_369.frameNStart = frameN  # exact frame index
        text_369.tStart = t  # local t and not account for scr refresh
        text_369.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_369, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_369.started')
        text_369.setAutoDraw(True)
    if text_369.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_369.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_369.tStop = t  # not accounting for scr refresh
            text_369.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_369.stopped')
            text_369.setAutoDraw(False)
    
    # *text_370* updates
    if text_370.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_370.frameNStart = frameN  # exact frame index
        text_370.tStart = t  # local t and not account for scr refresh
        text_370.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_370, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_370.started')
        text_370.setAutoDraw(True)
    if text_370.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_370.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_370.tStop = t  # not accounting for scr refresh
            text_370.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_370.stopped')
            text_370.setAutoDraw(False)
    
    # *key_resp_74* updates
    waitOnFlip = False
    if key_resp_74.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_74.frameNStart = frameN  # exact frame index
        key_resp_74.tStart = t  # local t and not account for scr refresh
        key_resp_74.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_74, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_74.started')
        key_resp_74.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_74.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_74.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_74.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_74.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_74.tStop = t  # not accounting for scr refresh
            key_resp_74.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_74.stopped')
            key_resp_74.status = FINISHED
    if key_resp_74.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_74.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_74_allKeys.extend(theseKeys)
        if len(_key_resp_74_allKeys):
            key_resp_74.keys = _key_resp_74_allKeys[-1].name  # just the last key pressed
            key_resp_74.rt = _key_resp_74_allKeys[-1].rt
            # was this correct?
            if (key_resp_74.keys == str('y')) or (key_resp_74.keys == 'y'):
                key_resp_74.corr = 1
            else:
                key_resp_74.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jo_so_joComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jo_so_jo" ---
for thisComponent in jo_so_joComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_74.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_74.keys in ['', [], None]:  # No response was made
    key_resp_74.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_74.corr = 1;  # correct non-response
    else:
       key_resp_74.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_74.keys',key_resp_74.keys)
thisExp.addData('key_resp_74.corr', key_resp_74.corr)
if key_resp_74.keys != None:  # we had a response
    thisExp.addData('key_resp_74.rt', key_resp_74.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sojosojopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_51.setSound('mainpairs/sojosojopso.wav', secs=3.5, hamming=True)
sound_vowels_51.setVolume(1.0, log=False)
key_resp_51.keys = []
key_resp_51.rt = []
_key_resp_51_allKeys = []
# keep track of which components have finished
sojosojopsoComponents = [sound_vowels_51, text_251, text_252, text_253, text_254, text_255, key_resp_51]
for thisComponent in sojosojopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sojosojopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_51
    if sound_vowels_51.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_51.frameNStart = frameN  # exact frame index
        sound_vowels_51.tStart = t  # local t and not account for scr refresh
        sound_vowels_51.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_51.started', tThisFlipGlobal)
        sound_vowels_51.play(when=win)  # sync with win flip
    if sound_vowels_51.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_51.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_51.tStop = t  # not accounting for scr refresh
            sound_vowels_51.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_51.stopped')
            sound_vowels_51.stop()
    
    # *text_251* updates
    if text_251.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_251.frameNStart = frameN  # exact frame index
        text_251.tStart = t  # local t and not account for scr refresh
        text_251.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_251, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_251.started')
        text_251.setAutoDraw(True)
    if text_251.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_251.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_251.tStop = t  # not accounting for scr refresh
            text_251.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_251.stopped')
            text_251.setAutoDraw(False)
    
    # *text_252* updates
    if text_252.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_252.frameNStart = frameN  # exact frame index
        text_252.tStart = t  # local t and not account for scr refresh
        text_252.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_252, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_252.started')
        text_252.setAutoDraw(True)
    if text_252.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_252.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_252.tStop = t  # not accounting for scr refresh
            text_252.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_252.stopped')
            text_252.setAutoDraw(False)
    
    # *text_253* updates
    if text_253.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_253.frameNStart = frameN  # exact frame index
        text_253.tStart = t  # local t and not account for scr refresh
        text_253.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_253, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_253.started')
        text_253.setAutoDraw(True)
    if text_253.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_253.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_253.tStop = t  # not accounting for scr refresh
            text_253.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_253.stopped')
            text_253.setAutoDraw(False)
    
    # *text_254* updates
    if text_254.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_254.frameNStart = frameN  # exact frame index
        text_254.tStart = t  # local t and not account for scr refresh
        text_254.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_254, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_254.started')
        text_254.setAutoDraw(True)
    if text_254.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_254.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_254.tStop = t  # not accounting for scr refresh
            text_254.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_254.stopped')
            text_254.setAutoDraw(False)
    
    # *text_255* updates
    if text_255.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_255.frameNStart = frameN  # exact frame index
        text_255.tStart = t  # local t and not account for scr refresh
        text_255.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_255, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_255.started')
        text_255.setAutoDraw(True)
    if text_255.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_255.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_255.tStop = t  # not accounting for scr refresh
            text_255.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_255.stopped')
            text_255.setAutoDraw(False)
    
    # *key_resp_51* updates
    waitOnFlip = False
    if key_resp_51.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_51.frameNStart = frameN  # exact frame index
        key_resp_51.tStart = t  # local t and not account for scr refresh
        key_resp_51.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_51, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_51.started')
        key_resp_51.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_51.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_51.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_51.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_51.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_51.tStop = t  # not accounting for scr refresh
            key_resp_51.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_51.stopped')
            key_resp_51.status = FINISHED
    if key_resp_51.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_51.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_51_allKeys.extend(theseKeys)
        if len(_key_resp_51_allKeys):
            key_resp_51.keys = _key_resp_51_allKeys[-1].name  # just the last key pressed
            key_resp_51.rt = _key_resp_51_allKeys[-1].rt
            # was this correct?
            if (key_resp_51.keys == str('n')) or (key_resp_51.keys == 'n'):
                key_resp_51.corr = 1
            else:
                key_resp_51.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sojosojopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sojosojopso" ---
for thisComponent in sojosojopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_51.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_51.keys in ['', [], None]:  # No response was made
    key_resp_51.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_51.corr = 1;  # correct non-response
    else:
       key_resp_51.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_51.keys',key_resp_51.keys)
thisExp.addData('key_resp_51.corr', key_resp_51.corr)
if key_resp_51.keys != None:  # we had a response
    thisExp.addData('key_resp_51.rt', key_resp_51.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "josojopjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_49.setSound('mainpairs/josojopjo.wav', secs=3.5, hamming=True)
sound_vowels_49.setVolume(1.0, log=False)
key_resp_49.keys = []
key_resp_49.rt = []
_key_resp_49_allKeys = []
# keep track of which components have finished
josojopjoComponents = [sound_vowels_49, text_241, text_242, text_243, text_244, text_245, key_resp_49]
for thisComponent in josojopjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "josojopjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_49
    if sound_vowels_49.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_49.frameNStart = frameN  # exact frame index
        sound_vowels_49.tStart = t  # local t and not account for scr refresh
        sound_vowels_49.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_49.started', tThisFlipGlobal)
        sound_vowels_49.play(when=win)  # sync with win flip
    if sound_vowels_49.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_49.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_49.tStop = t  # not accounting for scr refresh
            sound_vowels_49.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_49.stopped')
            sound_vowels_49.stop()
    
    # *text_241* updates
    if text_241.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_241.frameNStart = frameN  # exact frame index
        text_241.tStart = t  # local t and not account for scr refresh
        text_241.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_241, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_241.started')
        text_241.setAutoDraw(True)
    if text_241.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_241.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_241.tStop = t  # not accounting for scr refresh
            text_241.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_241.stopped')
            text_241.setAutoDraw(False)
    
    # *text_242* updates
    if text_242.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_242.frameNStart = frameN  # exact frame index
        text_242.tStart = t  # local t and not account for scr refresh
        text_242.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_242, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_242.started')
        text_242.setAutoDraw(True)
    if text_242.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_242.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_242.tStop = t  # not accounting for scr refresh
            text_242.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_242.stopped')
            text_242.setAutoDraw(False)
    
    # *text_243* updates
    if text_243.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_243.frameNStart = frameN  # exact frame index
        text_243.tStart = t  # local t and not account for scr refresh
        text_243.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_243, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_243.started')
        text_243.setAutoDraw(True)
    if text_243.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_243.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_243.tStop = t  # not accounting for scr refresh
            text_243.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_243.stopped')
            text_243.setAutoDraw(False)
    
    # *text_244* updates
    if text_244.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_244.frameNStart = frameN  # exact frame index
        text_244.tStart = t  # local t and not account for scr refresh
        text_244.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_244, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_244.started')
        text_244.setAutoDraw(True)
    if text_244.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_244.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_244.tStop = t  # not accounting for scr refresh
            text_244.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_244.stopped')
            text_244.setAutoDraw(False)
    
    # *text_245* updates
    if text_245.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_245.frameNStart = frameN  # exact frame index
        text_245.tStart = t  # local t and not account for scr refresh
        text_245.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_245, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_245.started')
        text_245.setAutoDraw(True)
    if text_245.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_245.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_245.tStop = t  # not accounting for scr refresh
            text_245.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_245.stopped')
            text_245.setAutoDraw(False)
    
    # *key_resp_49* updates
    waitOnFlip = False
    if key_resp_49.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_49.frameNStart = frameN  # exact frame index
        key_resp_49.tStart = t  # local t and not account for scr refresh
        key_resp_49.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_49, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_49.started')
        key_resp_49.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_49.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_49.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_49.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_49.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_49.tStop = t  # not accounting for scr refresh
            key_resp_49.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_49.stopped')
            key_resp_49.status = FINISHED
    if key_resp_49.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_49.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_49_allKeys.extend(theseKeys)
        if len(_key_resp_49_allKeys):
            key_resp_49.keys = _key_resp_49_allKeys[-1].name  # just the last key pressed
            key_resp_49.rt = _key_resp_49_allKeys[-1].rt
            # was this correct?
            if (key_resp_49.keys == str('n')) or (key_resp_49.keys == 'n'):
                key_resp_49.corr = 1
            else:
                key_resp_49.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in josojopjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "josojopjo" ---
for thisComponent in josojopjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_49.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_49.keys in ['', [], None]:  # No response was made
    key_resp_49.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_49.corr = 1;  # correct non-response
    else:
       key_resp_49.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_49.keys',key_resp_49.keys)
thisExp.addData('key_resp_49.corr', key_resp_49.corr)
if key_resp_49.keys != None:  # we had a response
    thisExp.addData('key_resp_49.rt', key_resp_49.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "joAjoApjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_47.setSound('mainpairs/joAjoApjo.wav', secs=3.5, hamming=True)
sound_vowels_47.setVolume(1.0, log=False)
key_resp_47.keys = []
key_resp_47.rt = []
_key_resp_47_allKeys = []
# keep track of which components have finished
joAjoApjoComponents = [sound_vowels_47, text_231, text_232, text_233, text_234, text_235, key_resp_47]
for thisComponent in joAjoApjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "joAjoApjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_47
    if sound_vowels_47.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_47.frameNStart = frameN  # exact frame index
        sound_vowels_47.tStart = t  # local t and not account for scr refresh
        sound_vowels_47.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_47.started', tThisFlipGlobal)
        sound_vowels_47.play(when=win)  # sync with win flip
    if sound_vowels_47.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_47.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_47.tStop = t  # not accounting for scr refresh
            sound_vowels_47.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_47.stopped')
            sound_vowels_47.stop()
    
    # *text_231* updates
    if text_231.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_231.frameNStart = frameN  # exact frame index
        text_231.tStart = t  # local t and not account for scr refresh
        text_231.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_231, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_231.started')
        text_231.setAutoDraw(True)
    if text_231.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_231.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_231.tStop = t  # not accounting for scr refresh
            text_231.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_231.stopped')
            text_231.setAutoDraw(False)
    
    # *text_232* updates
    if text_232.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_232.frameNStart = frameN  # exact frame index
        text_232.tStart = t  # local t and not account for scr refresh
        text_232.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_232, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_232.started')
        text_232.setAutoDraw(True)
    if text_232.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_232.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_232.tStop = t  # not accounting for scr refresh
            text_232.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_232.stopped')
            text_232.setAutoDraw(False)
    
    # *text_233* updates
    if text_233.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_233.frameNStart = frameN  # exact frame index
        text_233.tStart = t  # local t and not account for scr refresh
        text_233.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_233, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_233.started')
        text_233.setAutoDraw(True)
    if text_233.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_233.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_233.tStop = t  # not accounting for scr refresh
            text_233.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_233.stopped')
            text_233.setAutoDraw(False)
    
    # *text_234* updates
    if text_234.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_234.frameNStart = frameN  # exact frame index
        text_234.tStart = t  # local t and not account for scr refresh
        text_234.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_234, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_234.started')
        text_234.setAutoDraw(True)
    if text_234.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_234.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_234.tStop = t  # not accounting for scr refresh
            text_234.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_234.stopped')
            text_234.setAutoDraw(False)
    
    # *text_235* updates
    if text_235.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_235.frameNStart = frameN  # exact frame index
        text_235.tStart = t  # local t and not account for scr refresh
        text_235.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_235, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_235.started')
        text_235.setAutoDraw(True)
    if text_235.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_235.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_235.tStop = t  # not accounting for scr refresh
            text_235.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_235.stopped')
            text_235.setAutoDraw(False)
    
    # *key_resp_47* updates
    waitOnFlip = False
    if key_resp_47.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_47.frameNStart = frameN  # exact frame index
        key_resp_47.tStart = t  # local t and not account for scr refresh
        key_resp_47.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_47, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_47.started')
        key_resp_47.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_47.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_47.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_47.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_47.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_47.tStop = t  # not accounting for scr refresh
            key_resp_47.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_47.stopped')
            key_resp_47.status = FINISHED
    if key_resp_47.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_47.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_47_allKeys.extend(theseKeys)
        if len(_key_resp_47_allKeys):
            key_resp_47.keys = _key_resp_47_allKeys[-1].name  # just the last key pressed
            key_resp_47.rt = _key_resp_47_allKeys[-1].rt
            # was this correct?
            if (key_resp_47.keys == str('n')) or (key_resp_47.keys == 'n'):
                key_resp_47.corr = 1
            else:
                key_resp_47.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in joAjoApjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "joAjoApjo" ---
for thisComponent in joAjoApjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_47.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_47.keys in ['', [], None]:  # No response was made
    key_resp_47.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_47.corr = 1;  # correct non-response
    else:
       key_resp_47.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_47.keys',key_resp_47.keys)
thisExp.addData('key_resp_47.corr', key_resp_47.corr)
if key_resp_47.keys != None:  # we had a response
    thisExp.addData('key_resp_47.rt', key_resp_47.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "so_jo_jo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_80.setSound('mainpairs/so.jo+jo.wav', secs=3.5, hamming=True)
sound_vowels_80.setVolume(1.0, log=False)
key_resp_80.keys = []
key_resp_80.rt = []
_key_resp_80_allKeys = []
# keep track of which components have finished
so_jo_joComponents = [sound_vowels_80, text_396, text_397, text_398, text_399, text_400, key_resp_80]
for thisComponent in so_jo_joComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "so_jo_jo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_80
    if sound_vowels_80.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_80.frameNStart = frameN  # exact frame index
        sound_vowels_80.tStart = t  # local t and not account for scr refresh
        sound_vowels_80.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_80.started', tThisFlipGlobal)
        sound_vowels_80.play(when=win)  # sync with win flip
    if sound_vowels_80.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_80.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_80.tStop = t  # not accounting for scr refresh
            sound_vowels_80.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_80.stopped')
            sound_vowels_80.stop()
    
    # *text_396* updates
    if text_396.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_396.frameNStart = frameN  # exact frame index
        text_396.tStart = t  # local t and not account for scr refresh
        text_396.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_396, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_396.started')
        text_396.setAutoDraw(True)
    if text_396.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_396.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_396.tStop = t  # not accounting for scr refresh
            text_396.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_396.stopped')
            text_396.setAutoDraw(False)
    
    # *text_397* updates
    if text_397.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_397.frameNStart = frameN  # exact frame index
        text_397.tStart = t  # local t and not account for scr refresh
        text_397.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_397, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_397.started')
        text_397.setAutoDraw(True)
    if text_397.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_397.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_397.tStop = t  # not accounting for scr refresh
            text_397.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_397.stopped')
            text_397.setAutoDraw(False)
    
    # *text_398* updates
    if text_398.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_398.frameNStart = frameN  # exact frame index
        text_398.tStart = t  # local t and not account for scr refresh
        text_398.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_398, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_398.started')
        text_398.setAutoDraw(True)
    if text_398.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_398.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_398.tStop = t  # not accounting for scr refresh
            text_398.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_398.stopped')
            text_398.setAutoDraw(False)
    
    # *text_399* updates
    if text_399.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_399.frameNStart = frameN  # exact frame index
        text_399.tStart = t  # local t and not account for scr refresh
        text_399.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_399, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_399.started')
        text_399.setAutoDraw(True)
    if text_399.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_399.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_399.tStop = t  # not accounting for scr refresh
            text_399.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_399.stopped')
            text_399.setAutoDraw(False)
    
    # *text_400* updates
    if text_400.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_400.frameNStart = frameN  # exact frame index
        text_400.tStart = t  # local t and not account for scr refresh
        text_400.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_400, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_400.started')
        text_400.setAutoDraw(True)
    if text_400.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_400.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_400.tStop = t  # not accounting for scr refresh
            text_400.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_400.stopped')
            text_400.setAutoDraw(False)
    
    # *key_resp_80* updates
    waitOnFlip = False
    if key_resp_80.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_80.frameNStart = frameN  # exact frame index
        key_resp_80.tStart = t  # local t and not account for scr refresh
        key_resp_80.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_80, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_80.started')
        key_resp_80.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_80.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_80.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_80.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_80.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_80.tStop = t  # not accounting for scr refresh
            key_resp_80.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_80.stopped')
            key_resp_80.status = FINISHED
    if key_resp_80.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_80.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_80_allKeys.extend(theseKeys)
        if len(_key_resp_80_allKeys):
            key_resp_80.keys = _key_resp_80_allKeys[-1].name  # just the last key pressed
            key_resp_80.rt = _key_resp_80_allKeys[-1].rt
            # was this correct?
            if (key_resp_80.keys == str('y')) or (key_resp_80.keys == 'y'):
                key_resp_80.corr = 1
            else:
                key_resp_80.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in so_jo_joComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "so_jo_jo" ---
for thisComponent in so_jo_joComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_80.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_80.keys in ['', [], None]:  # No response was made
    key_resp_80.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_80.corr = 1;  # correct non-response
    else:
       key_resp_80.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_80.keys',key_resp_80.keys)
thisExp.addData('key_resp_80.corr', key_resp_80.corr)
if key_resp_80.keys != None:  # we had a response
    thisExp.addData('key_resp_80.rt', key_resp_80.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sousopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_46.setSound('mainpairs/sousopso.wav', secs=3.5, hamming=True)
sound_vowels_46.setVolume(1.0, log=False)
key_resp_46.keys = []
key_resp_46.rt = []
_key_resp_46_allKeys = []
# keep track of which components have finished
sousopsoComponents = [sound_vowels_46, text_226, text_227, text_228, text_229, text_230, key_resp_46]
for thisComponent in sousopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sousopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_46
    if sound_vowels_46.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_46.frameNStart = frameN  # exact frame index
        sound_vowels_46.tStart = t  # local t and not account for scr refresh
        sound_vowels_46.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_46.started', tThisFlipGlobal)
        sound_vowels_46.play(when=win)  # sync with win flip
    if sound_vowels_46.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_46.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_46.tStop = t  # not accounting for scr refresh
            sound_vowels_46.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_46.stopped')
            sound_vowels_46.stop()
    
    # *text_226* updates
    if text_226.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_226.frameNStart = frameN  # exact frame index
        text_226.tStart = t  # local t and not account for scr refresh
        text_226.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_226, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_226.started')
        text_226.setAutoDraw(True)
    if text_226.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_226.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_226.tStop = t  # not accounting for scr refresh
            text_226.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_226.stopped')
            text_226.setAutoDraw(False)
    
    # *text_227* updates
    if text_227.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_227.frameNStart = frameN  # exact frame index
        text_227.tStart = t  # local t and not account for scr refresh
        text_227.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_227, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_227.started')
        text_227.setAutoDraw(True)
    if text_227.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_227.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_227.tStop = t  # not accounting for scr refresh
            text_227.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_227.stopped')
            text_227.setAutoDraw(False)
    
    # *text_228* updates
    if text_228.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_228.frameNStart = frameN  # exact frame index
        text_228.tStart = t  # local t and not account for scr refresh
        text_228.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_228, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_228.started')
        text_228.setAutoDraw(True)
    if text_228.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_228.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_228.tStop = t  # not accounting for scr refresh
            text_228.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_228.stopped')
            text_228.setAutoDraw(False)
    
    # *text_229* updates
    if text_229.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_229.frameNStart = frameN  # exact frame index
        text_229.tStart = t  # local t and not account for scr refresh
        text_229.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_229, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_229.started')
        text_229.setAutoDraw(True)
    if text_229.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_229.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_229.tStop = t  # not accounting for scr refresh
            text_229.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_229.stopped')
            text_229.setAutoDraw(False)
    
    # *text_230* updates
    if text_230.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_230.frameNStart = frameN  # exact frame index
        text_230.tStart = t  # local t and not account for scr refresh
        text_230.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_230, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_230.started')
        text_230.setAutoDraw(True)
    if text_230.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_230.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_230.tStop = t  # not accounting for scr refresh
            text_230.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_230.stopped')
            text_230.setAutoDraw(False)
    
    # *key_resp_46* updates
    waitOnFlip = False
    if key_resp_46.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_46.frameNStart = frameN  # exact frame index
        key_resp_46.tStart = t  # local t and not account for scr refresh
        key_resp_46.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_46, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_46.started')
        key_resp_46.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_46.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_46.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_46.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_46.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_46.tStop = t  # not accounting for scr refresh
            key_resp_46.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_46.stopped')
            key_resp_46.status = FINISHED
    if key_resp_46.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_46.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_46_allKeys.extend(theseKeys)
        if len(_key_resp_46_allKeys):
            key_resp_46.keys = _key_resp_46_allKeys[-1].name  # just the last key pressed
            key_resp_46.rt = _key_resp_46_allKeys[-1].rt
            # was this correct?
            if (key_resp_46.keys == str('n')) or (key_resp_46.keys == 'n'):
                key_resp_46.corr = 1
            else:
                key_resp_46.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sousopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sousopso" ---
for thisComponent in sousopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_46.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_46.keys in ['', [], None]:  # No response was made
    key_resp_46.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_46.corr = 1;  # correct non-response
    else:
       key_resp_46.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_46.keys',key_resp_46.keys)
thisExp.addData('key_resp_46.corr', key_resp_46.corr)
if key_resp_46.keys != None:  # we had a response
    thisExp.addData('key_resp_46.rt', key_resp_46.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_sa_ja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_79.setSound('mainpairs/sa+sa.ja.wav', secs=3.5, hamming=True)
sound_vowels_79.setVolume(1.0, log=False)
key_resp_79.keys = []
key_resp_79.rt = []
_key_resp_79_allKeys = []
# keep track of which components have finished
sa_sa_jaComponents = [sound_vowels_79, text_391, text_392, text_393, text_394, text_395, key_resp_79]
for thisComponent in sa_sa_jaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_sa_ja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_79
    if sound_vowels_79.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_79.frameNStart = frameN  # exact frame index
        sound_vowels_79.tStart = t  # local t and not account for scr refresh
        sound_vowels_79.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_79.started', tThisFlipGlobal)
        sound_vowels_79.play(when=win)  # sync with win flip
    if sound_vowels_79.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_79.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_79.tStop = t  # not accounting for scr refresh
            sound_vowels_79.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_79.stopped')
            sound_vowels_79.stop()
    
    # *text_391* updates
    if text_391.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_391.frameNStart = frameN  # exact frame index
        text_391.tStart = t  # local t and not account for scr refresh
        text_391.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_391, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_391.started')
        text_391.setAutoDraw(True)
    if text_391.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_391.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_391.tStop = t  # not accounting for scr refresh
            text_391.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_391.stopped')
            text_391.setAutoDraw(False)
    
    # *text_392* updates
    if text_392.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_392.frameNStart = frameN  # exact frame index
        text_392.tStart = t  # local t and not account for scr refresh
        text_392.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_392, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_392.started')
        text_392.setAutoDraw(True)
    if text_392.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_392.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_392.tStop = t  # not accounting for scr refresh
            text_392.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_392.stopped')
            text_392.setAutoDraw(False)
    
    # *text_393* updates
    if text_393.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_393.frameNStart = frameN  # exact frame index
        text_393.tStart = t  # local t and not account for scr refresh
        text_393.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_393, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_393.started')
        text_393.setAutoDraw(True)
    if text_393.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_393.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_393.tStop = t  # not accounting for scr refresh
            text_393.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_393.stopped')
            text_393.setAutoDraw(False)
    
    # *text_394* updates
    if text_394.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_394.frameNStart = frameN  # exact frame index
        text_394.tStart = t  # local t and not account for scr refresh
        text_394.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_394, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_394.started')
        text_394.setAutoDraw(True)
    if text_394.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_394.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_394.tStop = t  # not accounting for scr refresh
            text_394.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_394.stopped')
            text_394.setAutoDraw(False)
    
    # *text_395* updates
    if text_395.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_395.frameNStart = frameN  # exact frame index
        text_395.tStart = t  # local t and not account for scr refresh
        text_395.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_395, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_395.started')
        text_395.setAutoDraw(True)
    if text_395.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_395.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_395.tStop = t  # not accounting for scr refresh
            text_395.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_395.stopped')
            text_395.setAutoDraw(False)
    
    # *key_resp_79* updates
    waitOnFlip = False
    if key_resp_79.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_79.frameNStart = frameN  # exact frame index
        key_resp_79.tStart = t  # local t and not account for scr refresh
        key_resp_79.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_79, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_79.started')
        key_resp_79.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_79.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_79.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_79.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_79.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_79.tStop = t  # not accounting for scr refresh
            key_resp_79.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_79.stopped')
            key_resp_79.status = FINISHED
    if key_resp_79.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_79.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_79_allKeys.extend(theseKeys)
        if len(_key_resp_79_allKeys):
            key_resp_79.keys = _key_resp_79_allKeys[-1].name  # just the last key pressed
            key_resp_79.rt = _key_resp_79_allKeys[-1].rt
            # was this correct?
            if (key_resp_79.keys == str('y')) or (key_resp_79.keys == 'y'):
                key_resp_79.corr = 1
            else:
                key_resp_79.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_sa_jaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_sa_ja" ---
for thisComponent in sa_sa_jaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_79.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_79.keys in ['', [], None]:  # No response was made
    key_resp_79.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_79.corr = 1;  # correct non-response
    else:
       key_resp_79.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_79.keys',key_resp_79.keys)
thisExp.addData('key_resp_79.corr', key_resp_79.corr)
if key_resp_79.keys != None:  # we had a response
    thisExp.addData('key_resp_79.rt', key_resp_79.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "joAjopjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_42.setSound('mainpairs/joAjopjo.wav', secs=3.5, hamming=True)
sound_vowels_42.setVolume(1.0, log=False)
key_resp_42.keys = []
key_resp_42.rt = []
_key_resp_42_allKeys = []
# keep track of which components have finished
joAjopjoComponents = [sound_vowels_42, text_206, text_207, text_208, text_209, text_210, key_resp_42]
for thisComponent in joAjopjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "joAjopjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_42
    if sound_vowels_42.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_42.frameNStart = frameN  # exact frame index
        sound_vowels_42.tStart = t  # local t and not account for scr refresh
        sound_vowels_42.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_42.started', tThisFlipGlobal)
        sound_vowels_42.play(when=win)  # sync with win flip
    if sound_vowels_42.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_42.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_42.tStop = t  # not accounting for scr refresh
            sound_vowels_42.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_42.stopped')
            sound_vowels_42.stop()
    
    # *text_206* updates
    if text_206.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_206.frameNStart = frameN  # exact frame index
        text_206.tStart = t  # local t and not account for scr refresh
        text_206.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_206, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_206.started')
        text_206.setAutoDraw(True)
    if text_206.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_206.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_206.tStop = t  # not accounting for scr refresh
            text_206.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_206.stopped')
            text_206.setAutoDraw(False)
    
    # *text_207* updates
    if text_207.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_207.frameNStart = frameN  # exact frame index
        text_207.tStart = t  # local t and not account for scr refresh
        text_207.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_207, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_207.started')
        text_207.setAutoDraw(True)
    if text_207.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_207.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_207.tStop = t  # not accounting for scr refresh
            text_207.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_207.stopped')
            text_207.setAutoDraw(False)
    
    # *text_208* updates
    if text_208.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_208.frameNStart = frameN  # exact frame index
        text_208.tStart = t  # local t and not account for scr refresh
        text_208.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_208, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_208.started')
        text_208.setAutoDraw(True)
    if text_208.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_208.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_208.tStop = t  # not accounting for scr refresh
            text_208.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_208.stopped')
            text_208.setAutoDraw(False)
    
    # *text_209* updates
    if text_209.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_209.frameNStart = frameN  # exact frame index
        text_209.tStart = t  # local t and not account for scr refresh
        text_209.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_209, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_209.started')
        text_209.setAutoDraw(True)
    if text_209.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_209.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_209.tStop = t  # not accounting for scr refresh
            text_209.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_209.stopped')
            text_209.setAutoDraw(False)
    
    # *text_210* updates
    if text_210.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_210.frameNStart = frameN  # exact frame index
        text_210.tStart = t  # local t and not account for scr refresh
        text_210.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_210, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_210.started')
        text_210.setAutoDraw(True)
    if text_210.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_210.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_210.tStop = t  # not accounting for scr refresh
            text_210.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_210.stopped')
            text_210.setAutoDraw(False)
    
    # *key_resp_42* updates
    waitOnFlip = False
    if key_resp_42.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_42.frameNStart = frameN  # exact frame index
        key_resp_42.tStart = t  # local t and not account for scr refresh
        key_resp_42.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_42, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_42.started')
        key_resp_42.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_42.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_42.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_42.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_42.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_42.tStop = t  # not accounting for scr refresh
            key_resp_42.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_42.stopped')
            key_resp_42.status = FINISHED
    if key_resp_42.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_42.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_42_allKeys.extend(theseKeys)
        if len(_key_resp_42_allKeys):
            key_resp_42.keys = _key_resp_42_allKeys[-1].name  # just the last key pressed
            key_resp_42.rt = _key_resp_42_allKeys[-1].rt
            # was this correct?
            if (key_resp_42.keys == str('n')) or (key_resp_42.keys == 'n'):
                key_resp_42.corr = 1
            else:
                key_resp_42.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in joAjopjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "joAjopjo" ---
for thisComponent in joAjopjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_42.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_42.keys in ['', [], None]:  # No response was made
    key_resp_42.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_42.corr = 1;  # correct non-response
    else:
       key_resp_42.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_42.keys',key_resp_42.keys)
thisExp.addData('key_resp_42.corr', key_resp_42.corr)
if key_resp_42.keys != None:  # we had a response
    thisExp.addData('key_resp_42.rt', key_resp_42.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_sa_japsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_60.setSound('mainpairs/sa+sa.japsa.wav', secs=3.5, hamming=True)
sound_vowels_60.setVolume(1.0, log=False)
key_resp_60.keys = []
key_resp_60.rt = []
_key_resp_60_allKeys = []
# keep track of which components have finished
sa_sa_japsaComponents = [sound_vowels_60, text_296, text_297, text_298, text_299, text_300, key_resp_60]
for thisComponent in sa_sa_japsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_sa_japsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_60
    if sound_vowels_60.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_60.frameNStart = frameN  # exact frame index
        sound_vowels_60.tStart = t  # local t and not account for scr refresh
        sound_vowels_60.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_60.started', tThisFlipGlobal)
        sound_vowels_60.play(when=win)  # sync with win flip
    if sound_vowels_60.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_60.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_60.tStop = t  # not accounting for scr refresh
            sound_vowels_60.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_60.stopped')
            sound_vowels_60.stop()
    
    # *text_296* updates
    if text_296.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_296.frameNStart = frameN  # exact frame index
        text_296.tStart = t  # local t and not account for scr refresh
        text_296.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_296, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_296.started')
        text_296.setAutoDraw(True)
    if text_296.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_296.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_296.tStop = t  # not accounting for scr refresh
            text_296.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_296.stopped')
            text_296.setAutoDraw(False)
    
    # *text_297* updates
    if text_297.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_297.frameNStart = frameN  # exact frame index
        text_297.tStart = t  # local t and not account for scr refresh
        text_297.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_297, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_297.started')
        text_297.setAutoDraw(True)
    if text_297.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_297.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_297.tStop = t  # not accounting for scr refresh
            text_297.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_297.stopped')
            text_297.setAutoDraw(False)
    
    # *text_298* updates
    if text_298.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_298.frameNStart = frameN  # exact frame index
        text_298.tStart = t  # local t and not account for scr refresh
        text_298.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_298, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_298.started')
        text_298.setAutoDraw(True)
    if text_298.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_298.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_298.tStop = t  # not accounting for scr refresh
            text_298.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_298.stopped')
            text_298.setAutoDraw(False)
    
    # *text_299* updates
    if text_299.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_299.frameNStart = frameN  # exact frame index
        text_299.tStart = t  # local t and not account for scr refresh
        text_299.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_299, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_299.started')
        text_299.setAutoDraw(True)
    if text_299.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_299.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_299.tStop = t  # not accounting for scr refresh
            text_299.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_299.stopped')
            text_299.setAutoDraw(False)
    
    # *text_300* updates
    if text_300.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_300.frameNStart = frameN  # exact frame index
        text_300.tStart = t  # local t and not account for scr refresh
        text_300.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_300, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_300.started')
        text_300.setAutoDraw(True)
    if text_300.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_300.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_300.tStop = t  # not accounting for scr refresh
            text_300.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_300.stopped')
            text_300.setAutoDraw(False)
    
    # *key_resp_60* updates
    waitOnFlip = False
    if key_resp_60.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_60.frameNStart = frameN  # exact frame index
        key_resp_60.tStart = t  # local t and not account for scr refresh
        key_resp_60.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_60, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_60.started')
        key_resp_60.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_60.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_60.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_60.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_60.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_60.tStop = t  # not accounting for scr refresh
            key_resp_60.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_60.stopped')
            key_resp_60.status = FINISHED
    if key_resp_60.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_60.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_60_allKeys.extend(theseKeys)
        if len(_key_resp_60_allKeys):
            key_resp_60.keys = _key_resp_60_allKeys[-1].name  # just the last key pressed
            key_resp_60.rt = _key_resp_60_allKeys[-1].rt
            # was this correct?
            if (key_resp_60.keys == str('n')) or (key_resp_60.keys == 'n'):
                key_resp_60.corr = 1
            else:
                key_resp_60.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_sa_japsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_sa_japsa" ---
for thisComponent in sa_sa_japsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_60.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_60.keys in ['', [], None]:  # No response was made
    key_resp_60.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_60.corr = 1;  # correct non-response
    else:
       key_resp_60.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_60.keys',key_resp_60.keys)
thisExp.addData('key_resp_60.corr', key_resp_60.corr)
if key_resp_60.keys != None:  # we had a response
    thisExp.addData('key_resp_60.rt', key_resp_60.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jo_A_jo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_72.setSound('mainpairs/jo.A+jo.wav', secs=3.5, hamming=True)
sound_vowels_72.setVolume(1.0, log=False)
key_resp_72.keys = []
key_resp_72.rt = []
_key_resp_72_allKeys = []
# keep track of which components have finished
jo_A_joComponents = [sound_vowels_72, text_356, text_357, text_358, text_359, text_360, key_resp_72]
for thisComponent in jo_A_joComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jo_A_jo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_72
    if sound_vowels_72.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_72.frameNStart = frameN  # exact frame index
        sound_vowels_72.tStart = t  # local t and not account for scr refresh
        sound_vowels_72.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_72.started', tThisFlipGlobal)
        sound_vowels_72.play(when=win)  # sync with win flip
    if sound_vowels_72.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_72.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_72.tStop = t  # not accounting for scr refresh
            sound_vowels_72.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_72.stopped')
            sound_vowels_72.stop()
    
    # *text_356* updates
    if text_356.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_356.frameNStart = frameN  # exact frame index
        text_356.tStart = t  # local t and not account for scr refresh
        text_356.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_356, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_356.started')
        text_356.setAutoDraw(True)
    if text_356.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_356.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_356.tStop = t  # not accounting for scr refresh
            text_356.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_356.stopped')
            text_356.setAutoDraw(False)
    
    # *text_357* updates
    if text_357.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_357.frameNStart = frameN  # exact frame index
        text_357.tStart = t  # local t and not account for scr refresh
        text_357.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_357, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_357.started')
        text_357.setAutoDraw(True)
    if text_357.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_357.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_357.tStop = t  # not accounting for scr refresh
            text_357.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_357.stopped')
            text_357.setAutoDraw(False)
    
    # *text_358* updates
    if text_358.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_358.frameNStart = frameN  # exact frame index
        text_358.tStart = t  # local t and not account for scr refresh
        text_358.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_358, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_358.started')
        text_358.setAutoDraw(True)
    if text_358.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_358.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_358.tStop = t  # not accounting for scr refresh
            text_358.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_358.stopped')
            text_358.setAutoDraw(False)
    
    # *text_359* updates
    if text_359.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_359.frameNStart = frameN  # exact frame index
        text_359.tStart = t  # local t and not account for scr refresh
        text_359.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_359, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_359.started')
        text_359.setAutoDraw(True)
    if text_359.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_359.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_359.tStop = t  # not accounting for scr refresh
            text_359.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_359.stopped')
            text_359.setAutoDraw(False)
    
    # *text_360* updates
    if text_360.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_360.frameNStart = frameN  # exact frame index
        text_360.tStart = t  # local t and not account for scr refresh
        text_360.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_360, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_360.started')
        text_360.setAutoDraw(True)
    if text_360.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_360.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_360.tStop = t  # not accounting for scr refresh
            text_360.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_360.stopped')
            text_360.setAutoDraw(False)
    
    # *key_resp_72* updates
    waitOnFlip = False
    if key_resp_72.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_72.frameNStart = frameN  # exact frame index
        key_resp_72.tStart = t  # local t and not account for scr refresh
        key_resp_72.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_72, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_72.started')
        key_resp_72.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_72.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_72.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_72.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_72.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_72.tStop = t  # not accounting for scr refresh
            key_resp_72.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_72.stopped')
            key_resp_72.status = FINISHED
    if key_resp_72.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_72.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_72_allKeys.extend(theseKeys)
        if len(_key_resp_72_allKeys):
            key_resp_72.keys = _key_resp_72_allKeys[-1].name  # just the last key pressed
            key_resp_72.rt = _key_resp_72_allKeys[-1].rt
            # was this correct?
            if (key_resp_72.keys == str('y')) or (key_resp_72.keys == 'y'):
                key_resp_72.corr = 1
            else:
                key_resp_72.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jo_A_joComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jo_A_jo" ---
for thisComponent in jo_A_joComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_72.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_72.keys in ['', [], None]:  # No response was made
    key_resp_72.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_72.corr = 1;  # correct non-response
    else:
       key_resp_72.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_72.keys',key_resp_72.keys)
thisExp.addData('key_resp_72.corr', key_resp_72.corr)
if key_resp_72.keys != None:  # we had a response
    thisExp.addData('key_resp_72.rt', key_resp_72.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sojosopjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_53.setSound('mainpairs/sojosopjo.wav', secs=3.5, hamming=True)
sound_vowels_53.setVolume(1.0, log=False)
key_resp_53.keys = []
key_resp_53.rt = []
_key_resp_53_allKeys = []
# keep track of which components have finished
sojosopjoComponents = [sound_vowels_53, text_261, text_262, text_263, text_264, text_265, key_resp_53]
for thisComponent in sojosopjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sojosopjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_53
    if sound_vowels_53.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_53.frameNStart = frameN  # exact frame index
        sound_vowels_53.tStart = t  # local t and not account for scr refresh
        sound_vowels_53.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_53.started', tThisFlipGlobal)
        sound_vowels_53.play(when=win)  # sync with win flip
    if sound_vowels_53.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_53.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_53.tStop = t  # not accounting for scr refresh
            sound_vowels_53.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_53.stopped')
            sound_vowels_53.stop()
    
    # *text_261* updates
    if text_261.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_261.frameNStart = frameN  # exact frame index
        text_261.tStart = t  # local t and not account for scr refresh
        text_261.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_261, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_261.started')
        text_261.setAutoDraw(True)
    if text_261.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_261.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_261.tStop = t  # not accounting for scr refresh
            text_261.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_261.stopped')
            text_261.setAutoDraw(False)
    
    # *text_262* updates
    if text_262.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_262.frameNStart = frameN  # exact frame index
        text_262.tStart = t  # local t and not account for scr refresh
        text_262.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_262, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_262.started')
        text_262.setAutoDraw(True)
    if text_262.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_262.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_262.tStop = t  # not accounting for scr refresh
            text_262.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_262.stopped')
            text_262.setAutoDraw(False)
    
    # *text_263* updates
    if text_263.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_263.frameNStart = frameN  # exact frame index
        text_263.tStart = t  # local t and not account for scr refresh
        text_263.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_263, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_263.started')
        text_263.setAutoDraw(True)
    if text_263.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_263.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_263.tStop = t  # not accounting for scr refresh
            text_263.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_263.stopped')
            text_263.setAutoDraw(False)
    
    # *text_264* updates
    if text_264.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_264.frameNStart = frameN  # exact frame index
        text_264.tStart = t  # local t and not account for scr refresh
        text_264.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_264, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_264.started')
        text_264.setAutoDraw(True)
    if text_264.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_264.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_264.tStop = t  # not accounting for scr refresh
            text_264.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_264.stopped')
            text_264.setAutoDraw(False)
    
    # *text_265* updates
    if text_265.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_265.frameNStart = frameN  # exact frame index
        text_265.tStart = t  # local t and not account for scr refresh
        text_265.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_265, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_265.started')
        text_265.setAutoDraw(True)
    if text_265.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_265.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_265.tStop = t  # not accounting for scr refresh
            text_265.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_265.stopped')
            text_265.setAutoDraw(False)
    
    # *key_resp_53* updates
    waitOnFlip = False
    if key_resp_53.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_53.frameNStart = frameN  # exact frame index
        key_resp_53.tStart = t  # local t and not account for scr refresh
        key_resp_53.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_53, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_53.started')
        key_resp_53.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_53.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_53.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_53.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_53.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_53.tStop = t  # not accounting for scr refresh
            key_resp_53.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_53.stopped')
            key_resp_53.status = FINISHED
    if key_resp_53.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_53.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_53_allKeys.extend(theseKeys)
        if len(_key_resp_53_allKeys):
            key_resp_53.keys = _key_resp_53_allKeys[-1].name  # just the last key pressed
            key_resp_53.rt = _key_resp_53_allKeys[-1].rt
            # was this correct?
            if (key_resp_53.keys == str('n')) or (key_resp_53.keys == 'n'):
                key_resp_53.corr = 1
            else:
                key_resp_53.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sojosopjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sojosopjo" ---
for thisComponent in sojosopjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_53.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_53.keys in ['', [], None]:  # No response was made
    key_resp_53.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_53.corr = 1;  # correct non-response
    else:
       key_resp_53.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_53.keys',key_resp_53.keys)
thisExp.addData('key_resp_53.corr', key_resp_53.corr)
if key_resp_53.keys != None:  # we had a response
    thisExp.addData('key_resp_53.rt', key_resp_53.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_japja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_62.setSound('mainpairs/sa.ja+japja.wav', secs=3.5, hamming=True)
sound_vowels_62.setVolume(1.0, log=False)
key_resp_62.keys = []
key_resp_62.rt = []
_key_resp_62_allKeys = []
# keep track of which components have finished
sa_ja_japjaComponents = [sound_vowels_62, text_306, text_307, text_308, text_309, text_310, key_resp_62]
for thisComponent in sa_ja_japjaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_japja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_62
    if sound_vowels_62.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_62.frameNStart = frameN  # exact frame index
        sound_vowels_62.tStart = t  # local t and not account for scr refresh
        sound_vowels_62.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_62.started', tThisFlipGlobal)
        sound_vowels_62.play(when=win)  # sync with win flip
    if sound_vowels_62.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_62.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_62.tStop = t  # not accounting for scr refresh
            sound_vowels_62.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_62.stopped')
            sound_vowels_62.stop()
    
    # *text_306* updates
    if text_306.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_306.frameNStart = frameN  # exact frame index
        text_306.tStart = t  # local t and not account for scr refresh
        text_306.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_306, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_306.started')
        text_306.setAutoDraw(True)
    if text_306.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_306.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_306.tStop = t  # not accounting for scr refresh
            text_306.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_306.stopped')
            text_306.setAutoDraw(False)
    
    # *text_307* updates
    if text_307.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_307.frameNStart = frameN  # exact frame index
        text_307.tStart = t  # local t and not account for scr refresh
        text_307.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_307, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_307.started')
        text_307.setAutoDraw(True)
    if text_307.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_307.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_307.tStop = t  # not accounting for scr refresh
            text_307.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_307.stopped')
            text_307.setAutoDraw(False)
    
    # *text_308* updates
    if text_308.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_308.frameNStart = frameN  # exact frame index
        text_308.tStart = t  # local t and not account for scr refresh
        text_308.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_308, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_308.started')
        text_308.setAutoDraw(True)
    if text_308.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_308.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_308.tStop = t  # not accounting for scr refresh
            text_308.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_308.stopped')
            text_308.setAutoDraw(False)
    
    # *text_309* updates
    if text_309.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_309.frameNStart = frameN  # exact frame index
        text_309.tStart = t  # local t and not account for scr refresh
        text_309.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_309, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_309.started')
        text_309.setAutoDraw(True)
    if text_309.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_309.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_309.tStop = t  # not accounting for scr refresh
            text_309.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_309.stopped')
            text_309.setAutoDraw(False)
    
    # *text_310* updates
    if text_310.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_310.frameNStart = frameN  # exact frame index
        text_310.tStart = t  # local t and not account for scr refresh
        text_310.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_310, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_310.started')
        text_310.setAutoDraw(True)
    if text_310.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_310.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_310.tStop = t  # not accounting for scr refresh
            text_310.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_310.stopped')
            text_310.setAutoDraw(False)
    
    # *key_resp_62* updates
    waitOnFlip = False
    if key_resp_62.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_62.frameNStart = frameN  # exact frame index
        key_resp_62.tStart = t  # local t and not account for scr refresh
        key_resp_62.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_62, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_62.started')
        key_resp_62.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_62.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_62.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_62.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_62.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_62.tStop = t  # not accounting for scr refresh
            key_resp_62.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_62.stopped')
            key_resp_62.status = FINISHED
    if key_resp_62.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_62.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_62_allKeys.extend(theseKeys)
        if len(_key_resp_62_allKeys):
            key_resp_62.keys = _key_resp_62_allKeys[-1].name  # just the last key pressed
            key_resp_62.rt = _key_resp_62_allKeys[-1].rt
            # was this correct?
            if (key_resp_62.keys == str('n')) or (key_resp_62.keys == 'n'):
                key_resp_62.corr = 1
            else:
                key_resp_62.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_japjaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_japja" ---
for thisComponent in sa_ja_japjaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_62.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_62.keys in ['', [], None]:  # No response was made
    key_resp_62.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_62.corr = 1;  # correct non-response
    else:
       key_resp_62.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_62.keys',key_resp_62.keys)
thisExp.addData('key_resp_62.corr', key_resp_62.corr)
if key_resp_62.keys != None:  # we had a response
    thisExp.addData('key_resp_62.rt', key_resp_62.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "joAjopA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_41.setSound('mainpairs/joAjopA.wav', secs=3.5, hamming=True)
sound_vowels_41.setVolume(1.0, log=False)
key_resp_41.keys = []
key_resp_41.rt = []
_key_resp_41_allKeys = []
# keep track of which components have finished
joAjopAComponents = [sound_vowels_41, text_201, text_202, text_203, text_204, text_205, key_resp_41]
for thisComponent in joAjopAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "joAjopA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_41
    if sound_vowels_41.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_41.frameNStart = frameN  # exact frame index
        sound_vowels_41.tStart = t  # local t and not account for scr refresh
        sound_vowels_41.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_41.started', tThisFlipGlobal)
        sound_vowels_41.play(when=win)  # sync with win flip
    if sound_vowels_41.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_41.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_41.tStop = t  # not accounting for scr refresh
            sound_vowels_41.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_41.stopped')
            sound_vowels_41.stop()
    
    # *text_201* updates
    if text_201.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_201.frameNStart = frameN  # exact frame index
        text_201.tStart = t  # local t and not account for scr refresh
        text_201.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_201, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_201.started')
        text_201.setAutoDraw(True)
    if text_201.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_201.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_201.tStop = t  # not accounting for scr refresh
            text_201.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_201.stopped')
            text_201.setAutoDraw(False)
    
    # *text_202* updates
    if text_202.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_202.frameNStart = frameN  # exact frame index
        text_202.tStart = t  # local t and not account for scr refresh
        text_202.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_202, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_202.started')
        text_202.setAutoDraw(True)
    if text_202.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_202.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_202.tStop = t  # not accounting for scr refresh
            text_202.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_202.stopped')
            text_202.setAutoDraw(False)
    
    # *text_203* updates
    if text_203.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_203.frameNStart = frameN  # exact frame index
        text_203.tStart = t  # local t and not account for scr refresh
        text_203.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_203, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_203.started')
        text_203.setAutoDraw(True)
    if text_203.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_203.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_203.tStop = t  # not accounting for scr refresh
            text_203.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_203.stopped')
            text_203.setAutoDraw(False)
    
    # *text_204* updates
    if text_204.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_204.frameNStart = frameN  # exact frame index
        text_204.tStart = t  # local t and not account for scr refresh
        text_204.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_204, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_204.started')
        text_204.setAutoDraw(True)
    if text_204.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_204.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_204.tStop = t  # not accounting for scr refresh
            text_204.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_204.stopped')
            text_204.setAutoDraw(False)
    
    # *text_205* updates
    if text_205.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_205.frameNStart = frameN  # exact frame index
        text_205.tStart = t  # local t and not account for scr refresh
        text_205.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_205, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_205.started')
        text_205.setAutoDraw(True)
    if text_205.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_205.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_205.tStop = t  # not accounting for scr refresh
            text_205.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_205.stopped')
            text_205.setAutoDraw(False)
    
    # *key_resp_41* updates
    waitOnFlip = False
    if key_resp_41.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_41.frameNStart = frameN  # exact frame index
        key_resp_41.tStart = t  # local t and not account for scr refresh
        key_resp_41.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_41, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_41.started')
        key_resp_41.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_41.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_41.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_41.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_41.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_41.tStop = t  # not accounting for scr refresh
            key_resp_41.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_41.stopped')
            key_resp_41.status = FINISHED
    if key_resp_41.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_41.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_41_allKeys.extend(theseKeys)
        if len(_key_resp_41_allKeys):
            key_resp_41.keys = _key_resp_41_allKeys[-1].name  # just the last key pressed
            key_resp_41.rt = _key_resp_41_allKeys[-1].rt
            # was this correct?
            if (key_resp_41.keys == str('n')) or (key_resp_41.keys == 'n'):
                key_resp_41.corr = 1
            else:
                key_resp_41.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in joAjopAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "joAjopA" ---
for thisComponent in joAjopAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_41.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_41.keys in ['', [], None]:  # No response was made
    key_resp_41.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_41.corr = 1;  # correct non-response
    else:
       key_resp_41.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_41.keys',key_resp_41.keys)
thisExp.addData('key_resp_41.corr', key_resp_41.corr)
if key_resp_41.keys != None:  # we had a response
    thisExp.addData('key_resp_41.rt', key_resp_41.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sapja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_37.setSound('mainpairs/sapja.wav', secs=3.5, hamming=True)
sound_vowels_37.setVolume(1.0, log=False)
key_resp_37.keys = []
key_resp_37.rt = []
_key_resp_37_allKeys = []
# keep track of which components have finished
sapjaComponents = [sound_vowels_37, text_181, text_182, text_183, text_184, text_185, key_resp_37]
for thisComponent in sapjaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sapja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_37
    if sound_vowels_37.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_37.frameNStart = frameN  # exact frame index
        sound_vowels_37.tStart = t  # local t and not account for scr refresh
        sound_vowels_37.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_37.started', tThisFlipGlobal)
        sound_vowels_37.play(when=win)  # sync with win flip
    if sound_vowels_37.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_37.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_37.tStop = t  # not accounting for scr refresh
            sound_vowels_37.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_37.stopped')
            sound_vowels_37.stop()
    
    # *text_181* updates
    if text_181.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_181.frameNStart = frameN  # exact frame index
        text_181.tStart = t  # local t and not account for scr refresh
        text_181.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_181, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_181.started')
        text_181.setAutoDraw(True)
    if text_181.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_181.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_181.tStop = t  # not accounting for scr refresh
            text_181.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_181.stopped')
            text_181.setAutoDraw(False)
    
    # *text_182* updates
    if text_182.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_182.frameNStart = frameN  # exact frame index
        text_182.tStart = t  # local t and not account for scr refresh
        text_182.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_182, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_182.started')
        text_182.setAutoDraw(True)
    if text_182.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_182.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_182.tStop = t  # not accounting for scr refresh
            text_182.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_182.stopped')
            text_182.setAutoDraw(False)
    
    # *text_183* updates
    if text_183.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_183.frameNStart = frameN  # exact frame index
        text_183.tStart = t  # local t and not account for scr refresh
        text_183.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_183, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_183.started')
        text_183.setAutoDraw(True)
    if text_183.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_183.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_183.tStop = t  # not accounting for scr refresh
            text_183.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_183.stopped')
            text_183.setAutoDraw(False)
    
    # *text_184* updates
    if text_184.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_184.frameNStart = frameN  # exact frame index
        text_184.tStart = t  # local t and not account for scr refresh
        text_184.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_184, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_184.started')
        text_184.setAutoDraw(True)
    if text_184.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_184.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_184.tStop = t  # not accounting for scr refresh
            text_184.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_184.stopped')
            text_184.setAutoDraw(False)
    
    # *text_185* updates
    if text_185.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_185.frameNStart = frameN  # exact frame index
        text_185.tStart = t  # local t and not account for scr refresh
        text_185.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_185, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_185.started')
        text_185.setAutoDraw(True)
    if text_185.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_185.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_185.tStop = t  # not accounting for scr refresh
            text_185.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_185.stopped')
            text_185.setAutoDraw(False)
    
    # *key_resp_37* updates
    waitOnFlip = False
    if key_resp_37.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_37.frameNStart = frameN  # exact frame index
        key_resp_37.tStart = t  # local t and not account for scr refresh
        key_resp_37.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_37, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_37.started')
        key_resp_37.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_37.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_37.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_37.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_37.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_37.tStop = t  # not accounting for scr refresh
            key_resp_37.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_37.stopped')
            key_resp_37.status = FINISHED
    if key_resp_37.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_37.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_37_allKeys.extend(theseKeys)
        if len(_key_resp_37_allKeys):
            key_resp_37.keys = _key_resp_37_allKeys[-1].name  # just the last key pressed
            key_resp_37.rt = _key_resp_37_allKeys[-1].rt
            # was this correct?
            if (key_resp_37.keys == str('n')) or (key_resp_37.keys == 'n'):
                key_resp_37.corr = 1
            else:
                key_resp_37.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sapjaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sapja" ---
for thisComponent in sapjaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_37.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_37.keys in ['', [], None]:  # No response was made
    key_resp_37.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_37.corr = 1;  # correct non-response
    else:
       key_resp_37.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_37.keys',key_resp_37.keys)
thisExp.addData('key_resp_37.corr', key_resp_37.corr)
if key_resp_37.keys != None:  # we had a response
    thisExp.addData('key_resp_37.rt', key_resp_37.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_sa_japja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_64.setSound('mainpairs/sa.ja+sa.japja.wav', secs=3.5, hamming=True)
sound_vowels_64.setVolume(1.0, log=False)
key_resp_64.keys = []
key_resp_64.rt = []
_key_resp_64_allKeys = []
# keep track of which components have finished
sa_ja_sa_japjaComponents = [sound_vowels_64, text_316, text_317, text_318, text_319, text_320, key_resp_64]
for thisComponent in sa_ja_sa_japjaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_sa_japja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_64
    if sound_vowels_64.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_64.frameNStart = frameN  # exact frame index
        sound_vowels_64.tStart = t  # local t and not account for scr refresh
        sound_vowels_64.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_64.started', tThisFlipGlobal)
        sound_vowels_64.play(when=win)  # sync with win flip
    if sound_vowels_64.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_64.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_64.tStop = t  # not accounting for scr refresh
            sound_vowels_64.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_64.stopped')
            sound_vowels_64.stop()
    
    # *text_316* updates
    if text_316.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_316.frameNStart = frameN  # exact frame index
        text_316.tStart = t  # local t and not account for scr refresh
        text_316.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_316, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_316.started')
        text_316.setAutoDraw(True)
    if text_316.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_316.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_316.tStop = t  # not accounting for scr refresh
            text_316.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_316.stopped')
            text_316.setAutoDraw(False)
    
    # *text_317* updates
    if text_317.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_317.frameNStart = frameN  # exact frame index
        text_317.tStart = t  # local t and not account for scr refresh
        text_317.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_317, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_317.started')
        text_317.setAutoDraw(True)
    if text_317.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_317.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_317.tStop = t  # not accounting for scr refresh
            text_317.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_317.stopped')
            text_317.setAutoDraw(False)
    
    # *text_318* updates
    if text_318.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_318.frameNStart = frameN  # exact frame index
        text_318.tStart = t  # local t and not account for scr refresh
        text_318.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_318, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_318.started')
        text_318.setAutoDraw(True)
    if text_318.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_318.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_318.tStop = t  # not accounting for scr refresh
            text_318.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_318.stopped')
            text_318.setAutoDraw(False)
    
    # *text_319* updates
    if text_319.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_319.frameNStart = frameN  # exact frame index
        text_319.tStart = t  # local t and not account for scr refresh
        text_319.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_319, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_319.started')
        text_319.setAutoDraw(True)
    if text_319.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_319.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_319.tStop = t  # not accounting for scr refresh
            text_319.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_319.stopped')
            text_319.setAutoDraw(False)
    
    # *text_320* updates
    if text_320.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_320.frameNStart = frameN  # exact frame index
        text_320.tStart = t  # local t and not account for scr refresh
        text_320.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_320, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_320.started')
        text_320.setAutoDraw(True)
    if text_320.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_320.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_320.tStop = t  # not accounting for scr refresh
            text_320.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_320.stopped')
            text_320.setAutoDraw(False)
    
    # *key_resp_64* updates
    waitOnFlip = False
    if key_resp_64.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_64.frameNStart = frameN  # exact frame index
        key_resp_64.tStart = t  # local t and not account for scr refresh
        key_resp_64.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_64, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_64.started')
        key_resp_64.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_64.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_64.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_64.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_64.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_64.tStop = t  # not accounting for scr refresh
            key_resp_64.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_64.stopped')
            key_resp_64.status = FINISHED
    if key_resp_64.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_64.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_64_allKeys.extend(theseKeys)
        if len(_key_resp_64_allKeys):
            key_resp_64.keys = _key_resp_64_allKeys[-1].name  # just the last key pressed
            key_resp_64.rt = _key_resp_64_allKeys[-1].rt
            # was this correct?
            if (key_resp_64.keys == str('n')) or (key_resp_64.keys == 'n'):
                key_resp_64.corr = 1
            else:
                key_resp_64.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_sa_japjaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_sa_japja" ---
for thisComponent in sa_ja_sa_japjaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_64.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_64.keys in ['', [], None]:  # No response was made
    key_resp_64.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_64.corr = 1;  # correct non-response
    else:
       key_resp_64.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_64.keys',key_resp_64.keys)
thisExp.addData('key_resp_64.corr', key_resp_64.corr)
if key_resp_64.keys != None:  # we had a response
    thisExp.addData('key_resp_64.rt', key_resp_64.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "josojopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_57.setSound('mainpairs/josojopso.wav', secs=3.5, hamming=True)
sound_vowels_57.setVolume(1.0, log=False)
key_resp_57.keys = []
key_resp_57.rt = []
_key_resp_57_allKeys = []
# keep track of which components have finished
josojopsoComponents = [sound_vowels_57, text_281, text_282, text_283, text_284, text_285, key_resp_57]
for thisComponent in josojopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "josojopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_57
    if sound_vowels_57.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_57.frameNStart = frameN  # exact frame index
        sound_vowels_57.tStart = t  # local t and not account for scr refresh
        sound_vowels_57.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_57.started', tThisFlipGlobal)
        sound_vowels_57.play(when=win)  # sync with win flip
    if sound_vowels_57.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_57.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_57.tStop = t  # not accounting for scr refresh
            sound_vowels_57.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_57.stopped')
            sound_vowels_57.stop()
    
    # *text_281* updates
    if text_281.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_281.frameNStart = frameN  # exact frame index
        text_281.tStart = t  # local t and not account for scr refresh
        text_281.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_281, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_281.started')
        text_281.setAutoDraw(True)
    if text_281.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_281.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_281.tStop = t  # not accounting for scr refresh
            text_281.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_281.stopped')
            text_281.setAutoDraw(False)
    
    # *text_282* updates
    if text_282.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_282.frameNStart = frameN  # exact frame index
        text_282.tStart = t  # local t and not account for scr refresh
        text_282.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_282, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_282.started')
        text_282.setAutoDraw(True)
    if text_282.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_282.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_282.tStop = t  # not accounting for scr refresh
            text_282.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_282.stopped')
            text_282.setAutoDraw(False)
    
    # *text_283* updates
    if text_283.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_283.frameNStart = frameN  # exact frame index
        text_283.tStart = t  # local t and not account for scr refresh
        text_283.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_283, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_283.started')
        text_283.setAutoDraw(True)
    if text_283.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_283.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_283.tStop = t  # not accounting for scr refresh
            text_283.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_283.stopped')
            text_283.setAutoDraw(False)
    
    # *text_284* updates
    if text_284.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_284.frameNStart = frameN  # exact frame index
        text_284.tStart = t  # local t and not account for scr refresh
        text_284.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_284, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_284.started')
        text_284.setAutoDraw(True)
    if text_284.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_284.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_284.tStop = t  # not accounting for scr refresh
            text_284.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_284.stopped')
            text_284.setAutoDraw(False)
    
    # *text_285* updates
    if text_285.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_285.frameNStart = frameN  # exact frame index
        text_285.tStart = t  # local t and not account for scr refresh
        text_285.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_285, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_285.started')
        text_285.setAutoDraw(True)
    if text_285.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_285.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_285.tStop = t  # not accounting for scr refresh
            text_285.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_285.stopped')
            text_285.setAutoDraw(False)
    
    # *key_resp_57* updates
    waitOnFlip = False
    if key_resp_57.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_57.frameNStart = frameN  # exact frame index
        key_resp_57.tStart = t  # local t and not account for scr refresh
        key_resp_57.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_57, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_57.started')
        key_resp_57.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_57.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_57.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_57.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_57.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_57.tStop = t  # not accounting for scr refresh
            key_resp_57.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_57.stopped')
            key_resp_57.status = FINISHED
    if key_resp_57.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_57.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_57_allKeys.extend(theseKeys)
        if len(_key_resp_57_allKeys):
            key_resp_57.keys = _key_resp_57_allKeys[-1].name  # just the last key pressed
            key_resp_57.rt = _key_resp_57_allKeys[-1].rt
            # was this correct?
            if (key_resp_57.keys == str('n')) or (key_resp_57.keys == 'n'):
                key_resp_57.corr = 1
            else:
                key_resp_57.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in josojopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "josojopso" ---
for thisComponent in josojopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_57.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_57.keys in ['', [], None]:  # No response was made
    key_resp_57.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_57.corr = 1;  # correct non-response
    else:
       key_resp_57.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_57.keys',key_resp_57.keys)
thisExp.addData('key_resp_57.corr', key_resp_57.corr)
if key_resp_57.keys != None:  # we had a response
    thisExp.addData('key_resp_57.rt', key_resp_57.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "so_jo_so_jo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_81.setSound('mainpairs/so.jo+so.jo.wav', secs=3.5, hamming=True)
sound_vowels_81.setVolume(1.0, log=False)
key_resp_81.keys = []
key_resp_81.rt = []
_key_resp_81_allKeys = []
# keep track of which components have finished
so_jo_so_joComponents = [sound_vowels_81, text_401, text_402, text_403, text_404, text_405, key_resp_81]
for thisComponent in so_jo_so_joComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "so_jo_so_jo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_81
    if sound_vowels_81.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_81.frameNStart = frameN  # exact frame index
        sound_vowels_81.tStart = t  # local t and not account for scr refresh
        sound_vowels_81.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_81.started', tThisFlipGlobal)
        sound_vowels_81.play(when=win)  # sync with win flip
    if sound_vowels_81.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_81.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_81.tStop = t  # not accounting for scr refresh
            sound_vowels_81.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_81.stopped')
            sound_vowels_81.stop()
    
    # *text_401* updates
    if text_401.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_401.frameNStart = frameN  # exact frame index
        text_401.tStart = t  # local t and not account for scr refresh
        text_401.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_401, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_401.started')
        text_401.setAutoDraw(True)
    if text_401.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_401.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_401.tStop = t  # not accounting for scr refresh
            text_401.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_401.stopped')
            text_401.setAutoDraw(False)
    
    # *text_402* updates
    if text_402.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_402.frameNStart = frameN  # exact frame index
        text_402.tStart = t  # local t and not account for scr refresh
        text_402.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_402, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_402.started')
        text_402.setAutoDraw(True)
    if text_402.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_402.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_402.tStop = t  # not accounting for scr refresh
            text_402.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_402.stopped')
            text_402.setAutoDraw(False)
    
    # *text_403* updates
    if text_403.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_403.frameNStart = frameN  # exact frame index
        text_403.tStart = t  # local t and not account for scr refresh
        text_403.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_403, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_403.started')
        text_403.setAutoDraw(True)
    if text_403.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_403.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_403.tStop = t  # not accounting for scr refresh
            text_403.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_403.stopped')
            text_403.setAutoDraw(False)
    
    # *text_404* updates
    if text_404.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_404.frameNStart = frameN  # exact frame index
        text_404.tStart = t  # local t and not account for scr refresh
        text_404.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_404, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_404.started')
        text_404.setAutoDraw(True)
    if text_404.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_404.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_404.tStop = t  # not accounting for scr refresh
            text_404.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_404.stopped')
            text_404.setAutoDraw(False)
    
    # *text_405* updates
    if text_405.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_405.frameNStart = frameN  # exact frame index
        text_405.tStart = t  # local t and not account for scr refresh
        text_405.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_405, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_405.started')
        text_405.setAutoDraw(True)
    if text_405.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_405.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_405.tStop = t  # not accounting for scr refresh
            text_405.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_405.stopped')
            text_405.setAutoDraw(False)
    
    # *key_resp_81* updates
    waitOnFlip = False
    if key_resp_81.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_81.frameNStart = frameN  # exact frame index
        key_resp_81.tStart = t  # local t and not account for scr refresh
        key_resp_81.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_81, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_81.started')
        key_resp_81.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_81.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_81.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_81.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_81.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_81.tStop = t  # not accounting for scr refresh
            key_resp_81.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_81.stopped')
            key_resp_81.status = FINISHED
    if key_resp_81.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_81.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_81_allKeys.extend(theseKeys)
        if len(_key_resp_81_allKeys):
            key_resp_81.keys = _key_resp_81_allKeys[-1].name  # just the last key pressed
            key_resp_81.rt = _key_resp_81_allKeys[-1].rt
            # was this correct?
            if (key_resp_81.keys == str('y')) or (key_resp_81.keys == 'y'):
                key_resp_81.corr = 1
            else:
                key_resp_81.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in so_jo_so_joComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "so_jo_so_jo" ---
for thisComponent in so_jo_so_joComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_81.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_81.keys in ['', [], None]:  # No response was made
    key_resp_81.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_81.corr = 1;  # correct non-response
    else:
       key_resp_81.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_81.keys',key_resp_81.keys)
thisExp.addData('key_resp_81.corr', key_resp_81.corr)
if key_resp_81.keys != None:  # we had a response
    thisExp.addData('key_resp_81.rt', key_resp_81.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_sa_japja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_61.setSound('mainpairs/sa+sa.japja.wav', secs=3.5, hamming=True)
sound_vowels_61.setVolume(1.0, log=False)
key_resp_61.keys = []
key_resp_61.rt = []
_key_resp_61_allKeys = []
# keep track of which components have finished
sa_sa_japjaComponents = [sound_vowels_61, text_301, text_302, text_303, text_304, text_305, key_resp_61]
for thisComponent in sa_sa_japjaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_sa_japja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_61
    if sound_vowels_61.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_61.frameNStart = frameN  # exact frame index
        sound_vowels_61.tStart = t  # local t and not account for scr refresh
        sound_vowels_61.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_61.started', tThisFlipGlobal)
        sound_vowels_61.play(when=win)  # sync with win flip
    if sound_vowels_61.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_61.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_61.tStop = t  # not accounting for scr refresh
            sound_vowels_61.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_61.stopped')
            sound_vowels_61.stop()
    
    # *text_301* updates
    if text_301.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_301.frameNStart = frameN  # exact frame index
        text_301.tStart = t  # local t and not account for scr refresh
        text_301.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_301, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_301.started')
        text_301.setAutoDraw(True)
    if text_301.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_301.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_301.tStop = t  # not accounting for scr refresh
            text_301.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_301.stopped')
            text_301.setAutoDraw(False)
    
    # *text_302* updates
    if text_302.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_302.frameNStart = frameN  # exact frame index
        text_302.tStart = t  # local t and not account for scr refresh
        text_302.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_302, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_302.started')
        text_302.setAutoDraw(True)
    if text_302.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_302.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_302.tStop = t  # not accounting for scr refresh
            text_302.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_302.stopped')
            text_302.setAutoDraw(False)
    
    # *text_303* updates
    if text_303.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_303.frameNStart = frameN  # exact frame index
        text_303.tStart = t  # local t and not account for scr refresh
        text_303.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_303, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_303.started')
        text_303.setAutoDraw(True)
    if text_303.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_303.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_303.tStop = t  # not accounting for scr refresh
            text_303.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_303.stopped')
            text_303.setAutoDraw(False)
    
    # *text_304* updates
    if text_304.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_304.frameNStart = frameN  # exact frame index
        text_304.tStart = t  # local t and not account for scr refresh
        text_304.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_304, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_304.started')
        text_304.setAutoDraw(True)
    if text_304.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_304.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_304.tStop = t  # not accounting for scr refresh
            text_304.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_304.stopped')
            text_304.setAutoDraw(False)
    
    # *text_305* updates
    if text_305.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_305.frameNStart = frameN  # exact frame index
        text_305.tStart = t  # local t and not account for scr refresh
        text_305.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_305, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_305.started')
        text_305.setAutoDraw(True)
    if text_305.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_305.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_305.tStop = t  # not accounting for scr refresh
            text_305.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_305.stopped')
            text_305.setAutoDraw(False)
    
    # *key_resp_61* updates
    waitOnFlip = False
    if key_resp_61.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_61.frameNStart = frameN  # exact frame index
        key_resp_61.tStart = t  # local t and not account for scr refresh
        key_resp_61.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_61, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_61.started')
        key_resp_61.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_61.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_61.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_61.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_61.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_61.tStop = t  # not accounting for scr refresh
            key_resp_61.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_61.stopped')
            key_resp_61.status = FINISHED
    if key_resp_61.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_61.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_61_allKeys.extend(theseKeys)
        if len(_key_resp_61_allKeys):
            key_resp_61.keys = _key_resp_61_allKeys[-1].name  # just the last key pressed
            key_resp_61.rt = _key_resp_61_allKeys[-1].rt
            # was this correct?
            if (key_resp_61.keys == str('n')) or (key_resp_61.keys == 'n'):
                key_resp_61.corr = 1
            else:
                key_resp_61.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_sa_japjaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_sa_japja" ---
for thisComponent in sa_sa_japjaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_61.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_61.keys in ['', [], None]:  # No response was made
    key_resp_61.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_61.corr = 1;  # correct non-response
    else:
       key_resp_61.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_61.keys',key_resp_61.keys)
thisExp.addData('key_resp_61.corr', key_resp_61.corr)
if key_resp_61.keys != None:  # we had a response
    thisExp.addData('key_resp_61.rt', key_resp_61.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sojojopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_52.setSound('mainpairs/sojojopso.wav', secs=3.5, hamming=True)
sound_vowels_52.setVolume(1.0, log=False)
key_resp_52.keys = []
key_resp_52.rt = []
_key_resp_52_allKeys = []
# keep track of which components have finished
sojojopsoComponents = [sound_vowels_52, text_256, text_257, text_258, text_259, text_260, key_resp_52]
for thisComponent in sojojopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sojojopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_52
    if sound_vowels_52.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_52.frameNStart = frameN  # exact frame index
        sound_vowels_52.tStart = t  # local t and not account for scr refresh
        sound_vowels_52.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_52.started', tThisFlipGlobal)
        sound_vowels_52.play(when=win)  # sync with win flip
    if sound_vowels_52.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_52.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_52.tStop = t  # not accounting for scr refresh
            sound_vowels_52.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_52.stopped')
            sound_vowels_52.stop()
    
    # *text_256* updates
    if text_256.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_256.frameNStart = frameN  # exact frame index
        text_256.tStart = t  # local t and not account for scr refresh
        text_256.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_256, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_256.started')
        text_256.setAutoDraw(True)
    if text_256.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_256.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_256.tStop = t  # not accounting for scr refresh
            text_256.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_256.stopped')
            text_256.setAutoDraw(False)
    
    # *text_257* updates
    if text_257.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_257.frameNStart = frameN  # exact frame index
        text_257.tStart = t  # local t and not account for scr refresh
        text_257.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_257, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_257.started')
        text_257.setAutoDraw(True)
    if text_257.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_257.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_257.tStop = t  # not accounting for scr refresh
            text_257.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_257.stopped')
            text_257.setAutoDraw(False)
    
    # *text_258* updates
    if text_258.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_258.frameNStart = frameN  # exact frame index
        text_258.tStart = t  # local t and not account for scr refresh
        text_258.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_258, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_258.started')
        text_258.setAutoDraw(True)
    if text_258.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_258.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_258.tStop = t  # not accounting for scr refresh
            text_258.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_258.stopped')
            text_258.setAutoDraw(False)
    
    # *text_259* updates
    if text_259.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_259.frameNStart = frameN  # exact frame index
        text_259.tStart = t  # local t and not account for scr refresh
        text_259.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_259, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_259.started')
        text_259.setAutoDraw(True)
    if text_259.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_259.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_259.tStop = t  # not accounting for scr refresh
            text_259.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_259.stopped')
            text_259.setAutoDraw(False)
    
    # *text_260* updates
    if text_260.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_260.frameNStart = frameN  # exact frame index
        text_260.tStart = t  # local t and not account for scr refresh
        text_260.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_260, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_260.started')
        text_260.setAutoDraw(True)
    if text_260.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_260.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_260.tStop = t  # not accounting for scr refresh
            text_260.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_260.stopped')
            text_260.setAutoDraw(False)
    
    # *key_resp_52* updates
    waitOnFlip = False
    if key_resp_52.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_52.frameNStart = frameN  # exact frame index
        key_resp_52.tStart = t  # local t and not account for scr refresh
        key_resp_52.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_52, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_52.started')
        key_resp_52.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_52.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_52.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_52.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_52.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_52.tStop = t  # not accounting for scr refresh
            key_resp_52.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_52.stopped')
            key_resp_52.status = FINISHED
    if key_resp_52.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_52.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_52_allKeys.extend(theseKeys)
        if len(_key_resp_52_allKeys):
            key_resp_52.keys = _key_resp_52_allKeys[-1].name  # just the last key pressed
            key_resp_52.rt = _key_resp_52_allKeys[-1].rt
            # was this correct?
            if (key_resp_52.keys == str('n')) or (key_resp_52.keys == 'n'):
                key_resp_52.corr = 1
            else:
                key_resp_52.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sojojopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sojojopso" ---
for thisComponent in sojojopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_52.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_52.keys in ['', [], None]:  # No response was made
    key_resp_52.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_52.corr = 1;  # correct non-response
    else:
       key_resp_52.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_52.keys',key_resp_52.keys)
thisExp.addData('key_resp_52.corr', key_resp_52.corr)
if key_resp_52.keys != None:  # we had a response
    thisExp.addData('key_resp_52.rt', key_resp_52.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jojoApA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_43.setSound('mainpairs/jojoApA.wav', secs=3.5, hamming=True)
sound_vowels_43.setVolume(1.0, log=False)
key_resp_43.keys = []
key_resp_43.rt = []
_key_resp_43_allKeys = []
# keep track of which components have finished
jojoApAComponents = [sound_vowels_43, text_211, text_212, text_213, text_214, text_215, key_resp_43]
for thisComponent in jojoApAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jojoApA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_43
    if sound_vowels_43.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_43.frameNStart = frameN  # exact frame index
        sound_vowels_43.tStart = t  # local t and not account for scr refresh
        sound_vowels_43.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_43.started', tThisFlipGlobal)
        sound_vowels_43.play(when=win)  # sync with win flip
    if sound_vowels_43.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_43.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_43.tStop = t  # not accounting for scr refresh
            sound_vowels_43.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_43.stopped')
            sound_vowels_43.stop()
    
    # *text_211* updates
    if text_211.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_211.frameNStart = frameN  # exact frame index
        text_211.tStart = t  # local t and not account for scr refresh
        text_211.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_211, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_211.started')
        text_211.setAutoDraw(True)
    if text_211.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_211.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_211.tStop = t  # not accounting for scr refresh
            text_211.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_211.stopped')
            text_211.setAutoDraw(False)
    
    # *text_212* updates
    if text_212.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_212.frameNStart = frameN  # exact frame index
        text_212.tStart = t  # local t and not account for scr refresh
        text_212.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_212, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_212.started')
        text_212.setAutoDraw(True)
    if text_212.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_212.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_212.tStop = t  # not accounting for scr refresh
            text_212.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_212.stopped')
            text_212.setAutoDraw(False)
    
    # *text_213* updates
    if text_213.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_213.frameNStart = frameN  # exact frame index
        text_213.tStart = t  # local t and not account for scr refresh
        text_213.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_213, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_213.started')
        text_213.setAutoDraw(True)
    if text_213.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_213.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_213.tStop = t  # not accounting for scr refresh
            text_213.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_213.stopped')
            text_213.setAutoDraw(False)
    
    # *text_214* updates
    if text_214.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_214.frameNStart = frameN  # exact frame index
        text_214.tStart = t  # local t and not account for scr refresh
        text_214.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_214, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_214.started')
        text_214.setAutoDraw(True)
    if text_214.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_214.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_214.tStop = t  # not accounting for scr refresh
            text_214.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_214.stopped')
            text_214.setAutoDraw(False)
    
    # *text_215* updates
    if text_215.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_215.frameNStart = frameN  # exact frame index
        text_215.tStart = t  # local t and not account for scr refresh
        text_215.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_215, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_215.started')
        text_215.setAutoDraw(True)
    if text_215.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_215.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_215.tStop = t  # not accounting for scr refresh
            text_215.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_215.stopped')
            text_215.setAutoDraw(False)
    
    # *key_resp_43* updates
    waitOnFlip = False
    if key_resp_43.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_43.frameNStart = frameN  # exact frame index
        key_resp_43.tStart = t  # local t and not account for scr refresh
        key_resp_43.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_43, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_43.started')
        key_resp_43.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_43.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_43.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_43.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_43.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_43.tStop = t  # not accounting for scr refresh
            key_resp_43.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_43.stopped')
            key_resp_43.status = FINISHED
    if key_resp_43.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_43.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_43_allKeys.extend(theseKeys)
        if len(_key_resp_43_allKeys):
            key_resp_43.keys = _key_resp_43_allKeys[-1].name  # just the last key pressed
            key_resp_43.rt = _key_resp_43_allKeys[-1].rt
            # was this correct?
            if (key_resp_43.keys == str('n')) or (key_resp_43.keys == 'n'):
                key_resp_43.corr = 1
            else:
                key_resp_43.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jojoApAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jojoApA" ---
for thisComponent in jojoApAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_43.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_43.keys in ['', [], None]:  # No response was made
    key_resp_43.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_43.corr = 1;  # correct non-response
    else:
       key_resp_43.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_43.keys',key_resp_43.keys)
thisExp.addData('key_resp_43.corr', key_resp_43.corr)
if key_resp_43.keys != None:  # we had a response
    thisExp.addData('key_resp_43.rt', key_resp_43.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "so_jo_so" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_82.setSound('mainpairs/so.jo+so.wav', secs=3.5, hamming=True)
sound_vowels_82.setVolume(1.0, log=False)
key_resp_82.keys = []
key_resp_82.rt = []
_key_resp_82_allKeys = []
# keep track of which components have finished
so_jo_soComponents = [sound_vowels_82, text_406, text_407, text_408, text_409, text_410, key_resp_82]
for thisComponent in so_jo_soComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "so_jo_so" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_82
    if sound_vowels_82.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_82.frameNStart = frameN  # exact frame index
        sound_vowels_82.tStart = t  # local t and not account for scr refresh
        sound_vowels_82.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_82.started', tThisFlipGlobal)
        sound_vowels_82.play(when=win)  # sync with win flip
    if sound_vowels_82.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_82.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_82.tStop = t  # not accounting for scr refresh
            sound_vowels_82.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_82.stopped')
            sound_vowels_82.stop()
    
    # *text_406* updates
    if text_406.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_406.frameNStart = frameN  # exact frame index
        text_406.tStart = t  # local t and not account for scr refresh
        text_406.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_406, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_406.started')
        text_406.setAutoDraw(True)
    if text_406.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_406.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_406.tStop = t  # not accounting for scr refresh
            text_406.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_406.stopped')
            text_406.setAutoDraw(False)
    
    # *text_407* updates
    if text_407.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_407.frameNStart = frameN  # exact frame index
        text_407.tStart = t  # local t and not account for scr refresh
        text_407.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_407, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_407.started')
        text_407.setAutoDraw(True)
    if text_407.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_407.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_407.tStop = t  # not accounting for scr refresh
            text_407.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_407.stopped')
            text_407.setAutoDraw(False)
    
    # *text_408* updates
    if text_408.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_408.frameNStart = frameN  # exact frame index
        text_408.tStart = t  # local t and not account for scr refresh
        text_408.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_408, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_408.started')
        text_408.setAutoDraw(True)
    if text_408.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_408.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_408.tStop = t  # not accounting for scr refresh
            text_408.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_408.stopped')
            text_408.setAutoDraw(False)
    
    # *text_409* updates
    if text_409.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_409.frameNStart = frameN  # exact frame index
        text_409.tStart = t  # local t and not account for scr refresh
        text_409.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_409, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_409.started')
        text_409.setAutoDraw(True)
    if text_409.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_409.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_409.tStop = t  # not accounting for scr refresh
            text_409.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_409.stopped')
            text_409.setAutoDraw(False)
    
    # *text_410* updates
    if text_410.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_410.frameNStart = frameN  # exact frame index
        text_410.tStart = t  # local t and not account for scr refresh
        text_410.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_410, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_410.started')
        text_410.setAutoDraw(True)
    if text_410.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_410.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_410.tStop = t  # not accounting for scr refresh
            text_410.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_410.stopped')
            text_410.setAutoDraw(False)
    
    # *key_resp_82* updates
    waitOnFlip = False
    if key_resp_82.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_82.frameNStart = frameN  # exact frame index
        key_resp_82.tStart = t  # local t and not account for scr refresh
        key_resp_82.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_82, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_82.started')
        key_resp_82.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_82.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_82.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_82.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_82.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_82.tStop = t  # not accounting for scr refresh
            key_resp_82.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_82.stopped')
            key_resp_82.status = FINISHED
    if key_resp_82.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_82.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_82_allKeys.extend(theseKeys)
        if len(_key_resp_82_allKeys):
            key_resp_82.keys = _key_resp_82_allKeys[-1].name  # just the last key pressed
            key_resp_82.rt = _key_resp_82_allKeys[-1].rt
            # was this correct?
            if (key_resp_82.keys == str('y')) or (key_resp_82.keys == 'y'):
                key_resp_82.corr = 1
            else:
                key_resp_82.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in so_jo_soComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "so_jo_so" ---
for thisComponent in so_jo_soComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_82.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_82.keys in ['', [], None]:  # No response was made
    key_resp_82.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_82.corr = 1;  # correct non-response
    else:
       key_resp_82.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_82.keys',key_resp_82.keys)
thisExp.addData('key_resp_82.corr', key_resp_82.corr)
if key_resp_82.keys != None:  # we had a response
    thisExp.addData('key_resp_82.rt', key_resp_82.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "joAApA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_38.setSound('mainpairs/joAApA.wav', secs=3.5, hamming=True)
sound_vowels_38.setVolume(1.0, log=False)
key_resp_38.keys = []
key_resp_38.rt = []
_key_resp_38_allKeys = []
# keep track of which components have finished
joAApAComponents = [sound_vowels_38, text_186, text_187, text_188, text_189, text_190, key_resp_38]
for thisComponent in joAApAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "joAApA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_38
    if sound_vowels_38.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_38.frameNStart = frameN  # exact frame index
        sound_vowels_38.tStart = t  # local t and not account for scr refresh
        sound_vowels_38.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_38.started', tThisFlipGlobal)
        sound_vowels_38.play(when=win)  # sync with win flip
    if sound_vowels_38.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_38.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_38.tStop = t  # not accounting for scr refresh
            sound_vowels_38.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_38.stopped')
            sound_vowels_38.stop()
    
    # *text_186* updates
    if text_186.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_186.frameNStart = frameN  # exact frame index
        text_186.tStart = t  # local t and not account for scr refresh
        text_186.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_186, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_186.started')
        text_186.setAutoDraw(True)
    if text_186.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_186.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_186.tStop = t  # not accounting for scr refresh
            text_186.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_186.stopped')
            text_186.setAutoDraw(False)
    
    # *text_187* updates
    if text_187.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_187.frameNStart = frameN  # exact frame index
        text_187.tStart = t  # local t and not account for scr refresh
        text_187.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_187, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_187.started')
        text_187.setAutoDraw(True)
    if text_187.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_187.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_187.tStop = t  # not accounting for scr refresh
            text_187.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_187.stopped')
            text_187.setAutoDraw(False)
    
    # *text_188* updates
    if text_188.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_188.frameNStart = frameN  # exact frame index
        text_188.tStart = t  # local t and not account for scr refresh
        text_188.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_188, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_188.started')
        text_188.setAutoDraw(True)
    if text_188.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_188.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_188.tStop = t  # not accounting for scr refresh
            text_188.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_188.stopped')
            text_188.setAutoDraw(False)
    
    # *text_189* updates
    if text_189.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_189.frameNStart = frameN  # exact frame index
        text_189.tStart = t  # local t and not account for scr refresh
        text_189.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_189, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_189.started')
        text_189.setAutoDraw(True)
    if text_189.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_189.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_189.tStop = t  # not accounting for scr refresh
            text_189.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_189.stopped')
            text_189.setAutoDraw(False)
    
    # *text_190* updates
    if text_190.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_190.frameNStart = frameN  # exact frame index
        text_190.tStart = t  # local t and not account for scr refresh
        text_190.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_190, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_190.started')
        text_190.setAutoDraw(True)
    if text_190.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_190.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_190.tStop = t  # not accounting for scr refresh
            text_190.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_190.stopped')
            text_190.setAutoDraw(False)
    
    # *key_resp_38* updates
    waitOnFlip = False
    if key_resp_38.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_38.frameNStart = frameN  # exact frame index
        key_resp_38.tStart = t  # local t and not account for scr refresh
        key_resp_38.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_38, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_38.started')
        key_resp_38.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_38.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_38.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_38.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_38.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_38.tStop = t  # not accounting for scr refresh
            key_resp_38.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_38.stopped')
            key_resp_38.status = FINISHED
    if key_resp_38.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_38.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_38_allKeys.extend(theseKeys)
        if len(_key_resp_38_allKeys):
            key_resp_38.keys = _key_resp_38_allKeys[-1].name  # just the last key pressed
            key_resp_38.rt = _key_resp_38_allKeys[-1].rt
            # was this correct?
            if (key_resp_38.keys == str('n')) or (key_resp_38.keys == 'n'):
                key_resp_38.corr = 1
            else:
                key_resp_38.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in joAApAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "joAApA" ---
for thisComponent in joAApAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_38.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_38.keys in ['', [], None]:  # No response was made
    key_resp_38.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_38.corr = 1;  # correct non-response
    else:
       key_resp_38.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_38.keys',key_resp_38.keys)
thisExp.addData('key_resp_38.corr', key_resp_38.corr)
if key_resp_38.keys != None:  # we had a response
    thisExp.addData('key_resp_38.rt', key_resp_38.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sojosopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_55.setSound('mainpairs/sojosopso.wav', secs=3.5, hamming=True)
sound_vowels_55.setVolume(1.0, log=False)
key_resp_55.keys = []
key_resp_55.rt = []
_key_resp_55_allKeys = []
# keep track of which components have finished
sojosopsoComponents = [sound_vowels_55, text_271, text_272, text_273, text_274, text_275, key_resp_55]
for thisComponent in sojosopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sojosopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_55
    if sound_vowels_55.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_55.frameNStart = frameN  # exact frame index
        sound_vowels_55.tStart = t  # local t and not account for scr refresh
        sound_vowels_55.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_55.started', tThisFlipGlobal)
        sound_vowels_55.play(when=win)  # sync with win flip
    if sound_vowels_55.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_55.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_55.tStop = t  # not accounting for scr refresh
            sound_vowels_55.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_55.stopped')
            sound_vowels_55.stop()
    
    # *text_271* updates
    if text_271.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_271.frameNStart = frameN  # exact frame index
        text_271.tStart = t  # local t and not account for scr refresh
        text_271.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_271, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_271.started')
        text_271.setAutoDraw(True)
    if text_271.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_271.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_271.tStop = t  # not accounting for scr refresh
            text_271.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_271.stopped')
            text_271.setAutoDraw(False)
    
    # *text_272* updates
    if text_272.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_272.frameNStart = frameN  # exact frame index
        text_272.tStart = t  # local t and not account for scr refresh
        text_272.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_272, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_272.started')
        text_272.setAutoDraw(True)
    if text_272.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_272.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_272.tStop = t  # not accounting for scr refresh
            text_272.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_272.stopped')
            text_272.setAutoDraw(False)
    
    # *text_273* updates
    if text_273.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_273.frameNStart = frameN  # exact frame index
        text_273.tStart = t  # local t and not account for scr refresh
        text_273.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_273, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_273.started')
        text_273.setAutoDraw(True)
    if text_273.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_273.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_273.tStop = t  # not accounting for scr refresh
            text_273.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_273.stopped')
            text_273.setAutoDraw(False)
    
    # *text_274* updates
    if text_274.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_274.frameNStart = frameN  # exact frame index
        text_274.tStart = t  # local t and not account for scr refresh
        text_274.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_274, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_274.started')
        text_274.setAutoDraw(True)
    if text_274.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_274.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_274.tStop = t  # not accounting for scr refresh
            text_274.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_274.stopped')
            text_274.setAutoDraw(False)
    
    # *text_275* updates
    if text_275.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_275.frameNStart = frameN  # exact frame index
        text_275.tStart = t  # local t and not account for scr refresh
        text_275.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_275, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_275.started')
        text_275.setAutoDraw(True)
    if text_275.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_275.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_275.tStop = t  # not accounting for scr refresh
            text_275.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_275.stopped')
            text_275.setAutoDraw(False)
    
    # *key_resp_55* updates
    waitOnFlip = False
    if key_resp_55.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_55.frameNStart = frameN  # exact frame index
        key_resp_55.tStart = t  # local t and not account for scr refresh
        key_resp_55.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_55, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_55.started')
        key_resp_55.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_55.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_55.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_55.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_55.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_55.tStop = t  # not accounting for scr refresh
            key_resp_55.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_55.stopped')
            key_resp_55.status = FINISHED
    if key_resp_55.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_55.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_55_allKeys.extend(theseKeys)
        if len(_key_resp_55_allKeys):
            key_resp_55.keys = _key_resp_55_allKeys[-1].name  # just the last key pressed
            key_resp_55.rt = _key_resp_55_allKeys[-1].rt
            # was this correct?
            if (key_resp_55.keys == str('n')) or (key_resp_55.keys == 'n'):
                key_resp_55.corr = 1
            else:
                key_resp_55.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sojosopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sojosopso" ---
for thisComponent in sojosopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_55.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_55.keys in ['', [], None]:  # No response was made
    key_resp_55.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_55.corr = 1;  # correct non-response
    else:
       key_resp_55.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_55.keys',key_resp_55.keys)
thisExp.addData('key_resp_55.corr', key_resp_55.corr)
if key_resp_55.keys != None:  # we had a response
    thisExp.addData('key_resp_55.rt', key_resp_55.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "usa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_33.setSound('mainpairs/usa.wav', secs=3.5, hamming=True)
sound_vowels_33.setVolume(1.0, log=False)
key_resp_33.keys = []
key_resp_33.rt = []
_key_resp_33_allKeys = []
# keep track of which components have finished
usaComponents = [sound_vowels_33, text_161, text_162, text_163, text_164, text_165, key_resp_33]
for thisComponent in usaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "usa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_33
    if sound_vowels_33.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_33.frameNStart = frameN  # exact frame index
        sound_vowels_33.tStart = t  # local t and not account for scr refresh
        sound_vowels_33.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_33.started', tThisFlipGlobal)
        sound_vowels_33.play(when=win)  # sync with win flip
    if sound_vowels_33.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_33.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_33.tStop = t  # not accounting for scr refresh
            sound_vowels_33.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_33.stopped')
            sound_vowels_33.stop()
    
    # *text_161* updates
    if text_161.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_161.frameNStart = frameN  # exact frame index
        text_161.tStart = t  # local t and not account for scr refresh
        text_161.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_161, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_161.started')
        text_161.setAutoDraw(True)
    if text_161.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_161.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_161.tStop = t  # not accounting for scr refresh
            text_161.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_161.stopped')
            text_161.setAutoDraw(False)
    
    # *text_162* updates
    if text_162.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_162.frameNStart = frameN  # exact frame index
        text_162.tStart = t  # local t and not account for scr refresh
        text_162.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_162, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_162.started')
        text_162.setAutoDraw(True)
    if text_162.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_162.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_162.tStop = t  # not accounting for scr refresh
            text_162.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_162.stopped')
            text_162.setAutoDraw(False)
    
    # *text_163* updates
    if text_163.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_163.frameNStart = frameN  # exact frame index
        text_163.tStart = t  # local t and not account for scr refresh
        text_163.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_163, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_163.started')
        text_163.setAutoDraw(True)
    if text_163.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_163.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_163.tStop = t  # not accounting for scr refresh
            text_163.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_163.stopped')
            text_163.setAutoDraw(False)
    
    # *text_164* updates
    if text_164.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_164.frameNStart = frameN  # exact frame index
        text_164.tStart = t  # local t and not account for scr refresh
        text_164.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_164, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_164.started')
        text_164.setAutoDraw(True)
    if text_164.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_164.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_164.tStop = t  # not accounting for scr refresh
            text_164.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_164.stopped')
            text_164.setAutoDraw(False)
    
    # *text_165* updates
    if text_165.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_165.frameNStart = frameN  # exact frame index
        text_165.tStart = t  # local t and not account for scr refresh
        text_165.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_165, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_165.started')
        text_165.setAutoDraw(True)
    if text_165.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_165.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_165.tStop = t  # not accounting for scr refresh
            text_165.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_165.stopped')
            text_165.setAutoDraw(False)
    
    # *key_resp_33* updates
    waitOnFlip = False
    if key_resp_33.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_33.frameNStart = frameN  # exact frame index
        key_resp_33.tStart = t  # local t and not account for scr refresh
        key_resp_33.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_33, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_33.started')
        key_resp_33.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_33.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_33.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_33.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_33.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_33.tStop = t  # not accounting for scr refresh
            key_resp_33.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_33.stopped')
            key_resp_33.status = FINISHED
    if key_resp_33.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_33.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_33_allKeys.extend(theseKeys)
        if len(_key_resp_33_allKeys):
            key_resp_33.keys = _key_resp_33_allKeys[-1].name  # just the last key pressed
            key_resp_33.rt = _key_resp_33_allKeys[-1].rt
            # was this correct?
            if (key_resp_33.keys == str('n')) or (key_resp_33.keys == 'n'):
                key_resp_33.corr = 1
            else:
                key_resp_33.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in usaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "usa" ---
for thisComponent in usaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_33.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_33.keys in ['', [], None]:  # No response was made
    key_resp_33.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_33.corr = 1;  # correct non-response
    else:
       key_resp_33.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_33.keys',key_resp_33.keys)
thisExp.addData('key_resp_33.corr', key_resp_33.corr)
if key_resp_33.keys != None:  # we had a response
    thisExp.addData('key_resp_33.rt', key_resp_33.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "soja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_36.setSound('mainpairs/soja.wav', secs=3.5, hamming=True)
sound_vowels_36.setVolume(1.0, log=False)
key_resp_36.keys = []
key_resp_36.rt = []
_key_resp_36_allKeys = []
# keep track of which components have finished
sojaComponents = [sound_vowels_36, text_176, text_177, text_178, text_179, text_180, key_resp_36]
for thisComponent in sojaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "soja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_36
    if sound_vowels_36.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_36.frameNStart = frameN  # exact frame index
        sound_vowels_36.tStart = t  # local t and not account for scr refresh
        sound_vowels_36.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_36.started', tThisFlipGlobal)
        sound_vowels_36.play(when=win)  # sync with win flip
    if sound_vowels_36.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_36.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_36.tStop = t  # not accounting for scr refresh
            sound_vowels_36.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_36.stopped')
            sound_vowels_36.stop()
    
    # *text_176* updates
    if text_176.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_176.frameNStart = frameN  # exact frame index
        text_176.tStart = t  # local t and not account for scr refresh
        text_176.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_176, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_176.started')
        text_176.setAutoDraw(True)
    if text_176.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_176.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_176.tStop = t  # not accounting for scr refresh
            text_176.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_176.stopped')
            text_176.setAutoDraw(False)
    
    # *text_177* updates
    if text_177.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_177.frameNStart = frameN  # exact frame index
        text_177.tStart = t  # local t and not account for scr refresh
        text_177.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_177, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_177.started')
        text_177.setAutoDraw(True)
    if text_177.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_177.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_177.tStop = t  # not accounting for scr refresh
            text_177.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_177.stopped')
            text_177.setAutoDraw(False)
    
    # *text_178* updates
    if text_178.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_178.frameNStart = frameN  # exact frame index
        text_178.tStart = t  # local t and not account for scr refresh
        text_178.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_178, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_178.started')
        text_178.setAutoDraw(True)
    if text_178.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_178.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_178.tStop = t  # not accounting for scr refresh
            text_178.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_178.stopped')
            text_178.setAutoDraw(False)
    
    # *text_179* updates
    if text_179.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_179.frameNStart = frameN  # exact frame index
        text_179.tStart = t  # local t and not account for scr refresh
        text_179.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_179, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_179.started')
        text_179.setAutoDraw(True)
    if text_179.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_179.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_179.tStop = t  # not accounting for scr refresh
            text_179.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_179.stopped')
            text_179.setAutoDraw(False)
    
    # *text_180* updates
    if text_180.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_180.frameNStart = frameN  # exact frame index
        text_180.tStart = t  # local t and not account for scr refresh
        text_180.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_180, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_180.started')
        text_180.setAutoDraw(True)
    if text_180.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_180.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_180.tStop = t  # not accounting for scr refresh
            text_180.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_180.stopped')
            text_180.setAutoDraw(False)
    
    # *key_resp_36* updates
    waitOnFlip = False
    if key_resp_36.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_36.frameNStart = frameN  # exact frame index
        key_resp_36.tStart = t  # local t and not account for scr refresh
        key_resp_36.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_36, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_36.started')
        key_resp_36.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_36.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_36.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_36.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_36.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_36.tStop = t  # not accounting for scr refresh
            key_resp_36.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_36.stopped')
            key_resp_36.status = FINISHED
    if key_resp_36.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_36.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_36_allKeys.extend(theseKeys)
        if len(_key_resp_36_allKeys):
            key_resp_36.keys = _key_resp_36_allKeys[-1].name  # just the last key pressed
            key_resp_36.rt = _key_resp_36_allKeys[-1].rt
            # was this correct?
            if (key_resp_36.keys == str('n')) or (key_resp_36.keys == 'n'):
                key_resp_36.corr = 1
            else:
                key_resp_36.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sojaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "soja" ---
for thisComponent in sojaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_36.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_36.keys in ['', [], None]:  # No response was made
    key_resp_36.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_36.corr = 1;  # correct non-response
    else:
       key_resp_36.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_36.keys',key_resp_36.keys)
thisExp.addData('key_resp_36.corr', key_resp_36.corr)
if key_resp_36.keys != None:  # we had a response
    thisExp.addData('key_resp_36.rt', key_resp_36.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AsaAsapsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_24.setSound('mainpairs/AsaAsapsa.wav', secs=3.5, hamming=True)
sound_vowels_24.setVolume(1.0, log=False)
key_resp_24.keys = []
key_resp_24.rt = []
_key_resp_24_allKeys = []
# keep track of which components have finished
AsaAsapsaComponents = [sound_vowels_24, text_116, text_117, text_118, text_119, text_120, key_resp_24]
for thisComponent in AsaAsapsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AsaAsapsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_24
    if sound_vowels_24.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_24.frameNStart = frameN  # exact frame index
        sound_vowels_24.tStart = t  # local t and not account for scr refresh
        sound_vowels_24.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_24.started', tThisFlipGlobal)
        sound_vowels_24.play(when=win)  # sync with win flip
    if sound_vowels_24.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_24.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_24.tStop = t  # not accounting for scr refresh
            sound_vowels_24.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_24.stopped')
            sound_vowels_24.stop()
    
    # *text_116* updates
    if text_116.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_116.frameNStart = frameN  # exact frame index
        text_116.tStart = t  # local t and not account for scr refresh
        text_116.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_116, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_116.started')
        text_116.setAutoDraw(True)
    if text_116.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_116.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_116.tStop = t  # not accounting for scr refresh
            text_116.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_116.stopped')
            text_116.setAutoDraw(False)
    
    # *text_117* updates
    if text_117.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_117.frameNStart = frameN  # exact frame index
        text_117.tStart = t  # local t and not account for scr refresh
        text_117.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_117, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_117.started')
        text_117.setAutoDraw(True)
    if text_117.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_117.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_117.tStop = t  # not accounting for scr refresh
            text_117.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_117.stopped')
            text_117.setAutoDraw(False)
    
    # *text_118* updates
    if text_118.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_118.frameNStart = frameN  # exact frame index
        text_118.tStart = t  # local t and not account for scr refresh
        text_118.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_118, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_118.started')
        text_118.setAutoDraw(True)
    if text_118.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_118.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_118.tStop = t  # not accounting for scr refresh
            text_118.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_118.stopped')
            text_118.setAutoDraw(False)
    
    # *text_119* updates
    if text_119.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_119.frameNStart = frameN  # exact frame index
        text_119.tStart = t  # local t and not account for scr refresh
        text_119.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_119, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_119.started')
        text_119.setAutoDraw(True)
    if text_119.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_119.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_119.tStop = t  # not accounting for scr refresh
            text_119.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_119.stopped')
            text_119.setAutoDraw(False)
    
    # *text_120* updates
    if text_120.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_120.frameNStart = frameN  # exact frame index
        text_120.tStart = t  # local t and not account for scr refresh
        text_120.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_120, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_120.started')
        text_120.setAutoDraw(True)
    if text_120.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_120.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_120.tStop = t  # not accounting for scr refresh
            text_120.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_120.stopped')
            text_120.setAutoDraw(False)
    
    # *key_resp_24* updates
    waitOnFlip = False
    if key_resp_24.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_24.frameNStart = frameN  # exact frame index
        key_resp_24.tStart = t  # local t and not account for scr refresh
        key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_24.started')
        key_resp_24.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_24.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_24.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_24.tStop = t  # not accounting for scr refresh
            key_resp_24.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_24.stopped')
            key_resp_24.status = FINISHED
    if key_resp_24.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_24.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_24_allKeys.extend(theseKeys)
        if len(_key_resp_24_allKeys):
            key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
            key_resp_24.rt = _key_resp_24_allKeys[-1].rt
            # was this correct?
            if (key_resp_24.keys == str('n')) or (key_resp_24.keys == 'n'):
                key_resp_24.corr = 1
            else:
                key_resp_24.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AsaAsapsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AsaAsapsa" ---
for thisComponent in AsaAsapsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_24.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_24.keys in ['', [], None]:  # No response was made
    key_resp_24.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_24.corr = 1;  # correct non-response
    else:
       key_resp_24.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_24.keys',key_resp_24.keys)
thisExp.addData('key_resp_24.corr', key_resp_24.corr)
if key_resp_24.keys != None:  # we had a response
    thisExp.addData('key_resp_24.rt', key_resp_24.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "uja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_34.setSound('mainpairs/uja.wav', secs=3.5, hamming=True)
sound_vowels_34.setVolume(1.0, log=False)
key_resp_34.keys = []
key_resp_34.rt = []
_key_resp_34_allKeys = []
# keep track of which components have finished
ujaComponents = [sound_vowels_34, text_166, text_167, text_168, text_169, text_170, key_resp_34]
for thisComponent in ujaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "uja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_34
    if sound_vowels_34.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_34.frameNStart = frameN  # exact frame index
        sound_vowels_34.tStart = t  # local t and not account for scr refresh
        sound_vowels_34.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_34.started', tThisFlipGlobal)
        sound_vowels_34.play(when=win)  # sync with win flip
    if sound_vowels_34.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_34.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_34.tStop = t  # not accounting for scr refresh
            sound_vowels_34.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_34.stopped')
            sound_vowels_34.stop()
    
    # *text_166* updates
    if text_166.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_166.frameNStart = frameN  # exact frame index
        text_166.tStart = t  # local t and not account for scr refresh
        text_166.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_166, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_166.started')
        text_166.setAutoDraw(True)
    if text_166.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_166.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_166.tStop = t  # not accounting for scr refresh
            text_166.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_166.stopped')
            text_166.setAutoDraw(False)
    
    # *text_167* updates
    if text_167.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_167.frameNStart = frameN  # exact frame index
        text_167.tStart = t  # local t and not account for scr refresh
        text_167.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_167, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_167.started')
        text_167.setAutoDraw(True)
    if text_167.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_167.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_167.tStop = t  # not accounting for scr refresh
            text_167.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_167.stopped')
            text_167.setAutoDraw(False)
    
    # *text_168* updates
    if text_168.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_168.frameNStart = frameN  # exact frame index
        text_168.tStart = t  # local t and not account for scr refresh
        text_168.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_168, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_168.started')
        text_168.setAutoDraw(True)
    if text_168.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_168.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_168.tStop = t  # not accounting for scr refresh
            text_168.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_168.stopped')
            text_168.setAutoDraw(False)
    
    # *text_169* updates
    if text_169.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_169.frameNStart = frameN  # exact frame index
        text_169.tStart = t  # local t and not account for scr refresh
        text_169.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_169, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_169.started')
        text_169.setAutoDraw(True)
    if text_169.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_169.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_169.tStop = t  # not accounting for scr refresh
            text_169.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_169.stopped')
            text_169.setAutoDraw(False)
    
    # *text_170* updates
    if text_170.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_170.frameNStart = frameN  # exact frame index
        text_170.tStart = t  # local t and not account for scr refresh
        text_170.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_170, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_170.started')
        text_170.setAutoDraw(True)
    if text_170.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_170.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_170.tStop = t  # not accounting for scr refresh
            text_170.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_170.stopped')
            text_170.setAutoDraw(False)
    
    # *key_resp_34* updates
    waitOnFlip = False
    if key_resp_34.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_34.frameNStart = frameN  # exact frame index
        key_resp_34.tStart = t  # local t and not account for scr refresh
        key_resp_34.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_34, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_34.started')
        key_resp_34.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_34.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_34.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_34.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_34.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_34.tStop = t  # not accounting for scr refresh
            key_resp_34.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_34.stopped')
            key_resp_34.status = FINISHED
    if key_resp_34.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_34.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_34_allKeys.extend(theseKeys)
        if len(_key_resp_34_allKeys):
            key_resp_34.keys = _key_resp_34_allKeys[-1].name  # just the last key pressed
            key_resp_34.rt = _key_resp_34_allKeys[-1].rt
            # was this correct?
            if (key_resp_34.keys == str('n')) or (key_resp_34.keys == 'n'):
                key_resp_34.corr = 1
            else:
                key_resp_34.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in ujaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "uja" ---
for thisComponent in ujaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_34.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_34.keys in ['', [], None]:  # No response was made
    key_resp_34.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_34.corr = 1;  # correct non-response
    else:
       key_resp_34.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_34.keys',key_resp_34.keys)
thisExp.addData('key_resp_34.corr', key_resp_34.corr)
if key_resp_34.keys != None:  # we had a response
    thisExp.addData('key_resp_34.rt', key_resp_34.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_sapsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_67.setSound('mainpairs/sa.ja+sapsa.wav', secs=3.5, hamming=True)
sound_vowels_67.setVolume(1.0, log=False)
key_resp_67.keys = []
key_resp_67.rt = []
_key_resp_67_allKeys = []
# keep track of which components have finished
sa_ja_sapsaComponents = [sound_vowels_67, text_331, text_332, text_333, text_334, text_335, key_resp_67]
for thisComponent in sa_ja_sapsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_sapsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_67
    if sound_vowels_67.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_67.frameNStart = frameN  # exact frame index
        sound_vowels_67.tStart = t  # local t and not account for scr refresh
        sound_vowels_67.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_67.started', tThisFlipGlobal)
        sound_vowels_67.play(when=win)  # sync with win flip
    if sound_vowels_67.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_67.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_67.tStop = t  # not accounting for scr refresh
            sound_vowels_67.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_67.stopped')
            sound_vowels_67.stop()
    
    # *text_331* updates
    if text_331.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_331.frameNStart = frameN  # exact frame index
        text_331.tStart = t  # local t and not account for scr refresh
        text_331.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_331, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_331.started')
        text_331.setAutoDraw(True)
    if text_331.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_331.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_331.tStop = t  # not accounting for scr refresh
            text_331.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_331.stopped')
            text_331.setAutoDraw(False)
    
    # *text_332* updates
    if text_332.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_332.frameNStart = frameN  # exact frame index
        text_332.tStart = t  # local t and not account for scr refresh
        text_332.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_332, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_332.started')
        text_332.setAutoDraw(True)
    if text_332.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_332.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_332.tStop = t  # not accounting for scr refresh
            text_332.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_332.stopped')
            text_332.setAutoDraw(False)
    
    # *text_333* updates
    if text_333.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_333.frameNStart = frameN  # exact frame index
        text_333.tStart = t  # local t and not account for scr refresh
        text_333.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_333, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_333.started')
        text_333.setAutoDraw(True)
    if text_333.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_333.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_333.tStop = t  # not accounting for scr refresh
            text_333.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_333.stopped')
            text_333.setAutoDraw(False)
    
    # *text_334* updates
    if text_334.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_334.frameNStart = frameN  # exact frame index
        text_334.tStart = t  # local t and not account for scr refresh
        text_334.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_334, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_334.started')
        text_334.setAutoDraw(True)
    if text_334.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_334.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_334.tStop = t  # not accounting for scr refresh
            text_334.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_334.stopped')
            text_334.setAutoDraw(False)
    
    # *text_335* updates
    if text_335.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_335.frameNStart = frameN  # exact frame index
        text_335.tStart = t  # local t and not account for scr refresh
        text_335.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_335, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_335.started')
        text_335.setAutoDraw(True)
    if text_335.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_335.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_335.tStop = t  # not accounting for scr refresh
            text_335.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_335.stopped')
            text_335.setAutoDraw(False)
    
    # *key_resp_67* updates
    waitOnFlip = False
    if key_resp_67.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_67.frameNStart = frameN  # exact frame index
        key_resp_67.tStart = t  # local t and not account for scr refresh
        key_resp_67.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_67, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_67.started')
        key_resp_67.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_67.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_67.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_67.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_67.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_67.tStop = t  # not accounting for scr refresh
            key_resp_67.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_67.stopped')
            key_resp_67.status = FINISHED
    if key_resp_67.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_67.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_67_allKeys.extend(theseKeys)
        if len(_key_resp_67_allKeys):
            key_resp_67.keys = _key_resp_67_allKeys[-1].name  # just the last key pressed
            key_resp_67.rt = _key_resp_67_allKeys[-1].rt
            # was this correct?
            if (key_resp_67.keys == str('n')) or (key_resp_67.keys == 'n'):
                key_resp_67.corr = 1
            else:
                key_resp_67.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_sapsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_sapsa" ---
for thisComponent in sa_ja_sapsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_67.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_67.keys in ['', [], None]:  # No response was made
    key_resp_67.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_67.corr = 1;  # correct non-response
    else:
       key_resp_67.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_67.keys',key_resp_67.keys)
thisExp.addData('key_resp_67.corr', key_resp_67.corr)
if key_resp_67.keys != None:  # we had a response
    thisExp.addData('key_resp_67.rt', key_resp_67.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "u" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_31.setSound('mainpairs/u.wav', secs=3.5, hamming=True)
sound_vowels_31.setVolume(1.0, log=False)
key_resp_31.keys = []
key_resp_31.rt = []
_key_resp_31_allKeys = []
# keep track of which components have finished
uComponents = [sound_vowels_31, text_151, text_152, text_153, text_154, text_155, key_resp_31]
for thisComponent in uComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "u" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_31
    if sound_vowels_31.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_31.frameNStart = frameN  # exact frame index
        sound_vowels_31.tStart = t  # local t and not account for scr refresh
        sound_vowels_31.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_31.started', tThisFlipGlobal)
        sound_vowels_31.play(when=win)  # sync with win flip
    if sound_vowels_31.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_31.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_31.tStop = t  # not accounting for scr refresh
            sound_vowels_31.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_31.stopped')
            sound_vowels_31.stop()
    
    # *text_151* updates
    if text_151.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_151.frameNStart = frameN  # exact frame index
        text_151.tStart = t  # local t and not account for scr refresh
        text_151.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_151, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_151.started')
        text_151.setAutoDraw(True)
    if text_151.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_151.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_151.tStop = t  # not accounting for scr refresh
            text_151.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_151.stopped')
            text_151.setAutoDraw(False)
    
    # *text_152* updates
    if text_152.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_152.frameNStart = frameN  # exact frame index
        text_152.tStart = t  # local t and not account for scr refresh
        text_152.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_152, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_152.started')
        text_152.setAutoDraw(True)
    if text_152.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_152.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_152.tStop = t  # not accounting for scr refresh
            text_152.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_152.stopped')
            text_152.setAutoDraw(False)
    
    # *text_153* updates
    if text_153.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_153.frameNStart = frameN  # exact frame index
        text_153.tStart = t  # local t and not account for scr refresh
        text_153.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_153, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_153.started')
        text_153.setAutoDraw(True)
    if text_153.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_153.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_153.tStop = t  # not accounting for scr refresh
            text_153.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_153.stopped')
            text_153.setAutoDraw(False)
    
    # *text_154* updates
    if text_154.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_154.frameNStart = frameN  # exact frame index
        text_154.tStart = t  # local t and not account for scr refresh
        text_154.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_154, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_154.started')
        text_154.setAutoDraw(True)
    if text_154.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_154.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_154.tStop = t  # not accounting for scr refresh
            text_154.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_154.stopped')
            text_154.setAutoDraw(False)
    
    # *text_155* updates
    if text_155.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_155.frameNStart = frameN  # exact frame index
        text_155.tStart = t  # local t and not account for scr refresh
        text_155.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_155, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_155.started')
        text_155.setAutoDraw(True)
    if text_155.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_155.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_155.tStop = t  # not accounting for scr refresh
            text_155.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_155.stopped')
            text_155.setAutoDraw(False)
    
    # *key_resp_31* updates
    waitOnFlip = False
    if key_resp_31.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_31.frameNStart = frameN  # exact frame index
        key_resp_31.tStart = t  # local t and not account for scr refresh
        key_resp_31.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_31, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_31.started')
        key_resp_31.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_31.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_31.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_31.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_31.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_31.tStop = t  # not accounting for scr refresh
            key_resp_31.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_31.stopped')
            key_resp_31.status = FINISHED
    if key_resp_31.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_31.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_31_allKeys.extend(theseKeys)
        if len(_key_resp_31_allKeys):
            key_resp_31.keys = _key_resp_31_allKeys[-1].name  # just the last key pressed
            key_resp_31.rt = _key_resp_31_allKeys[-1].rt
            # was this correct?
            if (key_resp_31.keys == str('y')) or (key_resp_31.keys == 'y'):
                key_resp_31.corr = 1
            else:
                key_resp_31.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in uComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "u" ---
for thisComponent in uComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_31.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_31.keys in ['', [], None]:  # No response was made
    key_resp_31.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_31.corr = 1;  # correct non-response
    else:
       key_resp_31.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_31.keys',key_resp_31.keys)
thisExp.addData('key_resp_31.corr', key_resp_31.corr)
if key_resp_31.keys != None:  # we had a response
    thisExp.addData('key_resp_31.rt', key_resp_31.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_sapja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_66.setSound('mainpairs/sa.ja+sapja.wav', secs=3.5, hamming=True)
sound_vowels_66.setVolume(1.0, log=False)
key_resp_66.keys = []
key_resp_66.rt = []
_key_resp_66_allKeys = []
# keep track of which components have finished
sa_ja_sapjaComponents = [sound_vowels_66, text_326, text_327, text_328, text_329, text_330, key_resp_66]
for thisComponent in sa_ja_sapjaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_sapja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_66
    if sound_vowels_66.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_66.frameNStart = frameN  # exact frame index
        sound_vowels_66.tStart = t  # local t and not account for scr refresh
        sound_vowels_66.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_66.started', tThisFlipGlobal)
        sound_vowels_66.play(when=win)  # sync with win flip
    if sound_vowels_66.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_66.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_66.tStop = t  # not accounting for scr refresh
            sound_vowels_66.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_66.stopped')
            sound_vowels_66.stop()
    
    # *text_326* updates
    if text_326.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_326.frameNStart = frameN  # exact frame index
        text_326.tStart = t  # local t and not account for scr refresh
        text_326.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_326, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_326.started')
        text_326.setAutoDraw(True)
    if text_326.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_326.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_326.tStop = t  # not accounting for scr refresh
            text_326.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_326.stopped')
            text_326.setAutoDraw(False)
    
    # *text_327* updates
    if text_327.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_327.frameNStart = frameN  # exact frame index
        text_327.tStart = t  # local t and not account for scr refresh
        text_327.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_327, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_327.started')
        text_327.setAutoDraw(True)
    if text_327.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_327.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_327.tStop = t  # not accounting for scr refresh
            text_327.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_327.stopped')
            text_327.setAutoDraw(False)
    
    # *text_328* updates
    if text_328.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_328.frameNStart = frameN  # exact frame index
        text_328.tStart = t  # local t and not account for scr refresh
        text_328.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_328, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_328.started')
        text_328.setAutoDraw(True)
    if text_328.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_328.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_328.tStop = t  # not accounting for scr refresh
            text_328.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_328.stopped')
            text_328.setAutoDraw(False)
    
    # *text_329* updates
    if text_329.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_329.frameNStart = frameN  # exact frame index
        text_329.tStart = t  # local t and not account for scr refresh
        text_329.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_329, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_329.started')
        text_329.setAutoDraw(True)
    if text_329.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_329.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_329.tStop = t  # not accounting for scr refresh
            text_329.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_329.stopped')
            text_329.setAutoDraw(False)
    
    # *text_330* updates
    if text_330.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_330.frameNStart = frameN  # exact frame index
        text_330.tStart = t  # local t and not account for scr refresh
        text_330.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_330, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_330.started')
        text_330.setAutoDraw(True)
    if text_330.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_330.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_330.tStop = t  # not accounting for scr refresh
            text_330.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_330.stopped')
            text_330.setAutoDraw(False)
    
    # *key_resp_66* updates
    waitOnFlip = False
    if key_resp_66.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_66.frameNStart = frameN  # exact frame index
        key_resp_66.tStart = t  # local t and not account for scr refresh
        key_resp_66.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_66, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_66.started')
        key_resp_66.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_66.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_66.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_66.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_66.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_66.tStop = t  # not accounting for scr refresh
            key_resp_66.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_66.stopped')
            key_resp_66.status = FINISHED
    if key_resp_66.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_66.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_66_allKeys.extend(theseKeys)
        if len(_key_resp_66_allKeys):
            key_resp_66.keys = _key_resp_66_allKeys[-1].name  # just the last key pressed
            key_resp_66.rt = _key_resp_66_allKeys[-1].rt
            # was this correct?
            if (key_resp_66.keys == str('n')) or (key_resp_66.keys == 'n'):
                key_resp_66.corr = 1
            else:
                key_resp_66.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_sapjaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_sapja" ---
for thisComponent in sa_ja_sapjaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_66.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_66.keys in ['', [], None]:  # No response was made
    key_resp_66.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_66.corr = 1;  # correct non-response
    else:
       key_resp_66.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_66.keys',key_resp_66.keys)
thisExp.addData('key_resp_66.corr', key_resp_66.corr)
if key_resp_66.keys != None:  # we had a response
    thisExp.addData('key_resp_66.rt', key_resp_66.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jopA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_32.setSound('mainpairs/jopA.wav', secs=3.5, hamming=True)
sound_vowels_32.setVolume(1.0, log=False)
key_resp_32.keys = []
key_resp_32.rt = []
_key_resp_32_allKeys = []
# keep track of which components have finished
jopAComponents = [sound_vowels_32, text_156, text_157, text_158, text_159, text_160, key_resp_32]
for thisComponent in jopAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jopA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_32
    if sound_vowels_32.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_32.frameNStart = frameN  # exact frame index
        sound_vowels_32.tStart = t  # local t and not account for scr refresh
        sound_vowels_32.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_32.started', tThisFlipGlobal)
        sound_vowels_32.play(when=win)  # sync with win flip
    if sound_vowels_32.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_32.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_32.tStop = t  # not accounting for scr refresh
            sound_vowels_32.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_32.stopped')
            sound_vowels_32.stop()
    
    # *text_156* updates
    if text_156.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_156.frameNStart = frameN  # exact frame index
        text_156.tStart = t  # local t and not account for scr refresh
        text_156.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_156, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_156.started')
        text_156.setAutoDraw(True)
    if text_156.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_156.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_156.tStop = t  # not accounting for scr refresh
            text_156.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_156.stopped')
            text_156.setAutoDraw(False)
    
    # *text_157* updates
    if text_157.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_157.frameNStart = frameN  # exact frame index
        text_157.tStart = t  # local t and not account for scr refresh
        text_157.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_157, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_157.started')
        text_157.setAutoDraw(True)
    if text_157.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_157.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_157.tStop = t  # not accounting for scr refresh
            text_157.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_157.stopped')
            text_157.setAutoDraw(False)
    
    # *text_158* updates
    if text_158.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_158.frameNStart = frameN  # exact frame index
        text_158.tStart = t  # local t and not account for scr refresh
        text_158.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_158, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_158.started')
        text_158.setAutoDraw(True)
    if text_158.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_158.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_158.tStop = t  # not accounting for scr refresh
            text_158.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_158.stopped')
            text_158.setAutoDraw(False)
    
    # *text_159* updates
    if text_159.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_159.frameNStart = frameN  # exact frame index
        text_159.tStart = t  # local t and not account for scr refresh
        text_159.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_159, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_159.started')
        text_159.setAutoDraw(True)
    if text_159.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_159.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_159.tStop = t  # not accounting for scr refresh
            text_159.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_159.stopped')
            text_159.setAutoDraw(False)
    
    # *text_160* updates
    if text_160.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_160.frameNStart = frameN  # exact frame index
        text_160.tStart = t  # local t and not account for scr refresh
        text_160.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_160, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_160.started')
        text_160.setAutoDraw(True)
    if text_160.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_160.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_160.tStop = t  # not accounting for scr refresh
            text_160.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_160.stopped')
            text_160.setAutoDraw(False)
    
    # *key_resp_32* updates
    waitOnFlip = False
    if key_resp_32.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_32.frameNStart = frameN  # exact frame index
        key_resp_32.tStart = t  # local t and not account for scr refresh
        key_resp_32.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_32, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_32.started')
        key_resp_32.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_32.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_32.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_32.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_32.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_32.tStop = t  # not accounting for scr refresh
            key_resp_32.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_32.stopped')
            key_resp_32.status = FINISHED
    if key_resp_32.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_32.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_32_allKeys.extend(theseKeys)
        if len(_key_resp_32_allKeys):
            key_resp_32.keys = _key_resp_32_allKeys[-1].name  # just the last key pressed
            key_resp_32.rt = _key_resp_32_allKeys[-1].rt
            # was this correct?
            if (key_resp_32.keys == str('n')) or (key_resp_32.keys == 'n'):
                key_resp_32.corr = 1
            else:
                key_resp_32.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jopAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jopA" ---
for thisComponent in jopAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_32.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_32.keys in ['', [], None]:  # No response was made
    key_resp_32.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_32.corr = 1;  # correct non-response
    else:
       key_resp_32.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_32.keys',key_resp_32.keys)
thisExp.addData('key_resp_32.corr', key_resp_32.corr)
if key_resp_32.keys != None:  # we had a response
    thisExp.addData('key_resp_32.rt', key_resp_32.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "usoupso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_16.setSound('mainpairs/usoupso.wav', secs=3.5, hamming=True)
sound_vowels_16.setVolume(1.0, log=False)
key_resp_16.keys = []
key_resp_16.rt = []
_key_resp_16_allKeys = []
# keep track of which components have finished
usoupsoComponents = [sound_vowels_16, text_76, text_77, text_78, text_79, text_80, key_resp_16]
for thisComponent in usoupsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "usoupso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_16
    if sound_vowels_16.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_16.frameNStart = frameN  # exact frame index
        sound_vowels_16.tStart = t  # local t and not account for scr refresh
        sound_vowels_16.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_16.started', tThisFlipGlobal)
        sound_vowels_16.play(when=win)  # sync with win flip
    if sound_vowels_16.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_16.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_16.tStop = t  # not accounting for scr refresh
            sound_vowels_16.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_16.stopped')
            sound_vowels_16.stop()
    
    # *text_76* updates
    if text_76.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_76.frameNStart = frameN  # exact frame index
        text_76.tStart = t  # local t and not account for scr refresh
        text_76.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_76, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_76.started')
        text_76.setAutoDraw(True)
    if text_76.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_76.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_76.tStop = t  # not accounting for scr refresh
            text_76.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_76.stopped')
            text_76.setAutoDraw(False)
    
    # *text_77* updates
    if text_77.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_77.frameNStart = frameN  # exact frame index
        text_77.tStart = t  # local t and not account for scr refresh
        text_77.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_77, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_77.started')
        text_77.setAutoDraw(True)
    if text_77.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_77.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_77.tStop = t  # not accounting for scr refresh
            text_77.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_77.stopped')
            text_77.setAutoDraw(False)
    
    # *text_78* updates
    if text_78.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_78.frameNStart = frameN  # exact frame index
        text_78.tStart = t  # local t and not account for scr refresh
        text_78.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_78, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_78.started')
        text_78.setAutoDraw(True)
    if text_78.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_78.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_78.tStop = t  # not accounting for scr refresh
            text_78.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_78.stopped')
            text_78.setAutoDraw(False)
    
    # *text_79* updates
    if text_79.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_79.frameNStart = frameN  # exact frame index
        text_79.tStart = t  # local t and not account for scr refresh
        text_79.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_79, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_79.started')
        text_79.setAutoDraw(True)
    if text_79.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_79.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_79.tStop = t  # not accounting for scr refresh
            text_79.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_79.stopped')
            text_79.setAutoDraw(False)
    
    # *text_80* updates
    if text_80.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_80.frameNStart = frameN  # exact frame index
        text_80.tStart = t  # local t and not account for scr refresh
        text_80.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_80, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_80.started')
        text_80.setAutoDraw(True)
    if text_80.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_80.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_80.tStop = t  # not accounting for scr refresh
            text_80.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_80.stopped')
            text_80.setAutoDraw(False)
    
    # *key_resp_16* updates
    waitOnFlip = False
    if key_resp_16.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_16.frameNStart = frameN  # exact frame index
        key_resp_16.tStart = t  # local t and not account for scr refresh
        key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_16.started')
        key_resp_16.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_16.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_16.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_16.tStop = t  # not accounting for scr refresh
            key_resp_16.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_16.stopped')
            key_resp_16.status = FINISHED
    if key_resp_16.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_16.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_16_allKeys.extend(theseKeys)
        if len(_key_resp_16_allKeys):
            key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
            key_resp_16.rt = _key_resp_16_allKeys[-1].rt
            # was this correct?
            if (key_resp_16.keys == str('n')) or (key_resp_16.keys == 'n'):
                key_resp_16.corr = 1
            else:
                key_resp_16.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in usoupsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "usoupso" ---
for thisComponent in usoupsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_16.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_16.keys in ['', [], None]:  # No response was made
    key_resp_16.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_16.corr = 1;  # correct non-response
    else:
       key_resp_16.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_16.keys',key_resp_16.keys)
thisExp.addData('key_resp_16.corr', key_resp_16.corr)
if key_resp_16.keys != None:  # we had a response
    thisExp.addData('key_resp_16.rt', key_resp_16.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sosojopjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_56.setSound('mainpairs/sosojopjo.wav', secs=3.5, hamming=True)
sound_vowels_56.setVolume(1.0, log=False)
key_resp_56.keys = []
key_resp_56.rt = []
_key_resp_56_allKeys = []
# keep track of which components have finished
sosojopjoComponents = [sound_vowels_56, text_276, text_277, text_278, text_279, text_280, key_resp_56]
for thisComponent in sosojopjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sosojopjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_56
    if sound_vowels_56.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_56.frameNStart = frameN  # exact frame index
        sound_vowels_56.tStart = t  # local t and not account for scr refresh
        sound_vowels_56.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_56.started', tThisFlipGlobal)
        sound_vowels_56.play(when=win)  # sync with win flip
    if sound_vowels_56.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_56.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_56.tStop = t  # not accounting for scr refresh
            sound_vowels_56.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_56.stopped')
            sound_vowels_56.stop()
    
    # *text_276* updates
    if text_276.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_276.frameNStart = frameN  # exact frame index
        text_276.tStart = t  # local t and not account for scr refresh
        text_276.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_276, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_276.started')
        text_276.setAutoDraw(True)
    if text_276.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_276.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_276.tStop = t  # not accounting for scr refresh
            text_276.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_276.stopped')
            text_276.setAutoDraw(False)
    
    # *text_277* updates
    if text_277.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_277.frameNStart = frameN  # exact frame index
        text_277.tStart = t  # local t and not account for scr refresh
        text_277.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_277, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_277.started')
        text_277.setAutoDraw(True)
    if text_277.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_277.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_277.tStop = t  # not accounting for scr refresh
            text_277.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_277.stopped')
            text_277.setAutoDraw(False)
    
    # *text_278* updates
    if text_278.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_278.frameNStart = frameN  # exact frame index
        text_278.tStart = t  # local t and not account for scr refresh
        text_278.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_278, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_278.started')
        text_278.setAutoDraw(True)
    if text_278.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_278.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_278.tStop = t  # not accounting for scr refresh
            text_278.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_278.stopped')
            text_278.setAutoDraw(False)
    
    # *text_279* updates
    if text_279.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_279.frameNStart = frameN  # exact frame index
        text_279.tStart = t  # local t and not account for scr refresh
        text_279.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_279, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_279.started')
        text_279.setAutoDraw(True)
    if text_279.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_279.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_279.tStop = t  # not accounting for scr refresh
            text_279.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_279.stopped')
            text_279.setAutoDraw(False)
    
    # *text_280* updates
    if text_280.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_280.frameNStart = frameN  # exact frame index
        text_280.tStart = t  # local t and not account for scr refresh
        text_280.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_280, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_280.started')
        text_280.setAutoDraw(True)
    if text_280.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_280.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_280.tStop = t  # not accounting for scr refresh
            text_280.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_280.stopped')
            text_280.setAutoDraw(False)
    
    # *key_resp_56* updates
    waitOnFlip = False
    if key_resp_56.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_56.frameNStart = frameN  # exact frame index
        key_resp_56.tStart = t  # local t and not account for scr refresh
        key_resp_56.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_56, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_56.started')
        key_resp_56.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_56.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_56.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_56.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_56.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_56.tStop = t  # not accounting for scr refresh
            key_resp_56.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_56.stopped')
            key_resp_56.status = FINISHED
    if key_resp_56.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_56.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_56_allKeys.extend(theseKeys)
        if len(_key_resp_56_allKeys):
            key_resp_56.keys = _key_resp_56_allKeys[-1].name  # just the last key pressed
            key_resp_56.rt = _key_resp_56_allKeys[-1].rt
            # was this correct?
            if (key_resp_56.keys == str('n')) or (key_resp_56.keys == 'n'):
                key_resp_56.corr = 1
            else:
                key_resp_56.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sosojopjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sosojopjo" ---
for thisComponent in sosojopjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_56.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_56.keys in ['', [], None]:  # No response was made
    key_resp_56.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_56.corr = 1;  # correct non-response
    else:
       key_resp_56.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_56.keys',key_resp_56.keys)
thisExp.addData('key_resp_56.corr', key_resp_56.corr)
if key_resp_56.keys != None:  # we had a response
    thisExp.addData('key_resp_56.rt', key_resp_56.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sosa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_35.setSound('mainpairs/sosa.wav', secs=3.5, hamming=True)
sound_vowels_35.setVolume(1.0, log=False)
key_resp_35.keys = []
key_resp_35.rt = []
_key_resp_35_allKeys = []
# keep track of which components have finished
sosaComponents = [sound_vowels_35, text_171, text_172, text_173, text_174, text_175, key_resp_35]
for thisComponent in sosaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sosa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_35
    if sound_vowels_35.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_35.frameNStart = frameN  # exact frame index
        sound_vowels_35.tStart = t  # local t and not account for scr refresh
        sound_vowels_35.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_35.started', tThisFlipGlobal)
        sound_vowels_35.play(when=win)  # sync with win flip
    if sound_vowels_35.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_35.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_35.tStop = t  # not accounting for scr refresh
            sound_vowels_35.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_35.stopped')
            sound_vowels_35.stop()
    
    # *text_171* updates
    if text_171.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_171.frameNStart = frameN  # exact frame index
        text_171.tStart = t  # local t and not account for scr refresh
        text_171.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_171, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_171.started')
        text_171.setAutoDraw(True)
    if text_171.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_171.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_171.tStop = t  # not accounting for scr refresh
            text_171.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_171.stopped')
            text_171.setAutoDraw(False)
    
    # *text_172* updates
    if text_172.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_172.frameNStart = frameN  # exact frame index
        text_172.tStart = t  # local t and not account for scr refresh
        text_172.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_172, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_172.started')
        text_172.setAutoDraw(True)
    if text_172.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_172.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_172.tStop = t  # not accounting for scr refresh
            text_172.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_172.stopped')
            text_172.setAutoDraw(False)
    
    # *text_173* updates
    if text_173.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_173.frameNStart = frameN  # exact frame index
        text_173.tStart = t  # local t and not account for scr refresh
        text_173.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_173, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_173.started')
        text_173.setAutoDraw(True)
    if text_173.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_173.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_173.tStop = t  # not accounting for scr refresh
            text_173.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_173.stopped')
            text_173.setAutoDraw(False)
    
    # *text_174* updates
    if text_174.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_174.frameNStart = frameN  # exact frame index
        text_174.tStart = t  # local t and not account for scr refresh
        text_174.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_174, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_174.started')
        text_174.setAutoDraw(True)
    if text_174.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_174.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_174.tStop = t  # not accounting for scr refresh
            text_174.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_174.stopped')
            text_174.setAutoDraw(False)
    
    # *text_175* updates
    if text_175.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_175.frameNStart = frameN  # exact frame index
        text_175.tStart = t  # local t and not account for scr refresh
        text_175.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_175, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_175.started')
        text_175.setAutoDraw(True)
    if text_175.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_175.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_175.tStop = t  # not accounting for scr refresh
            text_175.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_175.stopped')
            text_175.setAutoDraw(False)
    
    # *key_resp_35* updates
    waitOnFlip = False
    if key_resp_35.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_35.frameNStart = frameN  # exact frame index
        key_resp_35.tStart = t  # local t and not account for scr refresh
        key_resp_35.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_35, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_35.started')
        key_resp_35.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_35.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_35.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_35.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_35.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_35.tStop = t  # not accounting for scr refresh
            key_resp_35.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_35.stopped')
            key_resp_35.status = FINISHED
    if key_resp_35.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_35.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_35_allKeys.extend(theseKeys)
        if len(_key_resp_35_allKeys):
            key_resp_35.keys = _key_resp_35_allKeys[-1].name  # just the last key pressed
            key_resp_35.rt = _key_resp_35_allKeys[-1].rt
            # was this correct?
            if (key_resp_35.keys == str('n')) or (key_resp_35.keys == 'n'):
                key_resp_35.corr = 1
            else:
                key_resp_35.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sosaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sosa" ---
for thisComponent in sosaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_35.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_35.keys in ['', [], None]:  # No response was made
    key_resp_35.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_35.corr = 1;  # correct non-response
    else:
       key_resp_35.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_35.keys',key_resp_35.keys)
thisExp.addData('key_resp_35.corr', key_resp_35.corr)
if key_resp_35.keys != None:  # we had a response
    thisExp.addData('key_resp_35.rt', key_resp_35.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "A" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_9.setSound('mainpairs/A.wav', secs=3.5, hamming=True)
sound_vowels_9.setVolume(1.0, log=False)
key_resp_9.keys = []
key_resp_9.rt = []
_key_resp_9_allKeys = []
# keep track of which components have finished
AComponents = [sound_vowels_9, text_41, text_42, text_43, text_44, text_45, key_resp_9]
for thisComponent in AComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "A" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_9
    if sound_vowels_9.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_9.frameNStart = frameN  # exact frame index
        sound_vowels_9.tStart = t  # local t and not account for scr refresh
        sound_vowels_9.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_9.started', tThisFlipGlobal)
        sound_vowels_9.play(when=win)  # sync with win flip
    if sound_vowels_9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_9.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_9.tStop = t  # not accounting for scr refresh
            sound_vowels_9.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_9.stopped')
            sound_vowels_9.stop()
    
    # *text_41* updates
    if text_41.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_41.frameNStart = frameN  # exact frame index
        text_41.tStart = t  # local t and not account for scr refresh
        text_41.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_41, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_41.started')
        text_41.setAutoDraw(True)
    if text_41.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_41.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_41.tStop = t  # not accounting for scr refresh
            text_41.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_41.stopped')
            text_41.setAutoDraw(False)
    
    # *text_42* updates
    if text_42.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_42.frameNStart = frameN  # exact frame index
        text_42.tStart = t  # local t and not account for scr refresh
        text_42.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_42, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_42.started')
        text_42.setAutoDraw(True)
    if text_42.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_42.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_42.tStop = t  # not accounting for scr refresh
            text_42.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_42.stopped')
            text_42.setAutoDraw(False)
    
    # *text_43* updates
    if text_43.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_43.frameNStart = frameN  # exact frame index
        text_43.tStart = t  # local t and not account for scr refresh
        text_43.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_43, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_43.started')
        text_43.setAutoDraw(True)
    if text_43.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_43.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_43.tStop = t  # not accounting for scr refresh
            text_43.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_43.stopped')
            text_43.setAutoDraw(False)
    
    # *text_44* updates
    if text_44.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_44.frameNStart = frameN  # exact frame index
        text_44.tStart = t  # local t and not account for scr refresh
        text_44.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_44, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_44.started')
        text_44.setAutoDraw(True)
    if text_44.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_44.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_44.tStop = t  # not accounting for scr refresh
            text_44.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_44.stopped')
            text_44.setAutoDraw(False)
    
    # *text_45* updates
    if text_45.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_45.frameNStart = frameN  # exact frame index
        text_45.tStart = t  # local t and not account for scr refresh
        text_45.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_45, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_45.started')
        text_45.setAutoDraw(True)
    if text_45.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_45.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_45.tStop = t  # not accounting for scr refresh
            text_45.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_45.stopped')
            text_45.setAutoDraw(False)
    
    # *key_resp_9* updates
    waitOnFlip = False
    if key_resp_9.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_9.frameNStart = frameN  # exact frame index
        key_resp_9.tStart = t  # local t and not account for scr refresh
        key_resp_9.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_9, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_9.started')
        key_resp_9.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_9.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_9.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_9.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_9.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_9.tStop = t  # not accounting for scr refresh
            key_resp_9.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_9.stopped')
            key_resp_9.status = FINISHED
    if key_resp_9.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_9.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_9_allKeys.extend(theseKeys)
        if len(_key_resp_9_allKeys):
            key_resp_9.keys = _key_resp_9_allKeys[-1].name  # just the last key pressed
            key_resp_9.rt = _key_resp_9_allKeys[-1].rt
            # was this correct?
            if (key_resp_9.keys == str('y')) or (key_resp_9.keys == 'y'):
                key_resp_9.corr = 1
            else:
                key_resp_9.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "A" ---
for thisComponent in AComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_9.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_9.keys in ['', [], None]:  # No response was made
    key_resp_9.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_9.corr = 1;  # correct non-response
    else:
       key_resp_9.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_9.keys',key_resp_9.keys)
thisExp.addData('key_resp_9.corr', key_resp_9.corr)
if key_resp_9.keys != None:  # we had a response
    thisExp.addData('key_resp_9.rt', key_resp_9.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_japsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_63.setSound('mainpairs/sa.ja+japsa.wav', secs=3.5, hamming=True)
sound_vowels_63.setVolume(1.0, log=False)
key_resp_63.keys = []
key_resp_63.rt = []
_key_resp_63_allKeys = []
# keep track of which components have finished
sa_ja_japsaComponents = [sound_vowels_63, text_311, text_312, text_313, text_314, text_315, key_resp_63]
for thisComponent in sa_ja_japsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_japsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_63
    if sound_vowels_63.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_63.frameNStart = frameN  # exact frame index
        sound_vowels_63.tStart = t  # local t and not account for scr refresh
        sound_vowels_63.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_63.started', tThisFlipGlobal)
        sound_vowels_63.play(when=win)  # sync with win flip
    if sound_vowels_63.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_63.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_63.tStop = t  # not accounting for scr refresh
            sound_vowels_63.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_63.stopped')
            sound_vowels_63.stop()
    
    # *text_311* updates
    if text_311.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_311.frameNStart = frameN  # exact frame index
        text_311.tStart = t  # local t and not account for scr refresh
        text_311.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_311, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_311.started')
        text_311.setAutoDraw(True)
    if text_311.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_311.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_311.tStop = t  # not accounting for scr refresh
            text_311.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_311.stopped')
            text_311.setAutoDraw(False)
    
    # *text_312* updates
    if text_312.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_312.frameNStart = frameN  # exact frame index
        text_312.tStart = t  # local t and not account for scr refresh
        text_312.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_312, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_312.started')
        text_312.setAutoDraw(True)
    if text_312.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_312.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_312.tStop = t  # not accounting for scr refresh
            text_312.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_312.stopped')
            text_312.setAutoDraw(False)
    
    # *text_313* updates
    if text_313.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_313.frameNStart = frameN  # exact frame index
        text_313.tStart = t  # local t and not account for scr refresh
        text_313.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_313, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_313.started')
        text_313.setAutoDraw(True)
    if text_313.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_313.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_313.tStop = t  # not accounting for scr refresh
            text_313.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_313.stopped')
            text_313.setAutoDraw(False)
    
    # *text_314* updates
    if text_314.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_314.frameNStart = frameN  # exact frame index
        text_314.tStart = t  # local t and not account for scr refresh
        text_314.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_314, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_314.started')
        text_314.setAutoDraw(True)
    if text_314.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_314.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_314.tStop = t  # not accounting for scr refresh
            text_314.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_314.stopped')
            text_314.setAutoDraw(False)
    
    # *text_315* updates
    if text_315.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_315.frameNStart = frameN  # exact frame index
        text_315.tStart = t  # local t and not account for scr refresh
        text_315.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_315, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_315.started')
        text_315.setAutoDraw(True)
    if text_315.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_315.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_315.tStop = t  # not accounting for scr refresh
            text_315.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_315.stopped')
            text_315.setAutoDraw(False)
    
    # *key_resp_63* updates
    waitOnFlip = False
    if key_resp_63.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_63.frameNStart = frameN  # exact frame index
        key_resp_63.tStart = t  # local t and not account for scr refresh
        key_resp_63.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_63, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_63.started')
        key_resp_63.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_63.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_63.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_63.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_63.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_63.tStop = t  # not accounting for scr refresh
            key_resp_63.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_63.stopped')
            key_resp_63.status = FINISHED
    if key_resp_63.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_63.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_63_allKeys.extend(theseKeys)
        if len(_key_resp_63_allKeys):
            key_resp_63.keys = _key_resp_63_allKeys[-1].name  # just the last key pressed
            key_resp_63.rt = _key_resp_63_allKeys[-1].rt
            # was this correct?
            if (key_resp_63.keys == str('n')) or (key_resp_63.keys == 'n'):
                key_resp_63.corr = 1
            else:
                key_resp_63.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_japsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_japsa" ---
for thisComponent in sa_ja_japsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_63.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_63.keys in ['', [], None]:  # No response was made
    key_resp_63.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_63.corr = 1;  # correct non-response
    else:
       key_resp_63.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_63.keys',key_resp_63.keys)
thisExp.addData('key_resp_63.corr', key_resp_63.corr)
if key_resp_63.keys != None:  # we had a response
    thisExp.addData('key_resp_63.rt', key_resp_63.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "Apsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_20.setSound('mainpairs/Apsa.wav', secs=3.5, hamming=True)
sound_vowels_20.setVolume(1.0, log=False)
key_resp_20.keys = []
key_resp_20.rt = []
_key_resp_20_allKeys = []
# keep track of which components have finished
ApsaComponents = [sound_vowels_20, text_96, text_97, text_98, text_99, text_100, key_resp_20]
for thisComponent in ApsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "Apsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_20
    if sound_vowels_20.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_20.frameNStart = frameN  # exact frame index
        sound_vowels_20.tStart = t  # local t and not account for scr refresh
        sound_vowels_20.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_20.started', tThisFlipGlobal)
        sound_vowels_20.play(when=win)  # sync with win flip
    if sound_vowels_20.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_20.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_20.tStop = t  # not accounting for scr refresh
            sound_vowels_20.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_20.stopped')
            sound_vowels_20.stop()
    
    # *text_96* updates
    if text_96.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_96.frameNStart = frameN  # exact frame index
        text_96.tStart = t  # local t and not account for scr refresh
        text_96.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_96, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_96.started')
        text_96.setAutoDraw(True)
    if text_96.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_96.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_96.tStop = t  # not accounting for scr refresh
            text_96.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_96.stopped')
            text_96.setAutoDraw(False)
    
    # *text_97* updates
    if text_97.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_97.frameNStart = frameN  # exact frame index
        text_97.tStart = t  # local t and not account for scr refresh
        text_97.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_97, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_97.started')
        text_97.setAutoDraw(True)
    if text_97.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_97.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_97.tStop = t  # not accounting for scr refresh
            text_97.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_97.stopped')
            text_97.setAutoDraw(False)
    
    # *text_98* updates
    if text_98.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_98.frameNStart = frameN  # exact frame index
        text_98.tStart = t  # local t and not account for scr refresh
        text_98.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_98, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_98.started')
        text_98.setAutoDraw(True)
    if text_98.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_98.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_98.tStop = t  # not accounting for scr refresh
            text_98.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_98.stopped')
            text_98.setAutoDraw(False)
    
    # *text_99* updates
    if text_99.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_99.frameNStart = frameN  # exact frame index
        text_99.tStart = t  # local t and not account for scr refresh
        text_99.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_99, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_99.started')
        text_99.setAutoDraw(True)
    if text_99.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_99.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_99.tStop = t  # not accounting for scr refresh
            text_99.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_99.stopped')
            text_99.setAutoDraw(False)
    
    # *text_100* updates
    if text_100.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_100.frameNStart = frameN  # exact frame index
        text_100.tStart = t  # local t and not account for scr refresh
        text_100.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_100, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_100.started')
        text_100.setAutoDraw(True)
    if text_100.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_100.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_100.tStop = t  # not accounting for scr refresh
            text_100.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_100.stopped')
            text_100.setAutoDraw(False)
    
    # *key_resp_20* updates
    waitOnFlip = False
    if key_resp_20.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_20.frameNStart = frameN  # exact frame index
        key_resp_20.tStart = t  # local t and not account for scr refresh
        key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_20.started')
        key_resp_20.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_20.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_20.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_20.tStop = t  # not accounting for scr refresh
            key_resp_20.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_20.stopped')
            key_resp_20.status = FINISHED
    if key_resp_20.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_20.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_20_allKeys.extend(theseKeys)
        if len(_key_resp_20_allKeys):
            key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
            key_resp_20.rt = _key_resp_20_allKeys[-1].rt
            # was this correct?
            if (key_resp_20.keys == str('n')) or (key_resp_20.keys == 'n'):
                key_resp_20.corr = 1
            else:
                key_resp_20.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in ApsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "Apsa" ---
for thisComponent in ApsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_20.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_20.keys in ['', [], None]:  # No response was made
    key_resp_20.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_20.corr = 1;  # correct non-response
    else:
       key_resp_20.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_20.keys',key_resp_20.keys)
thisExp.addData('key_resp_20.corr', key_resp_20.corr)
if key_resp_20.keys != None:  # we had a response
    thisExp.addData('key_resp_20.rt', key_resp_20.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa_ja_sa_japsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_65.setSound('mainpairs/sa.ja+sa.japsa.wav', secs=3.5, hamming=True)
sound_vowels_65.setVolume(1.0, log=False)
key_resp_65.keys = []
key_resp_65.rt = []
_key_resp_65_allKeys = []
# keep track of which components have finished
sa_ja_sa_japsaComponents = [sound_vowels_65, text_321, text_322, text_323, text_324, text_325, key_resp_65]
for thisComponent in sa_ja_sa_japsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa_ja_sa_japsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_65
    if sound_vowels_65.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_65.frameNStart = frameN  # exact frame index
        sound_vowels_65.tStart = t  # local t and not account for scr refresh
        sound_vowels_65.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_65.started', tThisFlipGlobal)
        sound_vowels_65.play(when=win)  # sync with win flip
    if sound_vowels_65.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_65.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_65.tStop = t  # not accounting for scr refresh
            sound_vowels_65.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_65.stopped')
            sound_vowels_65.stop()
    
    # *text_321* updates
    if text_321.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_321.frameNStart = frameN  # exact frame index
        text_321.tStart = t  # local t and not account for scr refresh
        text_321.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_321, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_321.started')
        text_321.setAutoDraw(True)
    if text_321.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_321.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_321.tStop = t  # not accounting for scr refresh
            text_321.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_321.stopped')
            text_321.setAutoDraw(False)
    
    # *text_322* updates
    if text_322.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_322.frameNStart = frameN  # exact frame index
        text_322.tStart = t  # local t and not account for scr refresh
        text_322.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_322, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_322.started')
        text_322.setAutoDraw(True)
    if text_322.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_322.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_322.tStop = t  # not accounting for scr refresh
            text_322.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_322.stopped')
            text_322.setAutoDraw(False)
    
    # *text_323* updates
    if text_323.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_323.frameNStart = frameN  # exact frame index
        text_323.tStart = t  # local t and not account for scr refresh
        text_323.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_323, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_323.started')
        text_323.setAutoDraw(True)
    if text_323.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_323.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_323.tStop = t  # not accounting for scr refresh
            text_323.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_323.stopped')
            text_323.setAutoDraw(False)
    
    # *text_324* updates
    if text_324.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_324.frameNStart = frameN  # exact frame index
        text_324.tStart = t  # local t and not account for scr refresh
        text_324.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_324, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_324.started')
        text_324.setAutoDraw(True)
    if text_324.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_324.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_324.tStop = t  # not accounting for scr refresh
            text_324.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_324.stopped')
            text_324.setAutoDraw(False)
    
    # *text_325* updates
    if text_325.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_325.frameNStart = frameN  # exact frame index
        text_325.tStart = t  # local t and not account for scr refresh
        text_325.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_325, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_325.started')
        text_325.setAutoDraw(True)
    if text_325.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_325.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_325.tStop = t  # not accounting for scr refresh
            text_325.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_325.stopped')
            text_325.setAutoDraw(False)
    
    # *key_resp_65* updates
    waitOnFlip = False
    if key_resp_65.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_65.frameNStart = frameN  # exact frame index
        key_resp_65.tStart = t  # local t and not account for scr refresh
        key_resp_65.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_65, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_65.started')
        key_resp_65.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_65.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_65.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_65.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_65.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_65.tStop = t  # not accounting for scr refresh
            key_resp_65.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_65.stopped')
            key_resp_65.status = FINISHED
    if key_resp_65.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_65.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_65_allKeys.extend(theseKeys)
        if len(_key_resp_65_allKeys):
            key_resp_65.keys = _key_resp_65_allKeys[-1].name  # just the last key pressed
            key_resp_65.rt = _key_resp_65_allKeys[-1].rt
            # was this correct?
            if (key_resp_65.keys == str('n')) or (key_resp_65.keys == 'n'):
                key_resp_65.corr = 1
            else:
                key_resp_65.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in sa_ja_sa_japsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa_ja_sa_japsa" ---
for thisComponent in sa_ja_sa_japsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_65.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_65.keys in ['', [], None]:  # No response was made
    key_resp_65.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_65.corr = 1;  # correct non-response
    else:
       key_resp_65.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_65.keys',key_resp_65.keys)
thisExp.addData('key_resp_65.corr', key_resp_65.corr)
if key_resp_65.keys != None:  # we had a response
    thisExp.addData('key_resp_65.rt', key_resp_65.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "A_jo_A" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_11.setSound('mainpairs/A+jo.A.wav', secs=3.5, hamming=True)
sound_vowels_11.setVolume(1.0, log=False)
key_resp_11.keys = []
key_resp_11.rt = []
_key_resp_11_allKeys = []
# keep track of which components have finished
A_jo_AComponents = [sound_vowels_11, text_51, text_52, text_53, text_54, text_55, key_resp_11]
for thisComponent in A_jo_AComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "A_jo_A" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_11
    if sound_vowels_11.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_11.frameNStart = frameN  # exact frame index
        sound_vowels_11.tStart = t  # local t and not account for scr refresh
        sound_vowels_11.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_11.started', tThisFlipGlobal)
        sound_vowels_11.play(when=win)  # sync with win flip
    if sound_vowels_11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_11.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_11.tStop = t  # not accounting for scr refresh
            sound_vowels_11.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_11.stopped')
            sound_vowels_11.stop()
    
    # *text_51* updates
    if text_51.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_51.frameNStart = frameN  # exact frame index
        text_51.tStart = t  # local t and not account for scr refresh
        text_51.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_51, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_51.started')
        text_51.setAutoDraw(True)
    if text_51.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_51.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_51.tStop = t  # not accounting for scr refresh
            text_51.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_51.stopped')
            text_51.setAutoDraw(False)
    
    # *text_52* updates
    if text_52.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_52.frameNStart = frameN  # exact frame index
        text_52.tStart = t  # local t and not account for scr refresh
        text_52.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_52, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_52.started')
        text_52.setAutoDraw(True)
    if text_52.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_52.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_52.tStop = t  # not accounting for scr refresh
            text_52.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_52.stopped')
            text_52.setAutoDraw(False)
    
    # *text_53* updates
    if text_53.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_53.frameNStart = frameN  # exact frame index
        text_53.tStart = t  # local t and not account for scr refresh
        text_53.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_53, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_53.started')
        text_53.setAutoDraw(True)
    if text_53.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_53.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_53.tStop = t  # not accounting for scr refresh
            text_53.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_53.stopped')
            text_53.setAutoDraw(False)
    
    # *text_54* updates
    if text_54.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_54.frameNStart = frameN  # exact frame index
        text_54.tStart = t  # local t and not account for scr refresh
        text_54.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_54, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_54.started')
        text_54.setAutoDraw(True)
    if text_54.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_54.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_54.tStop = t  # not accounting for scr refresh
            text_54.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_54.stopped')
            text_54.setAutoDraw(False)
    
    # *text_55* updates
    if text_55.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_55.frameNStart = frameN  # exact frame index
        text_55.tStart = t  # local t and not account for scr refresh
        text_55.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_55, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_55.started')
        text_55.setAutoDraw(True)
    if text_55.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_55.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_55.tStop = t  # not accounting for scr refresh
            text_55.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_55.stopped')
            text_55.setAutoDraw(False)
    
    # *key_resp_11* updates
    waitOnFlip = False
    if key_resp_11.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_11.frameNStart = frameN  # exact frame index
        key_resp_11.tStart = t  # local t and not account for scr refresh
        key_resp_11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_11, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_11.started')
        key_resp_11.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_11.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_11.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_11.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_11.tStop = t  # not accounting for scr refresh
            key_resp_11.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_11.stopped')
            key_resp_11.status = FINISHED
    if key_resp_11.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_11.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_11_allKeys.extend(theseKeys)
        if len(_key_resp_11_allKeys):
            key_resp_11.keys = _key_resp_11_allKeys[-1].name  # just the last key pressed
            key_resp_11.rt = _key_resp_11_allKeys[-1].rt
            # was this correct?
            if (key_resp_11.keys == str('y')) or (key_resp_11.keys == 'y'):
                key_resp_11.corr = 1
            else:
                key_resp_11.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in A_jo_AComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "A_jo_A" ---
for thisComponent in A_jo_AComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_11.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_11.keys in ['', [], None]:  # No response was made
    key_resp_11.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_11.corr = 1;  # correct non-response
    else:
       key_resp_11.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_11.keys',key_resp_11.keys)
thisExp.addData('key_resp_11.corr', key_resp_11.corr)
if key_resp_11.keys != None:  # we had a response
    thisExp.addData('key_resp_11.rt', key_resp_11.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "jo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_27.setSound('mainpairs/jo.wav', secs=3.5, hamming=True)
sound_vowels_27.setVolume(1.0, log=False)
key_resp_27.keys = []
key_resp_27.rt = []
_key_resp_27_allKeys = []
# keep track of which components have finished
joComponents = [sound_vowels_27, text_131, text_132, text_133, text_134, text_135, key_resp_27]
for thisComponent in joComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "jo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_27
    if sound_vowels_27.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_27.frameNStart = frameN  # exact frame index
        sound_vowels_27.tStart = t  # local t and not account for scr refresh
        sound_vowels_27.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_27.started', tThisFlipGlobal)
        sound_vowels_27.play(when=win)  # sync with win flip
    if sound_vowels_27.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_27.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_27.tStop = t  # not accounting for scr refresh
            sound_vowels_27.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_27.stopped')
            sound_vowels_27.stop()
    
    # *text_131* updates
    if text_131.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_131.frameNStart = frameN  # exact frame index
        text_131.tStart = t  # local t and not account for scr refresh
        text_131.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_131, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_131.started')
        text_131.setAutoDraw(True)
    if text_131.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_131.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_131.tStop = t  # not accounting for scr refresh
            text_131.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_131.stopped')
            text_131.setAutoDraw(False)
    
    # *text_132* updates
    if text_132.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_132.frameNStart = frameN  # exact frame index
        text_132.tStart = t  # local t and not account for scr refresh
        text_132.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_132, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_132.started')
        text_132.setAutoDraw(True)
    if text_132.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_132.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_132.tStop = t  # not accounting for scr refresh
            text_132.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_132.stopped')
            text_132.setAutoDraw(False)
    
    # *text_133* updates
    if text_133.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_133.frameNStart = frameN  # exact frame index
        text_133.tStart = t  # local t and not account for scr refresh
        text_133.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_133, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_133.started')
        text_133.setAutoDraw(True)
    if text_133.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_133.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_133.tStop = t  # not accounting for scr refresh
            text_133.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_133.stopped')
            text_133.setAutoDraw(False)
    
    # *text_134* updates
    if text_134.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_134.frameNStart = frameN  # exact frame index
        text_134.tStart = t  # local t and not account for scr refresh
        text_134.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_134, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_134.started')
        text_134.setAutoDraw(True)
    if text_134.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_134.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_134.tStop = t  # not accounting for scr refresh
            text_134.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_134.stopped')
            text_134.setAutoDraw(False)
    
    # *text_135* updates
    if text_135.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_135.frameNStart = frameN  # exact frame index
        text_135.tStart = t  # local t and not account for scr refresh
        text_135.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_135, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_135.started')
        text_135.setAutoDraw(True)
    if text_135.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_135.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_135.tStop = t  # not accounting for scr refresh
            text_135.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_135.stopped')
            text_135.setAutoDraw(False)
    
    # *key_resp_27* updates
    waitOnFlip = False
    if key_resp_27.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_27.frameNStart = frameN  # exact frame index
        key_resp_27.tStart = t  # local t and not account for scr refresh
        key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_27.started')
        key_resp_27.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_27.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_27.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_27.tStop = t  # not accounting for scr refresh
            key_resp_27.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_27.stopped')
            key_resp_27.status = FINISHED
    if key_resp_27.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_27.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_27_allKeys.extend(theseKeys)
        if len(_key_resp_27_allKeys):
            key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
            key_resp_27.rt = _key_resp_27_allKeys[-1].rt
            # was this correct?
            if (key_resp_27.keys == str('y')) or (key_resp_27.keys == 'y'):
                key_resp_27.corr = 1
            else:
                key_resp_27.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in joComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "jo" ---
for thisComponent in joComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_27.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_27.keys in ['', [], None]:  # No response was made
    key_resp_27.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_27.corr = 1;  # correct non-response
    else:
       key_resp_27.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_27.keys',key_resp_27.keys)
thisExp.addData('key_resp_27.corr', key_resp_27.corr)
if key_resp_27.keys != None:  # we had a response
    thisExp.addData('key_resp_27.rt', key_resp_27.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "so" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_29.setSound('mainpairs/so.wav', secs=3.5, hamming=True)
sound_vowels_29.setVolume(1.0, log=False)
key_resp_29.keys = []
key_resp_29.rt = []
_key_resp_29_allKeys = []
# keep track of which components have finished
soComponents = [sound_vowels_29, text_141, text_142, text_143, text_144, text_145, key_resp_29]
for thisComponent in soComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "so" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_29
    if sound_vowels_29.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_29.frameNStart = frameN  # exact frame index
        sound_vowels_29.tStart = t  # local t and not account for scr refresh
        sound_vowels_29.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_29.started', tThisFlipGlobal)
        sound_vowels_29.play(when=win)  # sync with win flip
    if sound_vowels_29.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_29.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_29.tStop = t  # not accounting for scr refresh
            sound_vowels_29.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_29.stopped')
            sound_vowels_29.stop()
    
    # *text_141* updates
    if text_141.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_141.frameNStart = frameN  # exact frame index
        text_141.tStart = t  # local t and not account for scr refresh
        text_141.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_141, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_141.started')
        text_141.setAutoDraw(True)
    if text_141.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_141.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_141.tStop = t  # not accounting for scr refresh
            text_141.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_141.stopped')
            text_141.setAutoDraw(False)
    
    # *text_142* updates
    if text_142.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_142.frameNStart = frameN  # exact frame index
        text_142.tStart = t  # local t and not account for scr refresh
        text_142.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_142, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_142.started')
        text_142.setAutoDraw(True)
    if text_142.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_142.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_142.tStop = t  # not accounting for scr refresh
            text_142.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_142.stopped')
            text_142.setAutoDraw(False)
    
    # *text_143* updates
    if text_143.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_143.frameNStart = frameN  # exact frame index
        text_143.tStart = t  # local t and not account for scr refresh
        text_143.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_143, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_143.started')
        text_143.setAutoDraw(True)
    if text_143.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_143.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_143.tStop = t  # not accounting for scr refresh
            text_143.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_143.stopped')
            text_143.setAutoDraw(False)
    
    # *text_144* updates
    if text_144.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_144.frameNStart = frameN  # exact frame index
        text_144.tStart = t  # local t and not account for scr refresh
        text_144.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_144, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_144.started')
        text_144.setAutoDraw(True)
    if text_144.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_144.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_144.tStop = t  # not accounting for scr refresh
            text_144.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_144.stopped')
            text_144.setAutoDraw(False)
    
    # *text_145* updates
    if text_145.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_145.frameNStart = frameN  # exact frame index
        text_145.tStart = t  # local t and not account for scr refresh
        text_145.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_145, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_145.started')
        text_145.setAutoDraw(True)
    if text_145.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_145.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_145.tStop = t  # not accounting for scr refresh
            text_145.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_145.stopped')
            text_145.setAutoDraw(False)
    
    # *key_resp_29* updates
    waitOnFlip = False
    if key_resp_29.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_29.frameNStart = frameN  # exact frame index
        key_resp_29.tStart = t  # local t and not account for scr refresh
        key_resp_29.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_29, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_29.started')
        key_resp_29.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_29.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_29.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_29.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_29.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_29.tStop = t  # not accounting for scr refresh
            key_resp_29.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_29.stopped')
            key_resp_29.status = FINISHED
    if key_resp_29.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_29.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_29_allKeys.extend(theseKeys)
        if len(_key_resp_29_allKeys):
            key_resp_29.keys = _key_resp_29_allKeys[-1].name  # just the last key pressed
            key_resp_29.rt = _key_resp_29_allKeys[-1].rt
            # was this correct?
            if (key_resp_29.keys == str('y')) or (key_resp_29.keys == 'y'):
                key_resp_29.corr = 1
            else:
                key_resp_29.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in soComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "so" ---
for thisComponent in soComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_29.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_29.keys in ['', [], None]:  # No response was made
    key_resp_29.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_29.corr = 1;  # correct non-response
    else:
       key_resp_29.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_29.keys',key_resp_29.keys)
thisExp.addData('key_resp_29.corr', key_resp_29.corr)
if key_resp_29.keys != None:  # we had a response
    thisExp.addData('key_resp_29.rt', key_resp_29.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "joja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_28.setSound('mainpairs/joja.wav', secs=3.5, hamming=True)
sound_vowels_28.setVolume(1.0, log=False)
key_resp_28.keys = []
key_resp_28.rt = []
_key_resp_28_allKeys = []
# keep track of which components have finished
jojaComponents = [sound_vowels_28, text_136, text_137, text_138, text_139, text_140, key_resp_28]
for thisComponent in jojaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "joja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_28
    if sound_vowels_28.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_28.frameNStart = frameN  # exact frame index
        sound_vowels_28.tStart = t  # local t and not account for scr refresh
        sound_vowels_28.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_28.started', tThisFlipGlobal)
        sound_vowels_28.play(when=win)  # sync with win flip
    if sound_vowels_28.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_28.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_28.tStop = t  # not accounting for scr refresh
            sound_vowels_28.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_28.stopped')
            sound_vowels_28.stop()
    
    # *text_136* updates
    if text_136.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_136.frameNStart = frameN  # exact frame index
        text_136.tStart = t  # local t and not account for scr refresh
        text_136.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_136, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_136.started')
        text_136.setAutoDraw(True)
    if text_136.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_136.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_136.tStop = t  # not accounting for scr refresh
            text_136.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_136.stopped')
            text_136.setAutoDraw(False)
    
    # *text_137* updates
    if text_137.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_137.frameNStart = frameN  # exact frame index
        text_137.tStart = t  # local t and not account for scr refresh
        text_137.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_137, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_137.started')
        text_137.setAutoDraw(True)
    if text_137.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_137.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_137.tStop = t  # not accounting for scr refresh
            text_137.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_137.stopped')
            text_137.setAutoDraw(False)
    
    # *text_138* updates
    if text_138.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_138.frameNStart = frameN  # exact frame index
        text_138.tStart = t  # local t and not account for scr refresh
        text_138.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_138, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_138.started')
        text_138.setAutoDraw(True)
    if text_138.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_138.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_138.tStop = t  # not accounting for scr refresh
            text_138.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_138.stopped')
            text_138.setAutoDraw(False)
    
    # *text_139* updates
    if text_139.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_139.frameNStart = frameN  # exact frame index
        text_139.tStart = t  # local t and not account for scr refresh
        text_139.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_139, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_139.started')
        text_139.setAutoDraw(True)
    if text_139.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_139.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_139.tStop = t  # not accounting for scr refresh
            text_139.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_139.stopped')
            text_139.setAutoDraw(False)
    
    # *text_140* updates
    if text_140.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_140.frameNStart = frameN  # exact frame index
        text_140.tStart = t  # local t and not account for scr refresh
        text_140.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_140, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_140.started')
        text_140.setAutoDraw(True)
    if text_140.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_140.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_140.tStop = t  # not accounting for scr refresh
            text_140.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_140.stopped')
            text_140.setAutoDraw(False)
    
    # *key_resp_28* updates
    waitOnFlip = False
    if key_resp_28.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_28.frameNStart = frameN  # exact frame index
        key_resp_28.tStart = t  # local t and not account for scr refresh
        key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_28.started')
        key_resp_28.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_28.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_28.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_28.tStop = t  # not accounting for scr refresh
            key_resp_28.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_28.stopped')
            key_resp_28.status = FINISHED
    if key_resp_28.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_28.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_28_allKeys.extend(theseKeys)
        if len(_key_resp_28_allKeys):
            key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
            key_resp_28.rt = _key_resp_28_allKeys[-1].rt
            # was this correct?
            if (key_resp_28.keys == str('n')) or (key_resp_28.keys == 'n'):
                key_resp_28.corr = 1
            else:
                key_resp_28.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jojaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "joja" ---
for thisComponent in jojaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_28.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_28.keys in ['', [], None]:  # No response was made
    key_resp_28.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_28.corr = 1;  # correct non-response
    else:
       key_resp_28.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_28.keys',key_resp_28.keys)
thisExp.addData('key_resp_28.corr', key_resp_28.corr)
if key_resp_28.keys != None:  # we had a response
    thisExp.addData('key_resp_28.rt', key_resp_28.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "ja" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_26.setSound('mainpairs/ja.wav', secs=3.5, hamming=True)
sound_vowels_26.setVolume(1.0, log=False)
key_resp_26.keys = []
key_resp_26.rt = []
_key_resp_26_allKeys = []
# keep track of which components have finished
jaComponents = [sound_vowels_26, text_126, text_127, text_128, text_129, text_130, key_resp_26]
for thisComponent in jaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "ja" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_26
    if sound_vowels_26.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_26.frameNStart = frameN  # exact frame index
        sound_vowels_26.tStart = t  # local t and not account for scr refresh
        sound_vowels_26.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_26.started', tThisFlipGlobal)
        sound_vowels_26.play(when=win)  # sync with win flip
    if sound_vowels_26.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_26.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_26.tStop = t  # not accounting for scr refresh
            sound_vowels_26.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_26.stopped')
            sound_vowels_26.stop()
    
    # *text_126* updates
    if text_126.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_126.frameNStart = frameN  # exact frame index
        text_126.tStart = t  # local t and not account for scr refresh
        text_126.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_126, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_126.started')
        text_126.setAutoDraw(True)
    if text_126.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_126.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_126.tStop = t  # not accounting for scr refresh
            text_126.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_126.stopped')
            text_126.setAutoDraw(False)
    
    # *text_127* updates
    if text_127.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_127.frameNStart = frameN  # exact frame index
        text_127.tStart = t  # local t and not account for scr refresh
        text_127.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_127, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_127.started')
        text_127.setAutoDraw(True)
    if text_127.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_127.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_127.tStop = t  # not accounting for scr refresh
            text_127.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_127.stopped')
            text_127.setAutoDraw(False)
    
    # *text_128* updates
    if text_128.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_128.frameNStart = frameN  # exact frame index
        text_128.tStart = t  # local t and not account for scr refresh
        text_128.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_128, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_128.started')
        text_128.setAutoDraw(True)
    if text_128.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_128.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_128.tStop = t  # not accounting for scr refresh
            text_128.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_128.stopped')
            text_128.setAutoDraw(False)
    
    # *text_129* updates
    if text_129.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_129.frameNStart = frameN  # exact frame index
        text_129.tStart = t  # local t and not account for scr refresh
        text_129.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_129, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_129.started')
        text_129.setAutoDraw(True)
    if text_129.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_129.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_129.tStop = t  # not accounting for scr refresh
            text_129.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_129.stopped')
            text_129.setAutoDraw(False)
    
    # *text_130* updates
    if text_130.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_130.frameNStart = frameN  # exact frame index
        text_130.tStart = t  # local t and not account for scr refresh
        text_130.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_130, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_130.started')
        text_130.setAutoDraw(True)
    if text_130.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_130.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_130.tStop = t  # not accounting for scr refresh
            text_130.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_130.stopped')
            text_130.setAutoDraw(False)
    
    # *key_resp_26* updates
    waitOnFlip = False
    if key_resp_26.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_26.frameNStart = frameN  # exact frame index
        key_resp_26.tStart = t  # local t and not account for scr refresh
        key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_26.started')
        key_resp_26.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_26.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_26.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_26.tStop = t  # not accounting for scr refresh
            key_resp_26.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_26.stopped')
            key_resp_26.status = FINISHED
    if key_resp_26.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_26.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_26_allKeys.extend(theseKeys)
        if len(_key_resp_26_allKeys):
            key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
            key_resp_26.rt = _key_resp_26_allKeys[-1].rt
            # was this correct?
            if (key_resp_26.keys == str('y')) or (key_resp_26.keys == 'y'):
                key_resp_26.corr = 1
            else:
                key_resp_26.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in jaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "ja" ---
for thisComponent in jaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_26.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_26.keys in ['', [], None]:  # No response was made
    key_resp_26.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_26.corr = 1;  # correct non-response
    else:
       key_resp_26.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_26.keys',key_resp_26.keys)
thisExp.addData('key_resp_26.corr', key_resp_26.corr)
if key_resp_26.keys != None:  # we had a response
    thisExp.addData('key_resp_26.rt', key_resp_26.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AsasapA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_25.setSound('mainpairs/AsasapA.wav', secs=3.5, hamming=True)
sound_vowels_25.setVolume(1.0, log=False)
key_resp_25.keys = []
key_resp_25.rt = []
_key_resp_25_allKeys = []
# keep track of which components have finished
AsasapAComponents = [sound_vowels_25, text_121, text_122, text_123, text_124, text_125, key_resp_25]
for thisComponent in AsasapAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AsasapA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_25
    if sound_vowels_25.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_25.frameNStart = frameN  # exact frame index
        sound_vowels_25.tStart = t  # local t and not account for scr refresh
        sound_vowels_25.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_25.started', tThisFlipGlobal)
        sound_vowels_25.play(when=win)  # sync with win flip
    if sound_vowels_25.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_25.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_25.tStop = t  # not accounting for scr refresh
            sound_vowels_25.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_25.stopped')
            sound_vowels_25.stop()
    
    # *text_121* updates
    if text_121.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_121.frameNStart = frameN  # exact frame index
        text_121.tStart = t  # local t and not account for scr refresh
        text_121.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_121, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_121.started')
        text_121.setAutoDraw(True)
    if text_121.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_121.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_121.tStop = t  # not accounting for scr refresh
            text_121.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_121.stopped')
            text_121.setAutoDraw(False)
    
    # *text_122* updates
    if text_122.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_122.frameNStart = frameN  # exact frame index
        text_122.tStart = t  # local t and not account for scr refresh
        text_122.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_122, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_122.started')
        text_122.setAutoDraw(True)
    if text_122.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_122.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_122.tStop = t  # not accounting for scr refresh
            text_122.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_122.stopped')
            text_122.setAutoDraw(False)
    
    # *text_123* updates
    if text_123.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_123.frameNStart = frameN  # exact frame index
        text_123.tStart = t  # local t and not account for scr refresh
        text_123.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_123, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_123.started')
        text_123.setAutoDraw(True)
    if text_123.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_123.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_123.tStop = t  # not accounting for scr refresh
            text_123.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_123.stopped')
            text_123.setAutoDraw(False)
    
    # *text_124* updates
    if text_124.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_124.frameNStart = frameN  # exact frame index
        text_124.tStart = t  # local t and not account for scr refresh
        text_124.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_124, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_124.started')
        text_124.setAutoDraw(True)
    if text_124.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_124.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_124.tStop = t  # not accounting for scr refresh
            text_124.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_124.stopped')
            text_124.setAutoDraw(False)
    
    # *text_125* updates
    if text_125.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_125.frameNStart = frameN  # exact frame index
        text_125.tStart = t  # local t and not account for scr refresh
        text_125.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_125, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_125.started')
        text_125.setAutoDraw(True)
    if text_125.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_125.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_125.tStop = t  # not accounting for scr refresh
            text_125.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_125.stopped')
            text_125.setAutoDraw(False)
    
    # *key_resp_25* updates
    waitOnFlip = False
    if key_resp_25.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_25.frameNStart = frameN  # exact frame index
        key_resp_25.tStart = t  # local t and not account for scr refresh
        key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_25.started')
        key_resp_25.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_25.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_25.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_25.tStop = t  # not accounting for scr refresh
            key_resp_25.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_25.stopped')
            key_resp_25.status = FINISHED
    if key_resp_25.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_25.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_25_allKeys.extend(theseKeys)
        if len(_key_resp_25_allKeys):
            key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
            key_resp_25.rt = _key_resp_25_allKeys[-1].rt
            # was this correct?
            if (key_resp_25.keys == str('n')) or (key_resp_25.keys == 'n'):
                key_resp_25.corr = 1
            else:
                key_resp_25.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AsasapAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AsasapA" ---
for thisComponent in AsasapAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_25.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_25.keys in ['', [], None]:  # No response was made
    key_resp_25.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_25.corr = 1;  # correct non-response
    else:
       key_resp_25.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_25.keys',key_resp_25.keys)
thisExp.addData('key_resp_25.corr', key_resp_25.corr)
if key_resp_25.keys != None:  # we had a response
    thisExp.addData('key_resp_25.rt', key_resp_25.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AjoApA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_14.setSound('mainpairs/AjoApA.wav', secs=3.5, hamming=True)
sound_vowels_14.setVolume(1.0, log=False)
key_resp_14.keys = []
key_resp_14.rt = []
_key_resp_14_allKeys = []
# keep track of which components have finished
AjoApAComponents = [sound_vowels_14, text_66, text_67, text_68, text_69, text_70, key_resp_14]
for thisComponent in AjoApAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AjoApA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_14
    if sound_vowels_14.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_14.frameNStart = frameN  # exact frame index
        sound_vowels_14.tStart = t  # local t and not account for scr refresh
        sound_vowels_14.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_14.started', tThisFlipGlobal)
        sound_vowels_14.play(when=win)  # sync with win flip
    if sound_vowels_14.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_14.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_14.tStop = t  # not accounting for scr refresh
            sound_vowels_14.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_14.stopped')
            sound_vowels_14.stop()
    
    # *text_66* updates
    if text_66.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_66.frameNStart = frameN  # exact frame index
        text_66.tStart = t  # local t and not account for scr refresh
        text_66.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_66, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_66.started')
        text_66.setAutoDraw(True)
    if text_66.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_66.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_66.tStop = t  # not accounting for scr refresh
            text_66.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_66.stopped')
            text_66.setAutoDraw(False)
    
    # *text_67* updates
    if text_67.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_67.frameNStart = frameN  # exact frame index
        text_67.tStart = t  # local t and not account for scr refresh
        text_67.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_67, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_67.started')
        text_67.setAutoDraw(True)
    if text_67.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_67.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_67.tStop = t  # not accounting for scr refresh
            text_67.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_67.stopped')
            text_67.setAutoDraw(False)
    
    # *text_68* updates
    if text_68.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_68.frameNStart = frameN  # exact frame index
        text_68.tStart = t  # local t and not account for scr refresh
        text_68.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_68, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_68.started')
        text_68.setAutoDraw(True)
    if text_68.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_68.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_68.tStop = t  # not accounting for scr refresh
            text_68.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_68.stopped')
            text_68.setAutoDraw(False)
    
    # *text_69* updates
    if text_69.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_69.frameNStart = frameN  # exact frame index
        text_69.tStart = t  # local t and not account for scr refresh
        text_69.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_69, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_69.started')
        text_69.setAutoDraw(True)
    if text_69.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_69.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_69.tStop = t  # not accounting for scr refresh
            text_69.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_69.stopped')
            text_69.setAutoDraw(False)
    
    # *text_70* updates
    if text_70.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_70.frameNStart = frameN  # exact frame index
        text_70.tStart = t  # local t and not account for scr refresh
        text_70.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_70, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_70.started')
        text_70.setAutoDraw(True)
    if text_70.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_70.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_70.tStop = t  # not accounting for scr refresh
            text_70.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_70.stopped')
            text_70.setAutoDraw(False)
    
    # *key_resp_14* updates
    waitOnFlip = False
    if key_resp_14.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_14.frameNStart = frameN  # exact frame index
        key_resp_14.tStart = t  # local t and not account for scr refresh
        key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_14.started')
        key_resp_14.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_14.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_14.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_14.tStop = t  # not accounting for scr refresh
            key_resp_14.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_14.stopped')
            key_resp_14.status = FINISHED
    if key_resp_14.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_14.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_14_allKeys.extend(theseKeys)
        if len(_key_resp_14_allKeys):
            key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
            key_resp_14.rt = _key_resp_14_allKeys[-1].rt
            # was this correct?
            if (key_resp_14.keys == str('n')) or (key_resp_14.keys == 'n'):
                key_resp_14.corr = 1
            else:
                key_resp_14.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AjoApAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AjoApA" ---
for thisComponent in AjoApAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_14.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_14.keys in ['', [], None]:  # No response was made
    key_resp_14.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_14.corr = 1;  # correct non-response
    else:
       key_resp_14.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_14.keys',key_resp_14.keys)
thisExp.addData('key_resp_14.corr', key_resp_14.corr)
if key_resp_14.keys != None:  # we had a response
    thisExp.addData('key_resp_14.rt', key_resp_14.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "A_A_sa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_10.setSound('mainpairs/A+A.sa.wav', secs=3.5, hamming=True)
sound_vowels_10.setVolume(1.0, log=False)
key_resp_10.keys = []
key_resp_10.rt = []
_key_resp_10_allKeys = []
# keep track of which components have finished
A_A_saComponents = [sound_vowels_10, text_46, text_47, text_48, text_49, text_50, key_resp_10]
for thisComponent in A_A_saComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "A_A_sa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_10
    if sound_vowels_10.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_10.frameNStart = frameN  # exact frame index
        sound_vowels_10.tStart = t  # local t and not account for scr refresh
        sound_vowels_10.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_10.started', tThisFlipGlobal)
        sound_vowels_10.play(when=win)  # sync with win flip
    if sound_vowels_10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_10.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_10.tStop = t  # not accounting for scr refresh
            sound_vowels_10.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_10.stopped')
            sound_vowels_10.stop()
    
    # *text_46* updates
    if text_46.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_46.frameNStart = frameN  # exact frame index
        text_46.tStart = t  # local t and not account for scr refresh
        text_46.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_46, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_46.started')
        text_46.setAutoDraw(True)
    if text_46.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_46.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_46.tStop = t  # not accounting for scr refresh
            text_46.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_46.stopped')
            text_46.setAutoDraw(False)
    
    # *text_47* updates
    if text_47.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_47.frameNStart = frameN  # exact frame index
        text_47.tStart = t  # local t and not account for scr refresh
        text_47.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_47, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_47.started')
        text_47.setAutoDraw(True)
    if text_47.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_47.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_47.tStop = t  # not accounting for scr refresh
            text_47.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_47.stopped')
            text_47.setAutoDraw(False)
    
    # *text_48* updates
    if text_48.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_48.frameNStart = frameN  # exact frame index
        text_48.tStart = t  # local t and not account for scr refresh
        text_48.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_48, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_48.started')
        text_48.setAutoDraw(True)
    if text_48.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_48.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_48.tStop = t  # not accounting for scr refresh
            text_48.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_48.stopped')
            text_48.setAutoDraw(False)
    
    # *text_49* updates
    if text_49.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_49.frameNStart = frameN  # exact frame index
        text_49.tStart = t  # local t and not account for scr refresh
        text_49.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_49, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_49.started')
        text_49.setAutoDraw(True)
    if text_49.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_49.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_49.tStop = t  # not accounting for scr refresh
            text_49.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_49.stopped')
            text_49.setAutoDraw(False)
    
    # *text_50* updates
    if text_50.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_50.frameNStart = frameN  # exact frame index
        text_50.tStart = t  # local t and not account for scr refresh
        text_50.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_50, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_50.started')
        text_50.setAutoDraw(True)
    if text_50.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_50.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_50.tStop = t  # not accounting for scr refresh
            text_50.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_50.stopped')
            text_50.setAutoDraw(False)
    
    # *key_resp_10* updates
    waitOnFlip = False
    if key_resp_10.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_10.frameNStart = frameN  # exact frame index
        key_resp_10.tStart = t  # local t and not account for scr refresh
        key_resp_10.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_10, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_10.started')
        key_resp_10.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_10.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_10.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_10.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_10.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_10.tStop = t  # not accounting for scr refresh
            key_resp_10.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_10.stopped')
            key_resp_10.status = FINISHED
    if key_resp_10.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_10.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_10_allKeys.extend(theseKeys)
        if len(_key_resp_10_allKeys):
            key_resp_10.keys = _key_resp_10_allKeys[-1].name  # just the last key pressed
            key_resp_10.rt = _key_resp_10_allKeys[-1].rt
            # was this correct?
            if (key_resp_10.keys == str('y')) or (key_resp_10.keys == 'y'):
                key_resp_10.corr = 1
            else:
                key_resp_10.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in A_A_saComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "A_A_sa" ---
for thisComponent in A_A_saComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_10.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_10.keys in ['', [], None]:  # No response was made
    key_resp_10.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_10.corr = 1;  # correct non-response
    else:
       key_resp_10.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_10.keys',key_resp_10.keys)
thisExp.addData('key_resp_10.corr', key_resp_10.corr)
if key_resp_10.keys != None:  # we had a response
    thisExp.addData('key_resp_10.rt', key_resp_10.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "sa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_30.setSound('mainpairs/sa.wav', secs=3.5, hamming=True)
sound_vowels_30.setVolume(1.0, log=False)
key_resp_30.keys = []
key_resp_30.rt = []
_key_resp_30_allKeys = []
# keep track of which components have finished
saComponents = [sound_vowels_30, text_146, text_147, text_148, text_149, text_150, key_resp_30]
for thisComponent in saComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "sa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_30
    if sound_vowels_30.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_30.frameNStart = frameN  # exact frame index
        sound_vowels_30.tStart = t  # local t and not account for scr refresh
        sound_vowels_30.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_30.started', tThisFlipGlobal)
        sound_vowels_30.play(when=win)  # sync with win flip
    if sound_vowels_30.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_30.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_30.tStop = t  # not accounting for scr refresh
            sound_vowels_30.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_30.stopped')
            sound_vowels_30.stop()
    
    # *text_146* updates
    if text_146.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_146.frameNStart = frameN  # exact frame index
        text_146.tStart = t  # local t and not account for scr refresh
        text_146.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_146, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_146.started')
        text_146.setAutoDraw(True)
    if text_146.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_146.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_146.tStop = t  # not accounting for scr refresh
            text_146.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_146.stopped')
            text_146.setAutoDraw(False)
    
    # *text_147* updates
    if text_147.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_147.frameNStart = frameN  # exact frame index
        text_147.tStart = t  # local t and not account for scr refresh
        text_147.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_147, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_147.started')
        text_147.setAutoDraw(True)
    if text_147.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_147.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_147.tStop = t  # not accounting for scr refresh
            text_147.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_147.stopped')
            text_147.setAutoDraw(False)
    
    # *text_148* updates
    if text_148.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_148.frameNStart = frameN  # exact frame index
        text_148.tStart = t  # local t and not account for scr refresh
        text_148.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_148, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_148.started')
        text_148.setAutoDraw(True)
    if text_148.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_148.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_148.tStop = t  # not accounting for scr refresh
            text_148.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_148.stopped')
            text_148.setAutoDraw(False)
    
    # *text_149* updates
    if text_149.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_149.frameNStart = frameN  # exact frame index
        text_149.tStart = t  # local t and not account for scr refresh
        text_149.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_149, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_149.started')
        text_149.setAutoDraw(True)
    if text_149.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_149.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_149.tStop = t  # not accounting for scr refresh
            text_149.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_149.stopped')
            text_149.setAutoDraw(False)
    
    # *text_150* updates
    if text_150.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_150.frameNStart = frameN  # exact frame index
        text_150.tStart = t  # local t and not account for scr refresh
        text_150.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_150, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_150.started')
        text_150.setAutoDraw(True)
    if text_150.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_150.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_150.tStop = t  # not accounting for scr refresh
            text_150.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_150.stopped')
            text_150.setAutoDraw(False)
    
    # *key_resp_30* updates
    waitOnFlip = False
    if key_resp_30.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_30.frameNStart = frameN  # exact frame index
        key_resp_30.tStart = t  # local t and not account for scr refresh
        key_resp_30.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_30, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_30.started')
        key_resp_30.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_30.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_30.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_30.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_30.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_30.tStop = t  # not accounting for scr refresh
            key_resp_30.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_30.stopped')
            key_resp_30.status = FINISHED
    if key_resp_30.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_30.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_30_allKeys.extend(theseKeys)
        if len(_key_resp_30_allKeys):
            key_resp_30.keys = _key_resp_30_allKeys[-1].name  # just the last key pressed
            key_resp_30.rt = _key_resp_30_allKeys[-1].rt
            # was this correct?
            if (key_resp_30.keys == str('y')) or (key_resp_30.keys == 'y'):
                key_resp_30.corr = 1
            else:
                key_resp_30.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in saComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "sa" ---
for thisComponent in saComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_30.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_30.keys in ['', [], None]:  # No response was made
    key_resp_30.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_30.corr = 1;  # correct non-response
    else:
       key_resp_30.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_30.keys',key_resp_30.keys)
thisExp.addData('key_resp_30.corr', key_resp_30.corr)
if key_resp_30.keys != None:  # we had a response
    thisExp.addData('key_resp_30.rt', key_resp_30.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AsaAsapA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_23.setSound('mainpairs/AsaAsapA.wav', secs=3.5, hamming=True)
sound_vowels_23.setVolume(1.0, log=False)
key_resp_23.keys = []
key_resp_23.rt = []
_key_resp_23_allKeys = []
# keep track of which components have finished
AsaAsapAComponents = [sound_vowels_23, text_111, text_112, text_113, text_114, text_115, key_resp_23]
for thisComponent in AsaAsapAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AsaAsapA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_23
    if sound_vowels_23.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_23.frameNStart = frameN  # exact frame index
        sound_vowels_23.tStart = t  # local t and not account for scr refresh
        sound_vowels_23.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_23.started', tThisFlipGlobal)
        sound_vowels_23.play(when=win)  # sync with win flip
    if sound_vowels_23.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_23.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_23.tStop = t  # not accounting for scr refresh
            sound_vowels_23.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_23.stopped')
            sound_vowels_23.stop()
    
    # *text_111* updates
    if text_111.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_111.frameNStart = frameN  # exact frame index
        text_111.tStart = t  # local t and not account for scr refresh
        text_111.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_111, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_111.started')
        text_111.setAutoDraw(True)
    if text_111.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_111.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_111.tStop = t  # not accounting for scr refresh
            text_111.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_111.stopped')
            text_111.setAutoDraw(False)
    
    # *text_112* updates
    if text_112.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_112.frameNStart = frameN  # exact frame index
        text_112.tStart = t  # local t and not account for scr refresh
        text_112.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_112, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_112.started')
        text_112.setAutoDraw(True)
    if text_112.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_112.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_112.tStop = t  # not accounting for scr refresh
            text_112.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_112.stopped')
            text_112.setAutoDraw(False)
    
    # *text_113* updates
    if text_113.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_113.frameNStart = frameN  # exact frame index
        text_113.tStart = t  # local t and not account for scr refresh
        text_113.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_113, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_113.started')
        text_113.setAutoDraw(True)
    if text_113.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_113.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_113.tStop = t  # not accounting for scr refresh
            text_113.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_113.stopped')
            text_113.setAutoDraw(False)
    
    # *text_114* updates
    if text_114.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_114.frameNStart = frameN  # exact frame index
        text_114.tStart = t  # local t and not account for scr refresh
        text_114.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_114, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_114.started')
        text_114.setAutoDraw(True)
    if text_114.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_114.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_114.tStop = t  # not accounting for scr refresh
            text_114.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_114.stopped')
            text_114.setAutoDraw(False)
    
    # *text_115* updates
    if text_115.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_115.frameNStart = frameN  # exact frame index
        text_115.tStart = t  # local t and not account for scr refresh
        text_115.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_115, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_115.started')
        text_115.setAutoDraw(True)
    if text_115.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_115.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_115.tStop = t  # not accounting for scr refresh
            text_115.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_115.stopped')
            text_115.setAutoDraw(False)
    
    # *key_resp_23* updates
    waitOnFlip = False
    if key_resp_23.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_23.frameNStart = frameN  # exact frame index
        key_resp_23.tStart = t  # local t and not account for scr refresh
        key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_23.started')
        key_resp_23.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_23.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_23.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_23.tStop = t  # not accounting for scr refresh
            key_resp_23.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_23.stopped')
            key_resp_23.status = FINISHED
    if key_resp_23.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_23.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_23_allKeys.extend(theseKeys)
        if len(_key_resp_23_allKeys):
            key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
            key_resp_23.rt = _key_resp_23_allKeys[-1].rt
            # was this correct?
            if (key_resp_23.keys == str('n')) or (key_resp_23.keys == 'n'):
                key_resp_23.corr = 1
            else:
                key_resp_23.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AsaAsapAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AsaAsapA" ---
for thisComponent in AsaAsapAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_23.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_23.keys in ['', [], None]:  # No response was made
    key_resp_23.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_23.corr = 1;  # correct non-response
    else:
       key_resp_23.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_23.keys',key_resp_23.keys)
thisExp.addData('key_resp_23.corr', key_resp_23.corr)
if key_resp_23.keys != None:  # we had a response
    thisExp.addData('key_resp_23.rt', key_resp_23.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "usousopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_15.setSound('mainpairs/usousopso.wav', secs=3.5, hamming=True)
sound_vowels_15.setVolume(1.0, log=False)
key_resp_15.keys = []
key_resp_15.rt = []
_key_resp_15_allKeys = []
# keep track of which components have finished
usousopsoComponents = [sound_vowels_15, text_71, text_72, text_73, text_74, text_75, key_resp_15]
for thisComponent in usousopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "usousopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_15
    if sound_vowels_15.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_15.frameNStart = frameN  # exact frame index
        sound_vowels_15.tStart = t  # local t and not account for scr refresh
        sound_vowels_15.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_15.started', tThisFlipGlobal)
        sound_vowels_15.play(when=win)  # sync with win flip
    if sound_vowels_15.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_15.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_15.tStop = t  # not accounting for scr refresh
            sound_vowels_15.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_15.stopped')
            sound_vowels_15.stop()
    
    # *text_71* updates
    if text_71.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_71.frameNStart = frameN  # exact frame index
        text_71.tStart = t  # local t and not account for scr refresh
        text_71.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_71, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_71.started')
        text_71.setAutoDraw(True)
    if text_71.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_71.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_71.tStop = t  # not accounting for scr refresh
            text_71.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_71.stopped')
            text_71.setAutoDraw(False)
    
    # *text_72* updates
    if text_72.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_72.frameNStart = frameN  # exact frame index
        text_72.tStart = t  # local t and not account for scr refresh
        text_72.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_72, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_72.started')
        text_72.setAutoDraw(True)
    if text_72.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_72.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_72.tStop = t  # not accounting for scr refresh
            text_72.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_72.stopped')
            text_72.setAutoDraw(False)
    
    # *text_73* updates
    if text_73.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_73.frameNStart = frameN  # exact frame index
        text_73.tStart = t  # local t and not account for scr refresh
        text_73.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_73, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_73.started')
        text_73.setAutoDraw(True)
    if text_73.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_73.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_73.tStop = t  # not accounting for scr refresh
            text_73.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_73.stopped')
            text_73.setAutoDraw(False)
    
    # *text_74* updates
    if text_74.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_74.frameNStart = frameN  # exact frame index
        text_74.tStart = t  # local t and not account for scr refresh
        text_74.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_74, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_74.started')
        text_74.setAutoDraw(True)
    if text_74.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_74.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_74.tStop = t  # not accounting for scr refresh
            text_74.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_74.stopped')
            text_74.setAutoDraw(False)
    
    # *text_75* updates
    if text_75.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_75.frameNStart = frameN  # exact frame index
        text_75.tStart = t  # local t and not account for scr refresh
        text_75.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_75, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_75.started')
        text_75.setAutoDraw(True)
    if text_75.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_75.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_75.tStop = t  # not accounting for scr refresh
            text_75.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_75.stopped')
            text_75.setAutoDraw(False)
    
    # *key_resp_15* updates
    waitOnFlip = False
    if key_resp_15.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_15.frameNStart = frameN  # exact frame index
        key_resp_15.tStart = t  # local t and not account for scr refresh
        key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_15.started')
        key_resp_15.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_15.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_15.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_15.tStop = t  # not accounting for scr refresh
            key_resp_15.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_15.stopped')
            key_resp_15.status = FINISHED
    if key_resp_15.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_15.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_15_allKeys.extend(theseKeys)
        if len(_key_resp_15_allKeys):
            key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
            key_resp_15.rt = _key_resp_15_allKeys[-1].rt
            # was this correct?
            if (key_resp_15.keys == str('n')) or (key_resp_15.keys == 'n'):
                key_resp_15.corr = 1
            else:
                key_resp_15.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in usousopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "usousopso" ---
for thisComponent in usousopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_15.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_15.keys in ['', [], None]:  # No response was made
    key_resp_15.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_15.corr = 1;  # correct non-response
    else:
       key_resp_15.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_15.keys',key_resp_15.keys)
thisExp.addData('key_resp_15.corr', key_resp_15.corr)
if key_resp_15.keys != None:  # we had a response
    thisExp.addData('key_resp_15.rt', key_resp_15.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AAsapA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_12.setSound('mainpairs/AAsapA.wav', secs=3.5, hamming=True)
sound_vowels_12.setVolume(1.0, log=False)
key_resp_12.keys = []
key_resp_12.rt = []
_key_resp_12_allKeys = []
# keep track of which components have finished
AAsapAComponents = [sound_vowels_12, text_56, text_57, text_58, text_59, text_60, key_resp_12]
for thisComponent in AAsapAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AAsapA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_12
    if sound_vowels_12.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_12.frameNStart = frameN  # exact frame index
        sound_vowels_12.tStart = t  # local t and not account for scr refresh
        sound_vowels_12.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_12.started', tThisFlipGlobal)
        sound_vowels_12.play(when=win)  # sync with win flip
    if sound_vowels_12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_12.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_12.tStop = t  # not accounting for scr refresh
            sound_vowels_12.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_12.stopped')
            sound_vowels_12.stop()
    
    # *text_56* updates
    if text_56.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_56.frameNStart = frameN  # exact frame index
        text_56.tStart = t  # local t and not account for scr refresh
        text_56.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_56, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_56.started')
        text_56.setAutoDraw(True)
    if text_56.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_56.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_56.tStop = t  # not accounting for scr refresh
            text_56.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_56.stopped')
            text_56.setAutoDraw(False)
    
    # *text_57* updates
    if text_57.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_57.frameNStart = frameN  # exact frame index
        text_57.tStart = t  # local t and not account for scr refresh
        text_57.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_57, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_57.started')
        text_57.setAutoDraw(True)
    if text_57.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_57.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_57.tStop = t  # not accounting for scr refresh
            text_57.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_57.stopped')
            text_57.setAutoDraw(False)
    
    # *text_58* updates
    if text_58.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_58.frameNStart = frameN  # exact frame index
        text_58.tStart = t  # local t and not account for scr refresh
        text_58.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_58, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_58.started')
        text_58.setAutoDraw(True)
    if text_58.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_58.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_58.tStop = t  # not accounting for scr refresh
            text_58.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_58.stopped')
            text_58.setAutoDraw(False)
    
    # *text_59* updates
    if text_59.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_59.frameNStart = frameN  # exact frame index
        text_59.tStart = t  # local t and not account for scr refresh
        text_59.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_59, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_59.started')
        text_59.setAutoDraw(True)
    if text_59.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_59.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_59.tStop = t  # not accounting for scr refresh
            text_59.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_59.stopped')
            text_59.setAutoDraw(False)
    
    # *text_60* updates
    if text_60.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_60.frameNStart = frameN  # exact frame index
        text_60.tStart = t  # local t and not account for scr refresh
        text_60.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_60, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_60.started')
        text_60.setAutoDraw(True)
    if text_60.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_60.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_60.tStop = t  # not accounting for scr refresh
            text_60.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_60.stopped')
            text_60.setAutoDraw(False)
    
    # *key_resp_12* updates
    waitOnFlip = False
    if key_resp_12.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_12.frameNStart = frameN  # exact frame index
        key_resp_12.tStart = t  # local t and not account for scr refresh
        key_resp_12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_12, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_12.started')
        key_resp_12.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_12.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_12.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_12.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_12.tStop = t  # not accounting for scr refresh
            key_resp_12.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_12.stopped')
            key_resp_12.status = FINISHED
    if key_resp_12.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_12.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_12_allKeys.extend(theseKeys)
        if len(_key_resp_12_allKeys):
            key_resp_12.keys = _key_resp_12_allKeys[-1].name  # just the last key pressed
            key_resp_12.rt = _key_resp_12_allKeys[-1].rt
            # was this correct?
            if (key_resp_12.keys == str('n')) or (key_resp_12.keys == 'n'):
                key_resp_12.corr = 1
            else:
                key_resp_12.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AAsapAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AAsapA" ---
for thisComponent in AAsapAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_12.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_12.keys in ['', [], None]:  # No response was made
    key_resp_12.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_12.corr = 1;  # correct non-response
    else:
       key_resp_12.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_12.keys',key_resp_12.keys)
thisExp.addData('key_resp_12.corr', key_resp_12.corr)
if key_resp_12.keys != None:  # we had a response
    thisExp.addData('key_resp_12.rt', key_resp_12.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AjoApjo" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_19.setSound('mainpairs/AjoApjo.wav', secs=3.5, hamming=True)
sound_vowels_19.setVolume(1.0, log=False)
key_resp_19.keys = []
key_resp_19.rt = []
_key_resp_19_allKeys = []
# keep track of which components have finished
AjoApjoComponents = [sound_vowels_19, text_91, text_92, text_93, text_94, text_95, key_resp_19]
for thisComponent in AjoApjoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AjoApjo" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_19
    if sound_vowels_19.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_19.frameNStart = frameN  # exact frame index
        sound_vowels_19.tStart = t  # local t and not account for scr refresh
        sound_vowels_19.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_19.started', tThisFlipGlobal)
        sound_vowels_19.play(when=win)  # sync with win flip
    if sound_vowels_19.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_19.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_19.tStop = t  # not accounting for scr refresh
            sound_vowels_19.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_19.stopped')
            sound_vowels_19.stop()
    
    # *text_91* updates
    if text_91.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_91.frameNStart = frameN  # exact frame index
        text_91.tStart = t  # local t and not account for scr refresh
        text_91.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_91, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_91.started')
        text_91.setAutoDraw(True)
    if text_91.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_91.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_91.tStop = t  # not accounting for scr refresh
            text_91.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_91.stopped')
            text_91.setAutoDraw(False)
    
    # *text_92* updates
    if text_92.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_92.frameNStart = frameN  # exact frame index
        text_92.tStart = t  # local t and not account for scr refresh
        text_92.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_92, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_92.started')
        text_92.setAutoDraw(True)
    if text_92.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_92.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_92.tStop = t  # not accounting for scr refresh
            text_92.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_92.stopped')
            text_92.setAutoDraw(False)
    
    # *text_93* updates
    if text_93.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_93.frameNStart = frameN  # exact frame index
        text_93.tStart = t  # local t and not account for scr refresh
        text_93.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_93, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_93.started')
        text_93.setAutoDraw(True)
    if text_93.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_93.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_93.tStop = t  # not accounting for scr refresh
            text_93.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_93.stopped')
            text_93.setAutoDraw(False)
    
    # *text_94* updates
    if text_94.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_94.frameNStart = frameN  # exact frame index
        text_94.tStart = t  # local t and not account for scr refresh
        text_94.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_94, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_94.started')
        text_94.setAutoDraw(True)
    if text_94.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_94.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_94.tStop = t  # not accounting for scr refresh
            text_94.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_94.stopped')
            text_94.setAutoDraw(False)
    
    # *text_95* updates
    if text_95.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_95.frameNStart = frameN  # exact frame index
        text_95.tStart = t  # local t and not account for scr refresh
        text_95.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_95, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_95.started')
        text_95.setAutoDraw(True)
    if text_95.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_95.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_95.tStop = t  # not accounting for scr refresh
            text_95.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_95.stopped')
            text_95.setAutoDraw(False)
    
    # *key_resp_19* updates
    waitOnFlip = False
    if key_resp_19.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_19.frameNStart = frameN  # exact frame index
        key_resp_19.tStart = t  # local t and not account for scr refresh
        key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_19.started')
        key_resp_19.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_19.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_19.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_19.tStop = t  # not accounting for scr refresh
            key_resp_19.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_19.stopped')
            key_resp_19.status = FINISHED
    if key_resp_19.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_19.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_19_allKeys.extend(theseKeys)
        if len(_key_resp_19_allKeys):
            key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
            key_resp_19.rt = _key_resp_19_allKeys[-1].rt
            # was this correct?
            if (key_resp_19.keys == str('n')) or (key_resp_19.keys == 'n'):
                key_resp_19.corr = 1
            else:
                key_resp_19.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AjoApjoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AjoApjo" ---
for thisComponent in AjoApjoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_19.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_19.keys in ['', [], None]:  # No response was made
    key_resp_19.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_19.corr = 1;  # correct non-response
    else:
       key_resp_19.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_19.keys',key_resp_19.keys)
thisExp.addData('key_resp_19.corr', key_resp_19.corr)
if key_resp_19.keys != None:  # we had a response
    thisExp.addData('key_resp_19.rt', key_resp_19.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AAsapsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_13.setSound('mainpairs/AAsapsa.wav', secs=3.5, hamming=True)
sound_vowels_13.setVolume(1.0, log=False)
key_resp_13.keys = []
key_resp_13.rt = []
_key_resp_13_allKeys = []
# keep track of which components have finished
AAsapsaComponents = [sound_vowels_13, text_61, text_62, text_63, text_64, text_65, key_resp_13]
for thisComponent in AAsapsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AAsapsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_13
    if sound_vowels_13.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_13.frameNStart = frameN  # exact frame index
        sound_vowels_13.tStart = t  # local t and not account for scr refresh
        sound_vowels_13.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_13.started', tThisFlipGlobal)
        sound_vowels_13.play(when=win)  # sync with win flip
    if sound_vowels_13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_13.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_13.tStop = t  # not accounting for scr refresh
            sound_vowels_13.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_13.stopped')
            sound_vowels_13.stop()
    
    # *text_61* updates
    if text_61.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_61.frameNStart = frameN  # exact frame index
        text_61.tStart = t  # local t and not account for scr refresh
        text_61.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_61, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_61.started')
        text_61.setAutoDraw(True)
    if text_61.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_61.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_61.tStop = t  # not accounting for scr refresh
            text_61.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_61.stopped')
            text_61.setAutoDraw(False)
    
    # *text_62* updates
    if text_62.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_62.frameNStart = frameN  # exact frame index
        text_62.tStart = t  # local t and not account for scr refresh
        text_62.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_62, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_62.started')
        text_62.setAutoDraw(True)
    if text_62.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_62.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_62.tStop = t  # not accounting for scr refresh
            text_62.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_62.stopped')
            text_62.setAutoDraw(False)
    
    # *text_63* updates
    if text_63.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_63.frameNStart = frameN  # exact frame index
        text_63.tStart = t  # local t and not account for scr refresh
        text_63.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_63, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_63.started')
        text_63.setAutoDraw(True)
    if text_63.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_63.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_63.tStop = t  # not accounting for scr refresh
            text_63.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_63.stopped')
            text_63.setAutoDraw(False)
    
    # *text_64* updates
    if text_64.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_64.frameNStart = frameN  # exact frame index
        text_64.tStart = t  # local t and not account for scr refresh
        text_64.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_64, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_64.started')
        text_64.setAutoDraw(True)
    if text_64.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_64.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_64.tStop = t  # not accounting for scr refresh
            text_64.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_64.stopped')
            text_64.setAutoDraw(False)
    
    # *text_65* updates
    if text_65.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_65.frameNStart = frameN  # exact frame index
        text_65.tStart = t  # local t and not account for scr refresh
        text_65.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_65, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_65.started')
        text_65.setAutoDraw(True)
    if text_65.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_65.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_65.tStop = t  # not accounting for scr refresh
            text_65.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_65.stopped')
            text_65.setAutoDraw(False)
    
    # *key_resp_13* updates
    waitOnFlip = False
    if key_resp_13.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_13.frameNStart = frameN  # exact frame index
        key_resp_13.tStart = t  # local t and not account for scr refresh
        key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_13.started')
        key_resp_13.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_13.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_13.tStop = t  # not accounting for scr refresh
            key_resp_13.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_13.stopped')
            key_resp_13.status = FINISHED
    if key_resp_13.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_13.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_13_allKeys.extend(theseKeys)
        if len(_key_resp_13_allKeys):
            key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
            key_resp_13.rt = _key_resp_13_allKeys[-1].rt
            # was this correct?
            if (key_resp_13.keys == str('n')) or (key_resp_13.keys == 'n'):
                key_resp_13.corr = 1
            else:
                key_resp_13.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AAsapsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AAsapsa" ---
for thisComponent in AAsapsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_13.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_13.keys in ['', [], None]:  # No response was made
    key_resp_13.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_13.corr = 1;  # correct non-response
    else:
       key_resp_13.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_13.keys',key_resp_13.keys)
thisExp.addData('key_resp_13.corr', key_resp_13.corr)
if key_resp_13.keys != None:  # we had a response
    thisExp.addData('key_resp_13.rt', key_resp_13.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "usosopso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_17.setSound('mainpairs/usosopso.wav', secs=3.5, hamming=True)
sound_vowels_17.setVolume(1.0, log=False)
key_resp_17.keys = []
key_resp_17.rt = []
_key_resp_17_allKeys = []
# keep track of which components have finished
usosopsoComponents = [sound_vowels_17, text_81, text_82, text_83, text_84, text_85, key_resp_17]
for thisComponent in usosopsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "usosopso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_17
    if sound_vowels_17.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_17.frameNStart = frameN  # exact frame index
        sound_vowels_17.tStart = t  # local t and not account for scr refresh
        sound_vowels_17.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_17.started', tThisFlipGlobal)
        sound_vowels_17.play(when=win)  # sync with win flip
    if sound_vowels_17.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_17.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_17.tStop = t  # not accounting for scr refresh
            sound_vowels_17.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_17.stopped')
            sound_vowels_17.stop()
    
    # *text_81* updates
    if text_81.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_81.frameNStart = frameN  # exact frame index
        text_81.tStart = t  # local t and not account for scr refresh
        text_81.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_81, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_81.started')
        text_81.setAutoDraw(True)
    if text_81.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_81.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_81.tStop = t  # not accounting for scr refresh
            text_81.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_81.stopped')
            text_81.setAutoDraw(False)
    
    # *text_82* updates
    if text_82.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_82.frameNStart = frameN  # exact frame index
        text_82.tStart = t  # local t and not account for scr refresh
        text_82.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_82, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_82.started')
        text_82.setAutoDraw(True)
    if text_82.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_82.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_82.tStop = t  # not accounting for scr refresh
            text_82.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_82.stopped')
            text_82.setAutoDraw(False)
    
    # *text_83* updates
    if text_83.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_83.frameNStart = frameN  # exact frame index
        text_83.tStart = t  # local t and not account for scr refresh
        text_83.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_83, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_83.started')
        text_83.setAutoDraw(True)
    if text_83.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_83.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_83.tStop = t  # not accounting for scr refresh
            text_83.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_83.stopped')
            text_83.setAutoDraw(False)
    
    # *text_84* updates
    if text_84.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_84.frameNStart = frameN  # exact frame index
        text_84.tStart = t  # local t and not account for scr refresh
        text_84.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_84, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_84.started')
        text_84.setAutoDraw(True)
    if text_84.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_84.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_84.tStop = t  # not accounting for scr refresh
            text_84.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_84.stopped')
            text_84.setAutoDraw(False)
    
    # *text_85* updates
    if text_85.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_85.frameNStart = frameN  # exact frame index
        text_85.tStart = t  # local t and not account for scr refresh
        text_85.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_85, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_85.started')
        text_85.setAutoDraw(True)
    if text_85.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_85.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_85.tStop = t  # not accounting for scr refresh
            text_85.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_85.stopped')
            text_85.setAutoDraw(False)
    
    # *key_resp_17* updates
    waitOnFlip = False
    if key_resp_17.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_17.frameNStart = frameN  # exact frame index
        key_resp_17.tStart = t  # local t and not account for scr refresh
        key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_17.started')
        key_resp_17.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_17.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_17.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_17.tStop = t  # not accounting for scr refresh
            key_resp_17.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_17.stopped')
            key_resp_17.status = FINISHED
    if key_resp_17.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_17.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_17_allKeys.extend(theseKeys)
        if len(_key_resp_17_allKeys):
            key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
            key_resp_17.rt = _key_resp_17_allKeys[-1].rt
            # was this correct?
            if (key_resp_17.keys == str('n')) or (key_resp_17.keys == 'n'):
                key_resp_17.corr = 1
            else:
                key_resp_17.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in usosopsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "usosopso" ---
for thisComponent in usosopsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_17.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_17.keys in ['', [], None]:  # No response was made
    key_resp_17.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_17.corr = 1;  # correct non-response
    else:
       key_resp_17.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_17.keys',key_resp_17.keys)
thisExp.addData('key_resp_17.corr', key_resp_17.corr)
if key_resp_17.keys != None:  # we had a response
    thisExp.addData('key_resp_17.rt', key_resp_17.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "A_sa_A_" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_3.setSound('mainpairs/A.sa+A.wav', secs=3.5, hamming=True)
sound_vowels_3.setVolume(1.0, log=False)
key_resp_3.keys = []
key_resp_3.rt = []
_key_resp_3_allKeys = []
# keep track of which components have finished
A_sa_A_Components = [sound_vowels_3, text_11, text_12, text_13, text_14, text_15, key_resp_3]
for thisComponent in A_sa_A_Components:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "A_sa_A_" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_3
    if sound_vowels_3.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_3.frameNStart = frameN  # exact frame index
        sound_vowels_3.tStart = t  # local t and not account for scr refresh
        sound_vowels_3.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_3.started', tThisFlipGlobal)
        sound_vowels_3.play(when=win)  # sync with win flip
    if sound_vowels_3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_3.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_3.tStop = t  # not accounting for scr refresh
            sound_vowels_3.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_3.stopped')
            sound_vowels_3.stop()
    
    # *text_11* updates
    if text_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_11.frameNStart = frameN  # exact frame index
        text_11.tStart = t  # local t and not account for scr refresh
        text_11.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_11, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_11.started')
        text_11.setAutoDraw(True)
    if text_11.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_11.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_11.tStop = t  # not accounting for scr refresh
            text_11.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_11.stopped')
            text_11.setAutoDraw(False)
    
    # *text_12* updates
    if text_12.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_12.frameNStart = frameN  # exact frame index
        text_12.tStart = t  # local t and not account for scr refresh
        text_12.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_12, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_12.started')
        text_12.setAutoDraw(True)
    if text_12.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_12.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_12.tStop = t  # not accounting for scr refresh
            text_12.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_12.stopped')
            text_12.setAutoDraw(False)
    
    # *text_13* updates
    if text_13.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_13.frameNStart = frameN  # exact frame index
        text_13.tStart = t  # local t and not account for scr refresh
        text_13.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_13, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_13.started')
        text_13.setAutoDraw(True)
    if text_13.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_13.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_13.tStop = t  # not accounting for scr refresh
            text_13.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_13.stopped')
            text_13.setAutoDraw(False)
    
    # *text_14* updates
    if text_14.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_14.frameNStart = frameN  # exact frame index
        text_14.tStart = t  # local t and not account for scr refresh
        text_14.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_14, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_14.started')
        text_14.setAutoDraw(True)
    if text_14.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_14.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_14.tStop = t  # not accounting for scr refresh
            text_14.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_14.stopped')
            text_14.setAutoDraw(False)
    
    # *text_15* updates
    if text_15.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_15.frameNStart = frameN  # exact frame index
        text_15.tStart = t  # local t and not account for scr refresh
        text_15.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_15, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_15.started')
        text_15.setAutoDraw(True)
    if text_15.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_15.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_15.tStop = t  # not accounting for scr refresh
            text_15.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_15.stopped')
            text_15.setAutoDraw(False)
    
    # *key_resp_3* updates
    waitOnFlip = False
    if key_resp_3.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_3.frameNStart = frameN  # exact frame index
        key_resp_3.tStart = t  # local t and not account for scr refresh
        key_resp_3.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_3, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_3.started')
        key_resp_3.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_3.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_3.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_3.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_3.tStop = t  # not accounting for scr refresh
            key_resp_3.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_3.stopped')
            key_resp_3.status = FINISHED
    if key_resp_3.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_3.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_3_allKeys.extend(theseKeys)
        if len(_key_resp_3_allKeys):
            key_resp_3.keys = _key_resp_3_allKeys[-1].name  # just the last key pressed
            key_resp_3.rt = _key_resp_3_allKeys[-1].rt
            # was this correct?
            if (key_resp_3.keys == str('y')) or (key_resp_3.keys == 'y'):
                key_resp_3.corr = 1
            else:
                key_resp_3.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in A_sa_A_Components:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "A_sa_A_" ---
for thisComponent in A_sa_A_Components:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_3.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_3.keys in ['', [], None]:  # No response was made
    key_resp_3.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_3.corr = 1;  # correct non-response
    else:
       key_resp_3.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_3.keys',key_resp_3.keys)
thisExp.addData('key_resp_3.corr', key_resp_3.corr)
if key_resp_3.keys != None:  # we had a response
    thisExp.addData('key_resp_3.rt', key_resp_3.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "u_u_so" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_4.setSound('mainpairs/u+u.so.wav', secs=3.5, hamming=True)
sound_vowels_4.setVolume(1.0, log=False)
key_resp_4.keys = []
key_resp_4.rt = []
_key_resp_4_allKeys = []
# keep track of which components have finished
u_u_soComponents = [sound_vowels_4, text_16, text_17, text_18, text_19, text_20, key_resp_4]
for thisComponent in u_u_soComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "u_u_so" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_4
    if sound_vowels_4.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_4.frameNStart = frameN  # exact frame index
        sound_vowels_4.tStart = t  # local t and not account for scr refresh
        sound_vowels_4.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_4.started', tThisFlipGlobal)
        sound_vowels_4.play(when=win)  # sync with win flip
    if sound_vowels_4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_4.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_4.tStop = t  # not accounting for scr refresh
            sound_vowels_4.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_4.stopped')
            sound_vowels_4.stop()
    
    # *text_16* updates
    if text_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_16.frameNStart = frameN  # exact frame index
        text_16.tStart = t  # local t and not account for scr refresh
        text_16.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_16, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_16.started')
        text_16.setAutoDraw(True)
    if text_16.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_16.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_16.tStop = t  # not accounting for scr refresh
            text_16.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_16.stopped')
            text_16.setAutoDraw(False)
    
    # *text_17* updates
    if text_17.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_17.frameNStart = frameN  # exact frame index
        text_17.tStart = t  # local t and not account for scr refresh
        text_17.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_17, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_17.started')
        text_17.setAutoDraw(True)
    if text_17.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_17.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_17.tStop = t  # not accounting for scr refresh
            text_17.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_17.stopped')
            text_17.setAutoDraw(False)
    
    # *text_18* updates
    if text_18.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_18.frameNStart = frameN  # exact frame index
        text_18.tStart = t  # local t and not account for scr refresh
        text_18.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_18, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_18.started')
        text_18.setAutoDraw(True)
    if text_18.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_18.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_18.tStop = t  # not accounting for scr refresh
            text_18.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_18.stopped')
            text_18.setAutoDraw(False)
    
    # *text_19* updates
    if text_19.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_19.frameNStart = frameN  # exact frame index
        text_19.tStart = t  # local t and not account for scr refresh
        text_19.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_19, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_19.started')
        text_19.setAutoDraw(True)
    if text_19.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_19.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_19.tStop = t  # not accounting for scr refresh
            text_19.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_19.stopped')
            text_19.setAutoDraw(False)
    
    # *text_20* updates
    if text_20.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_20.frameNStart = frameN  # exact frame index
        text_20.tStart = t  # local t and not account for scr refresh
        text_20.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_20, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_20.started')
        text_20.setAutoDraw(True)
    if text_20.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_20.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_20.tStop = t  # not accounting for scr refresh
            text_20.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_20.stopped')
            text_20.setAutoDraw(False)
    
    # *key_resp_4* updates
    waitOnFlip = False
    if key_resp_4.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_4.frameNStart = frameN  # exact frame index
        key_resp_4.tStart = t  # local t and not account for scr refresh
        key_resp_4.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_4, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_4.started')
        key_resp_4.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_4.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_4.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_4.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_4.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_4.tStop = t  # not accounting for scr refresh
            key_resp_4.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_4.stopped')
            key_resp_4.status = FINISHED
    if key_resp_4.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_4.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_4_allKeys.extend(theseKeys)
        if len(_key_resp_4_allKeys):
            key_resp_4.keys = _key_resp_4_allKeys[-1].name  # just the last key pressed
            key_resp_4.rt = _key_resp_4_allKeys[-1].rt
            # was this correct?
            if (key_resp_4.keys == str('y')) or (key_resp_4.keys == 'y'):
                key_resp_4.corr = 1
            else:
                key_resp_4.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in u_u_soComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "u_u_so" ---
for thisComponent in u_u_soComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_4.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_4.keys in ['', [], None]:  # No response was made
    key_resp_4.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_4.corr = 1;  # correct non-response
    else:
       key_resp_4.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_4.keys',key_resp_4.keys)
thisExp.addData('key_resp_4.corr', key_resp_4.corr)
if key_resp_4.keys != None:  # we had a response
    thisExp.addData('key_resp_4.rt', key_resp_4.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AsaApA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_21.setSound('mainpairs/AsaApA.wav', secs=3.5, hamming=True)
sound_vowels_21.setVolume(1.0, log=False)
key_resp_21.keys = []
key_resp_21.rt = []
_key_resp_21_allKeys = []
# keep track of which components have finished
AsaApAComponents = [sound_vowels_21, text_101, text_102, text_103, text_104, text_105, key_resp_21]
for thisComponent in AsaApAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AsaApA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_21
    if sound_vowels_21.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_21.frameNStart = frameN  # exact frame index
        sound_vowels_21.tStart = t  # local t and not account for scr refresh
        sound_vowels_21.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_21.started', tThisFlipGlobal)
        sound_vowels_21.play(when=win)  # sync with win flip
    if sound_vowels_21.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_21.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_21.tStop = t  # not accounting for scr refresh
            sound_vowels_21.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_21.stopped')
            sound_vowels_21.stop()
    
    # *text_101* updates
    if text_101.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_101.frameNStart = frameN  # exact frame index
        text_101.tStart = t  # local t and not account for scr refresh
        text_101.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_101, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_101.started')
        text_101.setAutoDraw(True)
    if text_101.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_101.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_101.tStop = t  # not accounting for scr refresh
            text_101.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_101.stopped')
            text_101.setAutoDraw(False)
    
    # *text_102* updates
    if text_102.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_102.frameNStart = frameN  # exact frame index
        text_102.tStart = t  # local t and not account for scr refresh
        text_102.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_102, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_102.started')
        text_102.setAutoDraw(True)
    if text_102.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_102.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_102.tStop = t  # not accounting for scr refresh
            text_102.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_102.stopped')
            text_102.setAutoDraw(False)
    
    # *text_103* updates
    if text_103.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_103.frameNStart = frameN  # exact frame index
        text_103.tStart = t  # local t and not account for scr refresh
        text_103.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_103, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_103.started')
        text_103.setAutoDraw(True)
    if text_103.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_103.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_103.tStop = t  # not accounting for scr refresh
            text_103.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_103.stopped')
            text_103.setAutoDraw(False)
    
    # *text_104* updates
    if text_104.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_104.frameNStart = frameN  # exact frame index
        text_104.tStart = t  # local t and not account for scr refresh
        text_104.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_104, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_104.started')
        text_104.setAutoDraw(True)
    if text_104.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_104.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_104.tStop = t  # not accounting for scr refresh
            text_104.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_104.stopped')
            text_104.setAutoDraw(False)
    
    # *text_105* updates
    if text_105.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_105.frameNStart = frameN  # exact frame index
        text_105.tStart = t  # local t and not account for scr refresh
        text_105.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_105, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_105.started')
        text_105.setAutoDraw(True)
    if text_105.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_105.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_105.tStop = t  # not accounting for scr refresh
            text_105.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_105.stopped')
            text_105.setAutoDraw(False)
    
    # *key_resp_21* updates
    waitOnFlip = False
    if key_resp_21.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_21.frameNStart = frameN  # exact frame index
        key_resp_21.tStart = t  # local t and not account for scr refresh
        key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_21.started')
        key_resp_21.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_21.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_21.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_21.tStop = t  # not accounting for scr refresh
            key_resp_21.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_21.stopped')
            key_resp_21.status = FINISHED
    if key_resp_21.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_21.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_21_allKeys.extend(theseKeys)
        if len(_key_resp_21_allKeys):
            key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
            key_resp_21.rt = _key_resp_21_allKeys[-1].rt
            # was this correct?
            if (key_resp_21.keys == str('n')) or (key_resp_21.keys == 'n'):
                key_resp_21.corr = 1
            else:
                key_resp_21.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AsaApAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AsaApA" ---
for thisComponent in AsaApAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_21.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_21.keys in ['', [], None]:  # No response was made
    key_resp_21.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_21.corr = 1;  # correct non-response
    else:
       key_resp_21.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_21.keys',key_resp_21.keys)
thisExp.addData('key_resp_21.corr', key_resp_21.corr)
if key_resp_21.keys != None:  # we had a response
    thisExp.addData('key_resp_21.rt', key_resp_21.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "upso" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_18.setSound('mainpairs/upso.wav', secs=3.5, hamming=True)
sound_vowels_18.setVolume(1.0, log=False)
key_resp_18.keys = []
key_resp_18.rt = []
_key_resp_18_allKeys = []
# keep track of which components have finished
upsoComponents = [sound_vowels_18, text_86, text_87, text_88, text_89, text_90, key_resp_18]
for thisComponent in upsoComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "upso" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_18
    if sound_vowels_18.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_18.frameNStart = frameN  # exact frame index
        sound_vowels_18.tStart = t  # local t and not account for scr refresh
        sound_vowels_18.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_18.started', tThisFlipGlobal)
        sound_vowels_18.play(when=win)  # sync with win flip
    if sound_vowels_18.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_18.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_18.tStop = t  # not accounting for scr refresh
            sound_vowels_18.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_18.stopped')
            sound_vowels_18.stop()
    
    # *text_86* updates
    if text_86.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_86.frameNStart = frameN  # exact frame index
        text_86.tStart = t  # local t and not account for scr refresh
        text_86.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_86, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_86.started')
        text_86.setAutoDraw(True)
    if text_86.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_86.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_86.tStop = t  # not accounting for scr refresh
            text_86.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_86.stopped')
            text_86.setAutoDraw(False)
    
    # *text_87* updates
    if text_87.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_87.frameNStart = frameN  # exact frame index
        text_87.tStart = t  # local t and not account for scr refresh
        text_87.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_87, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_87.started')
        text_87.setAutoDraw(True)
    if text_87.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_87.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_87.tStop = t  # not accounting for scr refresh
            text_87.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_87.stopped')
            text_87.setAutoDraw(False)
    
    # *text_88* updates
    if text_88.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_88.frameNStart = frameN  # exact frame index
        text_88.tStart = t  # local t and not account for scr refresh
        text_88.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_88, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_88.started')
        text_88.setAutoDraw(True)
    if text_88.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_88.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_88.tStop = t  # not accounting for scr refresh
            text_88.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_88.stopped')
            text_88.setAutoDraw(False)
    
    # *text_89* updates
    if text_89.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_89.frameNStart = frameN  # exact frame index
        text_89.tStart = t  # local t and not account for scr refresh
        text_89.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_89, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_89.started')
        text_89.setAutoDraw(True)
    if text_89.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_89.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_89.tStop = t  # not accounting for scr refresh
            text_89.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_89.stopped')
            text_89.setAutoDraw(False)
    
    # *text_90* updates
    if text_90.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_90.frameNStart = frameN  # exact frame index
        text_90.tStart = t  # local t and not account for scr refresh
        text_90.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_90, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_90.started')
        text_90.setAutoDraw(True)
    if text_90.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_90.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_90.tStop = t  # not accounting for scr refresh
            text_90.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_90.stopped')
            text_90.setAutoDraw(False)
    
    # *key_resp_18* updates
    waitOnFlip = False
    if key_resp_18.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_18.frameNStart = frameN  # exact frame index
        key_resp_18.tStart = t  # local t and not account for scr refresh
        key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_18.started')
        key_resp_18.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_18.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_18.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_18.tStop = t  # not accounting for scr refresh
            key_resp_18.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_18.stopped')
            key_resp_18.status = FINISHED
    if key_resp_18.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_18.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_18_allKeys.extend(theseKeys)
        if len(_key_resp_18_allKeys):
            key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
            key_resp_18.rt = _key_resp_18_allKeys[-1].rt
            # was this correct?
            if (key_resp_18.keys == str('n')) or (key_resp_18.keys == 'n'):
                key_resp_18.corr = 1
            else:
                key_resp_18.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in upsoComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "upso" ---
for thisComponent in upsoComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_18.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_18.keys in ['', [], None]:  # No response was made
    key_resp_18.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_18.corr = 1;  # correct non-response
    else:
       key_resp_18.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_18.keys',key_resp_18.keys)
thisExp.addData('key_resp_18.corr', key_resp_18.corr)
if key_resp_18.keys != None:  # we had a response
    thisExp.addData('key_resp_18.rt', key_resp_18.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "AsaApsa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_22.setSound('mainpairs/AsaApsa.wav', secs=3.5, hamming=True)
sound_vowels_22.setVolume(1.0, log=False)
key_resp_22.keys = []
key_resp_22.rt = []
_key_resp_22_allKeys = []
# keep track of which components have finished
AsaApsaComponents = [sound_vowels_22, text_106, text_107, text_108, text_109, text_110, key_resp_22]
for thisComponent in AsaApsaComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "AsaApsa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_22
    if sound_vowels_22.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_22.frameNStart = frameN  # exact frame index
        sound_vowels_22.tStart = t  # local t and not account for scr refresh
        sound_vowels_22.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_22.started', tThisFlipGlobal)
        sound_vowels_22.play(when=win)  # sync with win flip
    if sound_vowels_22.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_22.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_22.tStop = t  # not accounting for scr refresh
            sound_vowels_22.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_22.stopped')
            sound_vowels_22.stop()
    
    # *text_106* updates
    if text_106.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_106.frameNStart = frameN  # exact frame index
        text_106.tStart = t  # local t and not account for scr refresh
        text_106.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_106, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_106.started')
        text_106.setAutoDraw(True)
    if text_106.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_106.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_106.tStop = t  # not accounting for scr refresh
            text_106.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_106.stopped')
            text_106.setAutoDraw(False)
    
    # *text_107* updates
    if text_107.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_107.frameNStart = frameN  # exact frame index
        text_107.tStart = t  # local t and not account for scr refresh
        text_107.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_107, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_107.started')
        text_107.setAutoDraw(True)
    if text_107.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_107.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_107.tStop = t  # not accounting for scr refresh
            text_107.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_107.stopped')
            text_107.setAutoDraw(False)
    
    # *text_108* updates
    if text_108.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_108.frameNStart = frameN  # exact frame index
        text_108.tStart = t  # local t and not account for scr refresh
        text_108.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_108, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_108.started')
        text_108.setAutoDraw(True)
    if text_108.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_108.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_108.tStop = t  # not accounting for scr refresh
            text_108.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_108.stopped')
            text_108.setAutoDraw(False)
    
    # *text_109* updates
    if text_109.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_109.frameNStart = frameN  # exact frame index
        text_109.tStart = t  # local t and not account for scr refresh
        text_109.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_109, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_109.started')
        text_109.setAutoDraw(True)
    if text_109.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_109.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_109.tStop = t  # not accounting for scr refresh
            text_109.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_109.stopped')
            text_109.setAutoDraw(False)
    
    # *text_110* updates
    if text_110.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_110.frameNStart = frameN  # exact frame index
        text_110.tStart = t  # local t and not account for scr refresh
        text_110.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_110, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_110.started')
        text_110.setAutoDraw(True)
    if text_110.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_110.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_110.tStop = t  # not accounting for scr refresh
            text_110.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_110.stopped')
            text_110.setAutoDraw(False)
    
    # *key_resp_22* updates
    waitOnFlip = False
    if key_resp_22.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_22.frameNStart = frameN  # exact frame index
        key_resp_22.tStart = t  # local t and not account for scr refresh
        key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_22.started')
        key_resp_22.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_22.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_22.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_22.tStop = t  # not accounting for scr refresh
            key_resp_22.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_22.stopped')
            key_resp_22.status = FINISHED
    if key_resp_22.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_22.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_22_allKeys.extend(theseKeys)
        if len(_key_resp_22_allKeys):
            key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
            key_resp_22.rt = _key_resp_22_allKeys[-1].rt
            # was this correct?
            if (key_resp_22.keys == str('n')) or (key_resp_22.keys == 'n'):
                key_resp_22.corr = 1
            else:
                key_resp_22.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in AsaApsaComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "AsaApsa" ---
for thisComponent in AsaApsaComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_22.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_22.keys in ['', [], None]:  # No response was made
    key_resp_22.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_22.corr = 1;  # correct non-response
    else:
       key_resp_22.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_22.keys',key_resp_22.keys)
thisExp.addData('key_resp_22.corr', key_resp_22.corr)
if key_resp_22.keys != None:  # we had a response
    thisExp.addData('key_resp_22.rt', key_resp_22.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "joAjoApA" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_5.setSound('mainpairs/joAjoApA.wav', secs=3.5, hamming=True)
sound_vowels_5.setVolume(1.0, log=False)
key_resp_5.keys = []
key_resp_5.rt = []
_key_resp_5_allKeys = []
# keep track of which components have finished
joAjoApAComponents = [sound_vowels_5, text_21, text_22, text_23, text_24, text_25, key_resp_5]
for thisComponent in joAjoApAComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "joAjoApA" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_5
    if sound_vowels_5.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_5.frameNStart = frameN  # exact frame index
        sound_vowels_5.tStart = t  # local t and not account for scr refresh
        sound_vowels_5.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_5.started', tThisFlipGlobal)
        sound_vowels_5.play(when=win)  # sync with win flip
    if sound_vowels_5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_5.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_5.tStop = t  # not accounting for scr refresh
            sound_vowels_5.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_5.stopped')
            sound_vowels_5.stop()
    
    # *text_21* updates
    if text_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_21.frameNStart = frameN  # exact frame index
        text_21.tStart = t  # local t and not account for scr refresh
        text_21.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_21, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_21.started')
        text_21.setAutoDraw(True)
    if text_21.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_21.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_21.tStop = t  # not accounting for scr refresh
            text_21.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_21.stopped')
            text_21.setAutoDraw(False)
    
    # *text_22* updates
    if text_22.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_22.frameNStart = frameN  # exact frame index
        text_22.tStart = t  # local t and not account for scr refresh
        text_22.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_22, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_22.started')
        text_22.setAutoDraw(True)
    if text_22.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_22.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_22.tStop = t  # not accounting for scr refresh
            text_22.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_22.stopped')
            text_22.setAutoDraw(False)
    
    # *text_23* updates
    if text_23.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_23.frameNStart = frameN  # exact frame index
        text_23.tStart = t  # local t and not account for scr refresh
        text_23.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_23, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_23.started')
        text_23.setAutoDraw(True)
    if text_23.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_23.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_23.tStop = t  # not accounting for scr refresh
            text_23.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_23.stopped')
            text_23.setAutoDraw(False)
    
    # *text_24* updates
    if text_24.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_24.frameNStart = frameN  # exact frame index
        text_24.tStart = t  # local t and not account for scr refresh
        text_24.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_24, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_24.started')
        text_24.setAutoDraw(True)
    if text_24.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_24.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_24.tStop = t  # not accounting for scr refresh
            text_24.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_24.stopped')
            text_24.setAutoDraw(False)
    
    # *text_25* updates
    if text_25.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_25.frameNStart = frameN  # exact frame index
        text_25.tStart = t  # local t and not account for scr refresh
        text_25.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_25, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_25.started')
        text_25.setAutoDraw(True)
    if text_25.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_25.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_25.tStop = t  # not accounting for scr refresh
            text_25.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_25.stopped')
            text_25.setAutoDraw(False)
    
    # *key_resp_5* updates
    waitOnFlip = False
    if key_resp_5.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_5.frameNStart = frameN  # exact frame index
        key_resp_5.tStart = t  # local t and not account for scr refresh
        key_resp_5.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_5, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_5.started')
        key_resp_5.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_5.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_5.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_5.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_5.tStop = t  # not accounting for scr refresh
            key_resp_5.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_5.stopped')
            key_resp_5.status = FINISHED
    if key_resp_5.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_5.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_5_allKeys.extend(theseKeys)
        if len(_key_resp_5_allKeys):
            key_resp_5.keys = _key_resp_5_allKeys[-1].name  # just the last key pressed
            key_resp_5.rt = _key_resp_5_allKeys[-1].rt
            # was this correct?
            if (key_resp_5.keys == str('n')) or (key_resp_5.keys == 'n'):
                key_resp_5.corr = 1
            else:
                key_resp_5.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in joAjoApAComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "joAjoApA" ---
for thisComponent in joAjoApAComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_5.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_5.keys in ['', [], None]:  # No response was made
    key_resp_5.keys = None
    # was no response the correct answer?!
    if str('n').lower() == 'none':
       key_resp_5.corr = 1;  # correct non-response
    else:
       key_resp_5.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_5.keys',key_resp_5.keys)
thisExp.addData('key_resp_5.corr', key_resp_5.corr)
if key_resp_5.keys != None:  # we had a response
    thisExp.addData('key_resp_5.rt', key_resp_5.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- Prepare to start Routine "A_sa_sa" ---
continueRoutine = True
routineForceEnded = False
# update component parameters for each repeat
sound_vowels_7.setSound('mainpairs/A.sa+sa.wav', secs=3.5, hamming=True)
sound_vowels_7.setVolume(1.0, log=False)
key_resp_7.keys = []
key_resp_7.rt = []
_key_resp_7_allKeys = []
# keep track of which components have finished
A_sa_saComponents = [sound_vowels_7, text_31, text_32, text_33, text_34, text_35, key_resp_7]
for thisComponent in A_sa_saComponents:
    thisComponent.tStart = None
    thisComponent.tStop = None
    thisComponent.tStartRefresh = None
    thisComponent.tStopRefresh = None
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
# reset timers
t = 0
_timeToFirstFrame = win.getFutureFlipTime(clock="now")
frameN = -1

# --- Run Routine "A_sa_sa" ---
while continueRoutine and routineTimer.getTime() < 19.0:
    # get current time
    t = routineTimer.getTime()
    tThisFlip = win.getFutureFlipTime(clock=routineTimer)
    tThisFlipGlobal = win.getFutureFlipTime(clock=None)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    # update/draw components on each frame
    # start/stop sound_vowels_7
    if sound_vowels_7.status == NOT_STARTED and tThisFlip >= 5-frameTolerance:
        # keep track of start time/frame for later
        sound_vowels_7.frameNStart = frameN  # exact frame index
        sound_vowels_7.tStart = t  # local t and not account for scr refresh
        sound_vowels_7.tStartRefresh = tThisFlipGlobal  # on global time
        # add timestamp to datafile
        thisExp.addData('sound_vowels_7.started', tThisFlipGlobal)
        sound_vowels_7.play(when=win)  # sync with win flip
    if sound_vowels_7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > sound_vowels_7.tStartRefresh + 3.5-frameTolerance:
            # keep track of stop time/frame for later
            sound_vowels_7.tStop = t  # not accounting for scr refresh
            sound_vowels_7.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'sound_vowels_7.stopped')
            sound_vowels_7.stop()
    
    # *text_31* updates
    if text_31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
        # keep track of start time/frame for later
        text_31.frameNStart = frameN  # exact frame index
        text_31.tStart = t  # local t and not account for scr refresh
        text_31.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_31, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_31.started')
        text_31.setAutoDraw(True)
    if text_31.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_31.tStartRefresh + 2.0-frameTolerance:
            # keep track of stop time/frame for later
            text_31.tStop = t  # not accounting for scr refresh
            text_31.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_31.stopped')
            text_31.setAutoDraw(False)
    
    # *text_32* updates
    if text_32.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        text_32.frameNStart = frameN  # exact frame index
        text_32.tStart = t  # local t and not account for scr refresh
        text_32.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_32, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_32.started')
        text_32.setAutoDraw(True)
    if text_32.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_32.tStartRefresh + 10.0-frameTolerance:
            # keep track of stop time/frame for later
            text_32.tStop = t  # not accounting for scr refresh
            text_32.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_32.stopped')
            text_32.setAutoDraw(False)
    
    # *text_33* updates
    if text_33.status == NOT_STARTED and tThisFlip >= 2-frameTolerance:
        # keep track of start time/frame for later
        text_33.frameNStart = frameN  # exact frame index
        text_33.tStart = t  # local t and not account for scr refresh
        text_33.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_33, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_33.started')
        text_33.setAutoDraw(True)
    if text_33.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_33.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_33.tStop = t  # not accounting for scr refresh
            text_33.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_33.stopped')
            text_33.setAutoDraw(False)
    
    # *text_34* updates
    if text_34.status == NOT_STARTED and tThisFlip >= 3.0-frameTolerance:
        # keep track of start time/frame for later
        text_34.frameNStart = frameN  # exact frame index
        text_34.tStart = t  # local t and not account for scr refresh
        text_34.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_34, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_34.started')
        text_34.setAutoDraw(True)
    if text_34.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_34.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_34.tStop = t  # not accounting for scr refresh
            text_34.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_34.stopped')
            text_34.setAutoDraw(False)
    
    # *text_35* updates
    if text_35.status == NOT_STARTED and tThisFlip >= 4.0-frameTolerance:
        # keep track of start time/frame for later
        text_35.frameNStart = frameN  # exact frame index
        text_35.tStart = t  # local t and not account for scr refresh
        text_35.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(text_35, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'text_35.started')
        text_35.setAutoDraw(True)
    if text_35.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > text_35.tStartRefresh + 1.0-frameTolerance:
            # keep track of stop time/frame for later
            text_35.tStop = t  # not accounting for scr refresh
            text_35.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_35.stopped')
            text_35.setAutoDraw(False)
    
    # *key_resp_7* updates
    waitOnFlip = False
    if key_resp_7.status == NOT_STARTED and tThisFlip >= 9.0-frameTolerance:
        # keep track of start time/frame for later
        key_resp_7.frameNStart = frameN  # exact frame index
        key_resp_7.tStart = t  # local t and not account for scr refresh
        key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
        win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
        # add timestamp to datafile
        thisExp.timestampOnFlip(win, 'key_resp_7.started')
        key_resp_7.status = STARTED
        # keyboard checking is just starting
        waitOnFlip = True
        win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
        win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
    if key_resp_7.status == STARTED:
        # is it time to stop? (based on global clock, using actual start)
        if tThisFlipGlobal > key_resp_7.tStartRefresh + 10-frameTolerance:
            # keep track of stop time/frame for later
            key_resp_7.tStop = t  # not accounting for scr refresh
            key_resp_7.frameNStop = frameN  # exact frame index
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_7.stopped')
            key_resp_7.status = FINISHED
    if key_resp_7.status == STARTED and not waitOnFlip:
        theseKeys = key_resp_7.getKeys(keyList=['y','n'], waitRelease=False)
        _key_resp_7_allKeys.extend(theseKeys)
        if len(_key_resp_7_allKeys):
            key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
            key_resp_7.rt = _key_resp_7_allKeys[-1].rt
            # was this correct?
            if (key_resp_7.keys == str('y')) or (key_resp_7.keys == 'y'):
                key_resp_7.corr = 1
            else:
                key_resp_7.corr = 0
            # a response ends the routine
            continueRoutine = False
    
    # check for quit (typically the Esc key)
    if endExpNow or defaultKeyboard.getKeys(keyList=["escape"]):
        core.quit()
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineForceEnded = True
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in A_sa_saComponents:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()

# --- Ending Routine "A_sa_sa" ---
for thisComponent in A_sa_saComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
sound_vowels_7.stop()  # ensure sound has stopped at end of routine
# check responses
if key_resp_7.keys in ['', [], None]:  # No response was made
    key_resp_7.keys = None
    # was no response the correct answer?!
    if str('y').lower() == 'none':
       key_resp_7.corr = 1;  # correct non-response
    else:
       key_resp_7.corr = 0;  # failed to respond (incorrectly)
# store data for thisExp (ExperimentHandler)
thisExp.addData('key_resp_7.keys',key_resp_7.keys)
thisExp.addData('key_resp_7.corr', key_resp_7.corr)
if key_resp_7.keys != None:  # we had a response
    thisExp.addData('key_resp_7.rt', key_resp_7.rt)
thisExp.nextEntry()
# using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
if routineForceEnded:
    routineTimer.reset()
else:
    routineTimer.addTime(-19.000000)

# --- End experiment ---
# Flip one final time so any remaining win.callOnFlip() 
# and win.timeOnFlip() tasks get executed before quitting
win.flip()

# these shouldn't be strictly necessary (should auto-save)
thisExp.saveAsWideText(filename+'.csv', delim='auto')
thisExp.saveAsPickle(filename)
logging.flush()
# make sure everything is closed down
if eyetracker:
    eyetracker.setConnectionState(False)
thisExp.abort()  # or data files will save again on exit
win.close()
core.quit()
