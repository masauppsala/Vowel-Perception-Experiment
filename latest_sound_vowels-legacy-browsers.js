/**************************** 
 * Latest_Sound_Vowels Test *
 ****************************/


// store info about the experiment session:
let expName = 'latest_sound_vowels';  // from the Builder filename that created this script
let expInfo = {
    'participant': `${util.pad(Number.parseFloat(util.randint(0, 999999)).toFixed(0), 6)}`,
    'session': '001',
};

// Start code blocks for 'Before Experiment'
// init psychoJS:
const psychoJS = new PsychoJS({
  debug: true
});

// open window:
psychoJS.openWindow({
  fullscr: true,
  color: new util.Color([0,0,0]),
  units: 'height',
  waitBlanking: true
});
// schedule the experiment:
psychoJS.schedule(psychoJS.gui.DlgFromDict({
  dictionary: expInfo,
  title: expName
}));

const flowScheduler = new Scheduler(psychoJS);
const dialogCancelScheduler = new Scheduler(psychoJS);
psychoJS.scheduleCondition(function() { return (psychoJS.gui.dialogComponent.button === 'OK'); }, flowScheduler, dialogCancelScheduler);

// flowScheduler gets run if the participants presses OK
flowScheduler.add(updateInfo); // add timeStamp
flowScheduler.add(experimentInit);
flowScheduler.add(trialRoutineBegin());
flowScheduler.add(trialRoutineEachFrame());
flowScheduler.add(trialRoutineEnd());
flowScheduler.add(A_sa_A_sasecondRoutineBegin());
flowScheduler.add(A_sa_A_sasecondRoutineEachFrame());
flowScheduler.add(A_sa_A_sasecondRoutineEnd());
flowScheduler.add(usousopuRoutineBegin());
flowScheduler.add(usousopuRoutineEachFrame());
flowScheduler.add(usousopuRoutineEnd());
flowScheduler.add(uusopsoRoutineBegin());
flowScheduler.add(uusopsoRoutineEachFrame());
flowScheduler.add(uusopsoRoutineEnd());
flowScheduler.add(sousopuRoutineBegin());
flowScheduler.add(sousopuRoutineEachFrame());
flowScheduler.add(sousopuRoutineEnd());
flowScheduler.add(sa_ja_saRoutineBegin());
flowScheduler.add(sa_ja_saRoutineEachFrame());
flowScheduler.add(sa_ja_saRoutineEnd());
flowScheduler.add(u_so_soRoutineBegin());
flowScheduler.add(u_so_soRoutineEachFrame());
flowScheduler.add(u_so_soRoutineEnd());
flowScheduler.add(sojojopjoRoutineBegin());
flowScheduler.add(sojojopjoRoutineEachFrame());
flowScheduler.add(sojojopjoRoutineEnd());
flowScheduler.add(u_so_u_soRoutineBegin());
flowScheduler.add(u_so_u_soRoutineEachFrame());
flowScheduler.add(u_so_u_soRoutineEnd());
flowScheduler.add(sa_ja_sa_jaRoutineBegin());
flowScheduler.add(sa_ja_sa_jaRoutineEachFrame());
flowScheduler.add(sa_ja_sa_jaRoutineEnd());
flowScheduler.add(so_u_soRoutineBegin());
flowScheduler.add(so_u_soRoutineEachFrame());
flowScheduler.add(so_u_soRoutineEnd());
flowScheduler.add(jo_jo_ARoutineBegin());
flowScheduler.add(jo_jo_ARoutineEachFrame());
flowScheduler.add(jo_jo_ARoutineEnd());
flowScheduler.add(u_so_uRoutineBegin());
flowScheduler.add(u_so_uRoutineEachFrame());
flowScheduler.add(u_so_uRoutineEnd());
flowScheduler.add(sa_ja_jaRoutineBegin());
flowScheduler.add(sa_ja_jaRoutineEachFrame());
flowScheduler.add(sa_ja_jaRoutineEnd());
flowScheduler.add(usosopuRoutineBegin());
flowScheduler.add(usosopuRoutineEachFrame());
flowScheduler.add(usosopuRoutineEnd());
flowScheduler.add(so_so_joRoutineBegin());
flowScheduler.add(so_so_joRoutineEachFrame());
flowScheduler.add(so_so_joRoutineEnd());
flowScheduler.add(ja_sa_jaRoutineBegin());
flowScheduler.add(ja_sa_jaRoutineEachFrame());
flowScheduler.add(ja_sa_jaRoutineEnd());
flowScheduler.add(sa_A_sapsaRoutineBegin());
flowScheduler.add(sa_A_sapsaRoutineEachFrame());
flowScheduler.add(sa_A_sapsaRoutineEnd());
flowScheduler.add(jo_A_ARoutineBegin());
flowScheduler.add(jo_A_ARoutineEachFrame());
flowScheduler.add(jo_A_ARoutineEnd());
flowScheduler.add(usoupuRoutineBegin());
flowScheduler.add(usoupuRoutineEachFrame());
flowScheduler.add(usoupuRoutineEnd());
flowScheduler.add(ja_sa_japjaRoutineBegin());
flowScheduler.add(ja_sa_japjaRoutineEachFrame());
flowScheduler.add(ja_sa_japjaRoutineEnd());
flowScheduler.add(joAApjoRoutineBegin());
flowScheduler.add(joAApjoRoutineEachFrame());
flowScheduler.add(joAApjoRoutineEnd());
flowScheduler.add(saAsapARoutineBegin());
flowScheduler.add(saAsapARoutineEachFrame());
flowScheduler.add(saAsapARoutineEnd());
flowScheduler.add(ja_sa_japsaRoutineBegin());
flowScheduler.add(ja_sa_japsaRoutineEachFrame());
flowScheduler.add(ja_sa_japsaRoutineEnd());
flowScheduler.add(sopjoRoutineBegin());
flowScheduler.add(sopjoRoutineEachFrame());
flowScheduler.add(sopjoRoutineEnd());
flowScheduler.add(sa_A_saRoutineBegin());
flowScheduler.add(sa_A_saRoutineEachFrame());
flowScheduler.add(sa_A_saRoutineEnd());
flowScheduler.add(jojoApjoRoutineBegin());
flowScheduler.add(jojoApjoRoutineEachFrame());
flowScheduler.add(jojoApjoRoutineEnd());
flowScheduler.add(uusopuRoutineBegin());
flowScheduler.add(uusopuRoutineEachFrame());
flowScheduler.add(uusopuRoutineEnd());
flowScheduler.add(sojosojopjoRoutineBegin());
flowScheduler.add(sojosojopjoRoutineEachFrame());
flowScheduler.add(sojosojopjoRoutineEnd());
flowScheduler.add(sosojopsoRoutineBegin());
flowScheduler.add(sosojopsoRoutineEachFrame());
flowScheduler.add(sosojopsoRoutineEnd());
flowScheduler.add(A_sa_sapsaRoutineBegin());
flowScheduler.add(A_sa_sapsaRoutineEachFrame());
flowScheduler.add(A_sa_sapsaRoutineEnd());
flowScheduler.add(jo_A_jo_ARoutineBegin());
flowScheduler.add(jo_A_jo_ARoutineEachFrame());
flowScheduler.add(jo_A_jo_ARoutineEnd());
flowScheduler.add(jo_so_joRoutineBegin());
flowScheduler.add(jo_so_joRoutineEachFrame());
flowScheduler.add(jo_so_joRoutineEnd());
flowScheduler.add(sojosojopsoRoutineBegin());
flowScheduler.add(sojosojopsoRoutineEachFrame());
flowScheduler.add(sojosojopsoRoutineEnd());
flowScheduler.add(josojopjoRoutineBegin());
flowScheduler.add(josojopjoRoutineEachFrame());
flowScheduler.add(josojopjoRoutineEnd());
flowScheduler.add(joAjoApjoRoutineBegin());
flowScheduler.add(joAjoApjoRoutineEachFrame());
flowScheduler.add(joAjoApjoRoutineEnd());
flowScheduler.add(so_jo_joRoutineBegin());
flowScheduler.add(so_jo_joRoutineEachFrame());
flowScheduler.add(so_jo_joRoutineEnd());
flowScheduler.add(sousopsoRoutineBegin());
flowScheduler.add(sousopsoRoutineEachFrame());
flowScheduler.add(sousopsoRoutineEnd());
flowScheduler.add(sa_sa_jaRoutineBegin());
flowScheduler.add(sa_sa_jaRoutineEachFrame());
flowScheduler.add(sa_sa_jaRoutineEnd());
flowScheduler.add(joAjopjoRoutineBegin());
flowScheduler.add(joAjopjoRoutineEachFrame());
flowScheduler.add(joAjopjoRoutineEnd());
flowScheduler.add(sa_sa_japsaRoutineBegin());
flowScheduler.add(sa_sa_japsaRoutineEachFrame());
flowScheduler.add(sa_sa_japsaRoutineEnd());
flowScheduler.add(jo_A_joRoutineBegin());
flowScheduler.add(jo_A_joRoutineEachFrame());
flowScheduler.add(jo_A_joRoutineEnd());
flowScheduler.add(sojosopjoRoutineBegin());
flowScheduler.add(sojosopjoRoutineEachFrame());
flowScheduler.add(sojosopjoRoutineEnd());
flowScheduler.add(sa_ja_japjaRoutineBegin());
flowScheduler.add(sa_ja_japjaRoutineEachFrame());
flowScheduler.add(sa_ja_japjaRoutineEnd());
flowScheduler.add(joAjopARoutineBegin());
flowScheduler.add(joAjopARoutineEachFrame());
flowScheduler.add(joAjopARoutineEnd());
flowScheduler.add(sapjaRoutineBegin());
flowScheduler.add(sapjaRoutineEachFrame());
flowScheduler.add(sapjaRoutineEnd());
flowScheduler.add(sa_ja_sa_japjaRoutineBegin());
flowScheduler.add(sa_ja_sa_japjaRoutineEachFrame());
flowScheduler.add(sa_ja_sa_japjaRoutineEnd());
flowScheduler.add(josojopsoRoutineBegin());
flowScheduler.add(josojopsoRoutineEachFrame());
flowScheduler.add(josojopsoRoutineEnd());
flowScheduler.add(so_jo_so_joRoutineBegin());
flowScheduler.add(so_jo_so_joRoutineEachFrame());
flowScheduler.add(so_jo_so_joRoutineEnd());
flowScheduler.add(sa_sa_japjaRoutineBegin());
flowScheduler.add(sa_sa_japjaRoutineEachFrame());
flowScheduler.add(sa_sa_japjaRoutineEnd());
flowScheduler.add(sojojopsoRoutineBegin());
flowScheduler.add(sojojopsoRoutineEachFrame());
flowScheduler.add(sojojopsoRoutineEnd());
flowScheduler.add(jojoApARoutineBegin());
flowScheduler.add(jojoApARoutineEachFrame());
flowScheduler.add(jojoApARoutineEnd());
flowScheduler.add(so_jo_soRoutineBegin());
flowScheduler.add(so_jo_soRoutineEachFrame());
flowScheduler.add(so_jo_soRoutineEnd());
flowScheduler.add(joAApARoutineBegin());
flowScheduler.add(joAApARoutineEachFrame());
flowScheduler.add(joAApARoutineEnd());
flowScheduler.add(sojosopsoRoutineBegin());
flowScheduler.add(sojosopsoRoutineEachFrame());
flowScheduler.add(sojosopsoRoutineEnd());
flowScheduler.add(usaRoutineBegin());
flowScheduler.add(usaRoutineEachFrame());
flowScheduler.add(usaRoutineEnd());
flowScheduler.add(sojaRoutineBegin());
flowScheduler.add(sojaRoutineEachFrame());
flowScheduler.add(sojaRoutineEnd());
flowScheduler.add(AsaAsapsaRoutineBegin());
flowScheduler.add(AsaAsapsaRoutineEachFrame());
flowScheduler.add(AsaAsapsaRoutineEnd());
flowScheduler.add(ujaRoutineBegin());
flowScheduler.add(ujaRoutineEachFrame());
flowScheduler.add(ujaRoutineEnd());
flowScheduler.add(sa_ja_sapsaRoutineBegin());
flowScheduler.add(sa_ja_sapsaRoutineEachFrame());
flowScheduler.add(sa_ja_sapsaRoutineEnd());
flowScheduler.add(uRoutineBegin());
flowScheduler.add(uRoutineEachFrame());
flowScheduler.add(uRoutineEnd());
flowScheduler.add(sa_ja_sapjaRoutineBegin());
flowScheduler.add(sa_ja_sapjaRoutineEachFrame());
flowScheduler.add(sa_ja_sapjaRoutineEnd());
flowScheduler.add(jopARoutineBegin());
flowScheduler.add(jopARoutineEachFrame());
flowScheduler.add(jopARoutineEnd());
flowScheduler.add(usoupsoRoutineBegin());
flowScheduler.add(usoupsoRoutineEachFrame());
flowScheduler.add(usoupsoRoutineEnd());
flowScheduler.add(sosojopjoRoutineBegin());
flowScheduler.add(sosojopjoRoutineEachFrame());
flowScheduler.add(sosojopjoRoutineEnd());
flowScheduler.add(sosaRoutineBegin());
flowScheduler.add(sosaRoutineEachFrame());
flowScheduler.add(sosaRoutineEnd());
flowScheduler.add(ARoutineBegin());
flowScheduler.add(ARoutineEachFrame());
flowScheduler.add(ARoutineEnd());
flowScheduler.add(sa_ja_japsaRoutineBegin());
flowScheduler.add(sa_ja_japsaRoutineEachFrame());
flowScheduler.add(sa_ja_japsaRoutineEnd());
flowScheduler.add(ApsaRoutineBegin());
flowScheduler.add(ApsaRoutineEachFrame());
flowScheduler.add(ApsaRoutineEnd());
flowScheduler.add(sa_ja_sa_japsaRoutineBegin());
flowScheduler.add(sa_ja_sa_japsaRoutineEachFrame());
flowScheduler.add(sa_ja_sa_japsaRoutineEnd());
flowScheduler.add(A_jo_ARoutineBegin());
flowScheduler.add(A_jo_ARoutineEachFrame());
flowScheduler.add(A_jo_ARoutineEnd());
flowScheduler.add(joRoutineBegin());
flowScheduler.add(joRoutineEachFrame());
flowScheduler.add(joRoutineEnd());
flowScheduler.add(soRoutineBegin());
flowScheduler.add(soRoutineEachFrame());
flowScheduler.add(soRoutineEnd());
flowScheduler.add(jojaRoutineBegin());
flowScheduler.add(jojaRoutineEachFrame());
flowScheduler.add(jojaRoutineEnd());
flowScheduler.add(jaRoutineBegin());
flowScheduler.add(jaRoutineEachFrame());
flowScheduler.add(jaRoutineEnd());
flowScheduler.add(AsasapARoutineBegin());
flowScheduler.add(AsasapARoutineEachFrame());
flowScheduler.add(AsasapARoutineEnd());
flowScheduler.add(AjoApARoutineBegin());
flowScheduler.add(AjoApARoutineEachFrame());
flowScheduler.add(AjoApARoutineEnd());
flowScheduler.add(A_A_saRoutineBegin());
flowScheduler.add(A_A_saRoutineEachFrame());
flowScheduler.add(A_A_saRoutineEnd());
flowScheduler.add(saRoutineBegin());
flowScheduler.add(saRoutineEachFrame());
flowScheduler.add(saRoutineEnd());
flowScheduler.add(AsaAsapARoutineBegin());
flowScheduler.add(AsaAsapARoutineEachFrame());
flowScheduler.add(AsaAsapARoutineEnd());
flowScheduler.add(usousopsoRoutineBegin());
flowScheduler.add(usousopsoRoutineEachFrame());
flowScheduler.add(usousopsoRoutineEnd());
flowScheduler.add(AAsapARoutineBegin());
flowScheduler.add(AAsapARoutineEachFrame());
flowScheduler.add(AAsapARoutineEnd());
flowScheduler.add(AjoApjoRoutineBegin());
flowScheduler.add(AjoApjoRoutineEachFrame());
flowScheduler.add(AjoApjoRoutineEnd());
flowScheduler.add(AAsapsaRoutineBegin());
flowScheduler.add(AAsapsaRoutineEachFrame());
flowScheduler.add(AAsapsaRoutineEnd());
flowScheduler.add(usosopsoRoutineBegin());
flowScheduler.add(usosopsoRoutineEachFrame());
flowScheduler.add(usosopsoRoutineEnd());
flowScheduler.add(A_sa_A_RoutineBegin());
flowScheduler.add(A_sa_A_RoutineEachFrame());
flowScheduler.add(A_sa_A_RoutineEnd());
flowScheduler.add(u_u_soRoutineBegin());
flowScheduler.add(u_u_soRoutineEachFrame());
flowScheduler.add(u_u_soRoutineEnd());
flowScheduler.add(AsaApARoutineBegin());
flowScheduler.add(AsaApARoutineEachFrame());
flowScheduler.add(AsaApARoutineEnd());
flowScheduler.add(upsoRoutineBegin());
flowScheduler.add(upsoRoutineEachFrame());
flowScheduler.add(upsoRoutineEnd());
flowScheduler.add(AsaApsaRoutineBegin());
flowScheduler.add(AsaApsaRoutineEachFrame());
flowScheduler.add(AsaApsaRoutineEnd());
flowScheduler.add(joAjoApARoutineBegin());
flowScheduler.add(joAjoApARoutineEachFrame());
flowScheduler.add(joAjoApARoutineEnd());
flowScheduler.add(A_sa_saRoutineBegin());
flowScheduler.add(A_sa_saRoutineEachFrame());
flowScheduler.add(A_sa_saRoutineEnd());
flowScheduler.add(quitPsychoJS, '', true);

// quit if user presses Cancel in dialog box:
dialogCancelScheduler.add(quitPsychoJS, '', false);

psychoJS.start({
  expName: expName,
  expInfo: expInfo,
  resources: [
    {'name': 'mainpairs/so.jo+jo.wav', 'path': 'mainpairs/so.jo+jo.wav'},
    {'name': 'mainpairs/sa+sa.japja.wav', 'path': 'mainpairs/sa+sa.japja.wav'},
    {'name': 'mainpairs/so.jo+so.wav', 'path': 'mainpairs/so.jo+so.wav'},
    {'name': 'mainpairs/sa.ja+sa.japsa.wav', 'path': 'mainpairs/sa.ja+sa.japsa.wav'},
    {'name': 'mainpairs/joAjopA.wav', 'path': 'mainpairs/joAjopA.wav'},
    {'name': 'mainpairs/sosojopjo.wav', 'path': 'mainpairs/sosojopjo.wav'},
    {'name': 'mainpairs/joAjopjo.wav', 'path': 'mainpairs/joAjopjo.wav'},
    {'name': 'mainpairs/sa+A.sa.wav', 'path': 'mainpairs/sa+A.sa.wav'},
    {'name': 'mainpairs/A.sa+sapsa.wav', 'path': 'mainpairs/A.sa+sapsa.wav'},
    {'name': 'mainpairs/AjoApjo.wav', 'path': 'mainpairs/AjoApjo.wav'},
    {'name': 'mainpairs/so.jo+so.jo.wav', 'path': 'mainpairs/so.jo+so.jo.wav'},
    {'name': 'mainpairs/usousopso.wav', 'path': 'mainpairs/usousopso.wav'},
    {'name': 'mainpairs/sa+sa.ja.wav', 'path': 'mainpairs/sa+sa.ja.wav'},
    {'name': 'mainpairs/AsaApA.wav', 'path': 'mainpairs/AsaApA.wav'},
    {'name': 'mainpairs/Apsa.wav', 'path': 'mainpairs/Apsa.wav'},
    {'name': 'mainpairs/jo.A+A.wav', 'path': 'mainpairs/jo.A+A.wav'},
    {'name': 'mainpairs/sa+sa.japsa.wav', 'path': 'mainpairs/sa+sa.japsa.wav'},
    {'name': 'mainpairs/A.sa+A.sa.wav', 'path': 'mainpairs/A.sa+A.sa.wav'},
    {'name': 'mainpairs/jo+so.jo.wav', 'path': 'mainpairs/jo+so.jo.wav'},
    {'name': 'mainpairs/jo.wav', 'path': 'mainpairs/jo.wav'},
    {'name': 'mainpairs/uusopu.wav', 'path': 'mainpairs/uusopu.wav'},
    {'name': 'mainpairs/ja+sa.japja.wav', 'path': 'mainpairs/ja+sa.japja.wav'},
    {'name': 'mainpairs/sousopu.wav', 'path': 'mainpairs/sousopu.wav'},
    {'name': 'mainpairs/ja+sa.japsa.wav', 'path': 'mainpairs/ja+sa.japsa.wav'},
    {'name': 'mainpairs/uja.wav', 'path': 'mainpairs/uja.wav'},
    {'name': 'mainpairs/sosojopso.wav', 'path': 'mainpairs/sosojopso.wav'},
    {'name': 'mainpairs/jopA.wav', 'path': 'mainpairs/jopA.wav'},
    {'name': 'mainpairs/sojojopso.wav', 'path': 'mainpairs/sojojopso.wav'},
    {'name': 'mainpairs/sa.wav', 'path': 'mainpairs/sa.wav'},
    {'name': 'mainpairs/soja.wav', 'path': 'mainpairs/soja.wav'},
    {'name': 'mainpairs/josojopjo.wav', 'path': 'mainpairs/josojopjo.wav'},
    {'name': 'mainpairs/usousopu.wav', 'path': 'mainpairs/usousopu.wav'},
    {'name': 'mainpairs/joAjoApjo.wav', 'path': 'mainpairs/joAjoApjo.wav'},
    {'name': 'mainpairs/sa.ja+sa.japja.wav', 'path': 'mainpairs/sa.ja+sa.japja.wav'},
    {'name': 'mainpairs/sojosopso.wav', 'path': 'mainpairs/sojosopso.wav'},
    {'name': 'mainpairs/sa.ja+japsa.wav', 'path': 'mainpairs/sa.ja+japsa.wav'},
    {'name': 'mainpairs/usa.wav', 'path': 'mainpairs/usa.wav'},
    {'name': 'mainpairs/usoupu.wav', 'path': 'mainpairs/usoupu.wav'},
    {'name': 'mainpairs/AsaAsapA.wav', 'path': 'mainpairs/AsaAsapA.wav'},
    {'name': 'mainpairs/sa.ja+sa.ja.wav', 'path': 'mainpairs/sa.ja+sa.ja.wav'},
    {'name': 'mainpairs/sojosopjo.wav', 'path': 'mainpairs/sojosopjo.wav'},
    {'name': 'mainpairs/jo.A+jo.wav', 'path': 'mainpairs/jo.A+jo.wav'},
    {'name': 'mainpairs/sa+A.sapsa.wav', 'path': 'mainpairs/sa+A.sapsa.wav'},
    {'name': 'mainpairs/so+u.so.wav', 'path': 'mainpairs/so+u.so.wav'},
    {'name': 'mainpairs/usosopso.wav', 'path': 'mainpairs/usosopso.wav'},
    {'name': 'mainpairs/ja+sa.ja.wav', 'path': 'mainpairs/ja+sa.ja.wav'},
    {'name': 'mainpairs/sa.ja+sa.wav', 'path': 'mainpairs/sa.ja+sa.wav'},
    {'name': 'mainpairs/A.sa+A.wav', 'path': 'mainpairs/A.sa+A.wav'},
    {'name': 'mainpairs/u.so+so.wav', 'path': 'mainpairs/u.so+so.wav'},
    {'name': 'mainpairs/AsasapA.wav', 'path': 'mainpairs/AsasapA.wav'},
    {'name': 'mainpairs/sa.ja+japja.wav', 'path': 'mainpairs/sa.ja+japja.wav'},
    {'name': 'mainpairs/AsaApsa.wav', 'path': 'mainpairs/AsaApsa.wav'},
    {'name': 'mainpairs/joja.wav', 'path': 'mainpairs/joja.wav'},
    {'name': 'mainpairs/AjoApA.wav', 'path': 'mainpairs/AjoApA.wav'},
    {'name': 'mainpairs/joAApA.wav', 'path': 'mainpairs/joAApA.wav'},
    {'name': 'mainpairs/sosa.wav', 'path': 'mainpairs/sosa.wav'},
    {'name': 'mainpairs/A+jo.A.wav', 'path': 'mainpairs/A+jo.A.wav'},
    {'name': 'mainpairs/A+A.sa.wav', 'path': 'mainpairs/A+A.sa.wav'},
    {'name': 'mainpairs/jojoApA.wav', 'path': 'mainpairs/jojoApA.wav'},
    {'name': 'mainpairs/ja.wav', 'path': 'mainpairs/ja.wav'},
    {'name': 'mainpairs/u+u.so.wav', 'path': 'mainpairs/u+u.so.wav'},
    {'name': 'mainpairs/u.so+u.wav', 'path': 'mainpairs/u.so+u.wav'},
    {'name': 'mainpairs/joAApjo.wav', 'path': 'mainpairs/joAApjo.wav'},
    {'name': 'mainpairs/so.wav', 'path': 'mainpairs/so.wav'},
    {'name': 'mainpairs/sa.ja+ja.wav', 'path': 'mainpairs/sa.ja+ja.wav'},
    {'name': 'mainpairs/sapja.wav', 'path': 'mainpairs/sapja.wav'},
    {'name': 'mainpairs/u.wav', 'path': 'mainpairs/u.wav'},
    {'name': 'mainpairs/sojojopjo.wav', 'path': 'mainpairs/sojojopjo.wav'},
    {'name': 'mainpairs/AAsapsa.wav', 'path': 'mainpairs/AAsapsa.wav'},
    {'name': 'mainpairs/jojoApjo.wav', 'path': 'mainpairs/jojoApjo.wav'},
    {'name': 'mainpairs/so+so.jo.wav', 'path': 'mainpairs/so+so.jo.wav'},
    {'name': 'mainpairs/sojosojopjo.wav', 'path': 'mainpairs/sojosojopjo.wav'},
    {'name': 'mainpairs/sa.ja+sapsa.wav', 'path': 'mainpairs/sa.ja+sapsa.wav'},
    {'name': 'mainpairs/u.so+u.so.wav', 'path': 'mainpairs/u.so+u.so.wav'},
    {'name': 'mainpairs/A.sa+sa.wav', 'path': 'mainpairs/A.sa+sa.wav'},
    {'name': 'mainpairs/saAsapA.wav', 'path': 'mainpairs/saAsapA.wav'},
    {'name': 'mainpairs/sojosojopso.wav', 'path': 'mainpairs/sojosojopso.wav'},
    {'name': 'mainpairs/sa.ja+sapja.wav', 'path': 'mainpairs/sa.ja+sapja.wav'},
    {'name': 'mainpairs/usosopu.wav', 'path': 'mainpairs/usosopu.wav'},
    {'name': 'mainpairs/josojopso.wav', 'path': 'mainpairs/josojopso.wav'},
    {'name': 'mainpairs/uusopso.wav', 'path': 'mainpairs/uusopso.wav'},
    {'name': 'mainpairs/jo+jo.A.wav', 'path': 'mainpairs/jo+jo.A.wav'},
    {'name': 'mainpairs/sopjo.wav', 'path': 'mainpairs/sopjo.wav'},
    {'name': 'mainpairs/jo.A+jo.A.wav', 'path': 'mainpairs/jo.A+jo.A.wav'},
    {'name': 'mainpairs/AAsapA.wav', 'path': 'mainpairs/AAsapA.wav'},
    {'name': 'mainpairs/sousopso.wav', 'path': 'mainpairs/sousopso.wav'},
    {'name': 'mainpairs/upso.wav', 'path': 'mainpairs/upso.wav'},
    {'name': 'mainpairs/usoupso.wav', 'path': 'mainpairs/usoupso.wav'},
    {'name': 'mainpairs/joAjoApA.wav', 'path': 'mainpairs/joAjoApA.wav'},
    {'name': 'mainpairs/A.wav', 'path': 'mainpairs/A.wav'},
    {'name': 'mainpairs/AsaAsapsa.wav', 'path': 'mainpairs/AsaAsapsa.wav'}
  ]
});

psychoJS.experimentLogger.setLevel(core.Logger.ServerLevel.EXP);


var currentLoop;
var frameDur;
async function updateInfo() {
  currentLoop = psychoJS.experiment;  // right now there are no loops
  expInfo['date'] = util.MonotonicClock.getDateStr();  // add a simple timestamp
  expInfo['expName'] = expName;
  expInfo['psychopyVersion'] = '2022.2.5';
  expInfo['OS'] = window.navigator.platform;


  // store frame rate of monitor if we can measure it successfully
  expInfo['frameRate'] = psychoJS.window.getActualFrameRate();
  if (typeof expInfo['frameRate'] !== 'undefined')
    frameDur = 1.0 / Math.round(expInfo['frameRate']);
  else
    frameDur = 1.0 / 60.0; // couldn't get a reliable measure so guess

  // add info from the URL:
  util.addInfoFromUrl(expInfo);
  

  
  psychoJS.experiment.dataFileName = (("." + "/") + `data/${expInfo["participant"]}_${expName}_${expInfo["date"]}`);


  return Scheduler.Event.NEXT;
}


var trialClock;
var sound_vowels;
var text;
var text_2;
var text_3;
var text_4;
var text_5;
var key_resp;
var A_sa_A_sasecondClock;
var A_saandA_sa;
var text_6;
var text_7;
var text_8;
var text_9;
var text_10;
var key_resp_2;
var usousopuClock;
var sound_vowels_91;
var text_451;
var text_452;
var text_453;
var text_454;
var text_455;
var key_resp_91;
var uusopsoClock;
var sound_vowels_92;
var text_456;
var text_457;
var text_458;
var text_459;
var text_460;
var key_resp_92;
var sousopuClock;
var sound_vowels_85;
var text_421;
var text_422;
var text_423;
var text_424;
var text_425;
var key_resp_85;
var sa_ja_saClock;
var sound_vowels_77;
var text_381;
var text_382;
var text_383;
var text_384;
var text_385;
var key_resp_77;
var u_so_soClock;
var sound_vowels_86;
var text_426;
var text_427;
var text_428;
var text_429;
var text_430;
var key_resp_86;
var sojojopjoClock;
var sound_vowels_45;
var text_221;
var text_222;
var text_223;
var text_224;
var text_225;
var key_resp_45;
var u_so_u_soClock;
var sound_vowels_87;
var text_431;
var text_432;
var text_433;
var text_434;
var text_435;
var key_resp_87;
var sa_ja_sa_jaClock;
var sound_vowels_76;
var text_376;
var text_377;
var text_378;
var text_379;
var text_380;
var key_resp_76;
var so_u_soClock;
var sound_vowels_84;
var text_416;
var text_417;
var text_418;
var text_419;
var text_420;
var key_resp_84;
var jo_jo_AClock;
var sound_vowels_73;
var text_361;
var text_362;
var text_363;
var text_364;
var text_365;
var key_resp_73;
var u_so_uClock;
var sound_vowels_88;
var text_436;
var text_437;
var text_438;
var text_439;
var text_440;
var key_resp_88;
var sa_ja_jaClock;
var sound_vowels_75;
var text_371;
var text_372;
var text_373;
var text_374;
var text_375;
var key_resp_75;
var usosopuClock;
var sound_vowels_89;
var text_441;
var text_442;
var text_443;
var text_444;
var text_445;
var key_resp_89;
var so_so_joClock;
var sound_vowels_83;
var text_411;
var text_412;
var text_413;
var text_414;
var text_415;
var key_resp_83;
var ja_sa_jaClock;
var sound_vowels_69;
var text_341;
var text_342;
var text_343;
var text_344;
var text_345;
var key_resp_69;
var sa_A_sapsaClock;
var sound_vowels_68;
var text_336;
var text_337;
var text_338;
var text_339;
var text_340;
var key_resp_68;
var jo_A_AClock;
var sound_vowels_70;
var text_346;
var text_347;
var text_348;
var text_349;
var text_350;
var key_resp_70;
var usoupuClock;
var sound_vowels_90;
var text_446;
var text_447;
var text_448;
var text_449;
var text_450;
var key_resp_90;
var ja_sa_japjaClock;
var sound_vowels_58;
var text_286;
var text_287;
var text_288;
var text_289;
var text_290;
var key_resp_58;
var joAApjoClock;
var sound_vowels_40;
var text_196;
var text_197;
var text_198;
var text_199;
var text_200;
var key_resp_40;
var saAsapAClock;
var sound_vowels_44;
var text_216;
var text_217;
var text_218;
var text_219;
var text_220;
var key_resp_44;
var ja_sa_japsaClock;
var sound_vowels_59;
var text_291;
var text_292;
var text_293;
var text_294;
var text_295;
var key_resp_59;
var sopjoClock;
var sound_vowels_39;
var text_191;
var text_192;
var text_193;
var text_194;
var text_195;
var key_resp_39;
var sa_A_saClock;
var sound_vowels_78;
var text_386;
var text_387;
var text_388;
var text_389;
var text_390;
var key_resp_78;
var jojoApjoClock;
var sound_vowels_48;
var text_236;
var text_237;
var text_238;
var text_239;
var text_240;
var key_resp_48;
var uusopuClock;
var sound_vowels_93;
var text_461;
var text_462;
var text_463;
var text_464;
var text_465;
var key_resp_93;
var sojosojopjoClock;
var sound_vowels_54;
var text_266;
var text_267;
var text_268;
var text_269;
var text_270;
var key_resp_54;
var sosojopsoClock;
var sound_vowels_50;
var text_246;
var text_247;
var text_248;
var text_249;
var text_250;
var key_resp_50;
var A_sa_sapsaClock;
var sound_vowels_8;
var text_36;
var text_37;
var text_38;
var text_39;
var text_40;
var key_resp_8;
var jo_A_jo_AClock;
var sound_vowels_71;
var text_351;
var text_352;
var text_353;
var text_354;
var text_355;
var key_resp_71;
var jo_so_joClock;
var sound_vowels_74;
var text_366;
var text_367;
var text_368;
var text_369;
var text_370;
var key_resp_74;
var sojosojopsoClock;
var sound_vowels_51;
var text_251;
var text_252;
var text_253;
var text_254;
var text_255;
var key_resp_51;
var josojopjoClock;
var sound_vowels_49;
var text_241;
var text_242;
var text_243;
var text_244;
var text_245;
var key_resp_49;
var joAjoApjoClock;
var sound_vowels_47;
var text_231;
var text_232;
var text_233;
var text_234;
var text_235;
var key_resp_47;
var so_jo_joClock;
var sound_vowels_80;
var text_396;
var text_397;
var text_398;
var text_399;
var text_400;
var key_resp_80;
var sousopsoClock;
var sound_vowels_46;
var text_226;
var text_227;
var text_228;
var text_229;
var text_230;
var key_resp_46;
var sa_sa_jaClock;
var sound_vowels_79;
var text_391;
var text_392;
var text_393;
var text_394;
var text_395;
var key_resp_79;
var joAjopjoClock;
var sound_vowels_42;
var text_206;
var text_207;
var text_208;
var text_209;
var text_210;
var key_resp_42;
var sa_sa_japsaClock;
var sound_vowels_60;
var text_296;
var text_297;
var text_298;
var text_299;
var text_300;
var key_resp_60;
var jo_A_joClock;
var sound_vowels_72;
var text_356;
var text_357;
var text_358;
var text_359;
var text_360;
var key_resp_72;
var sojosopjoClock;
var sound_vowels_53;
var text_261;
var text_262;
var text_263;
var text_264;
var text_265;
var key_resp_53;
var sa_ja_japjaClock;
var sound_vowels_62;
var text_306;
var text_307;
var text_308;
var text_309;
var text_310;
var key_resp_62;
var joAjopAClock;
var sound_vowels_41;
var text_201;
var text_202;
var text_203;
var text_204;
var text_205;
var key_resp_41;
var sapjaClock;
var sound_vowels_37;
var text_181;
var text_182;
var text_183;
var text_184;
var text_185;
var key_resp_37;
var sa_ja_sa_japjaClock;
var sound_vowels_64;
var text_316;
var text_317;
var text_318;
var text_319;
var text_320;
var key_resp_64;
var josojopsoClock;
var sound_vowels_57;
var text_281;
var text_282;
var text_283;
var text_284;
var text_285;
var key_resp_57;
var so_jo_so_joClock;
var sound_vowels_81;
var text_401;
var text_402;
var text_403;
var text_404;
var text_405;
var key_resp_81;
var sa_sa_japjaClock;
var sound_vowels_61;
var text_301;
var text_302;
var text_303;
var text_304;
var text_305;
var key_resp_61;
var sojojopsoClock;
var sound_vowels_52;
var text_256;
var text_257;
var text_258;
var text_259;
var text_260;
var key_resp_52;
var jojoApAClock;
var sound_vowels_43;
var text_211;
var text_212;
var text_213;
var text_214;
var text_215;
var key_resp_43;
var so_jo_soClock;
var sound_vowels_82;
var text_406;
var text_407;
var text_408;
var text_409;
var text_410;
var key_resp_82;
var joAApAClock;
var sound_vowels_38;
var text_186;
var text_187;
var text_188;
var text_189;
var text_190;
var key_resp_38;
var sojosopsoClock;
var sound_vowels_55;
var text_271;
var text_272;
var text_273;
var text_274;
var text_275;
var key_resp_55;
var usaClock;
var sound_vowels_33;
var text_161;
var text_162;
var text_163;
var text_164;
var text_165;
var key_resp_33;
var sojaClock;
var sound_vowels_36;
var text_176;
var text_177;
var text_178;
var text_179;
var text_180;
var key_resp_36;
var AsaAsapsaClock;
var sound_vowels_24;
var text_116;
var text_117;
var text_118;
var text_119;
var text_120;
var key_resp_24;
var ujaClock;
var sound_vowels_34;
var text_166;
var text_167;
var text_168;
var text_169;
var text_170;
var key_resp_34;
var sa_ja_sapsaClock;
var sound_vowels_67;
var text_331;
var text_332;
var text_333;
var text_334;
var text_335;
var key_resp_67;
var uClock;
var sound_vowels_31;
var text_151;
var text_152;
var text_153;
var text_154;
var text_155;
var key_resp_31;
var sa_ja_sapjaClock;
var sound_vowels_66;
var text_326;
var text_327;
var text_328;
var text_329;
var text_330;
var key_resp_66;
var jopAClock;
var sound_vowels_32;
var text_156;
var text_157;
var text_158;
var text_159;
var text_160;
var key_resp_32;
var usoupsoClock;
var sound_vowels_16;
var text_76;
var text_77;
var text_78;
var text_79;
var text_80;
var key_resp_16;
var sosojopjoClock;
var sound_vowels_56;
var text_276;
var text_277;
var text_278;
var text_279;
var text_280;
var key_resp_56;
var sosaClock;
var sound_vowels_35;
var text_171;
var text_172;
var text_173;
var text_174;
var text_175;
var key_resp_35;
var AClock;
var sound_vowels_9;
var text_41;
var text_42;
var text_43;
var text_44;
var text_45;
var key_resp_9;
var sa_ja_japsaClock;
var sound_vowels_63;
var text_311;
var text_312;
var text_313;
var text_314;
var text_315;
var key_resp_63;
var ApsaClock;
var sound_vowels_20;
var text_96;
var text_97;
var text_98;
var text_99;
var text_100;
var key_resp_20;
var sa_ja_sa_japsaClock;
var sound_vowels_65;
var text_321;
var text_322;
var text_323;
var text_324;
var text_325;
var key_resp_65;
var A_jo_AClock;
var sound_vowels_11;
var text_51;
var text_52;
var text_53;
var text_54;
var text_55;
var key_resp_11;
var joClock;
var sound_vowels_27;
var text_131;
var text_132;
var text_133;
var text_134;
var text_135;
var key_resp_27;
var soClock;
var sound_vowels_29;
var text_141;
var text_142;
var text_143;
var text_144;
var text_145;
var key_resp_29;
var jojaClock;
var sound_vowels_28;
var text_136;
var text_137;
var text_138;
var text_139;
var text_140;
var key_resp_28;
var jaClock;
var sound_vowels_26;
var text_126;
var text_127;
var text_128;
var text_129;
var text_130;
var key_resp_26;
var AsasapAClock;
var sound_vowels_25;
var text_121;
var text_122;
var text_123;
var text_124;
var text_125;
var key_resp_25;
var AjoApAClock;
var sound_vowels_14;
var text_66;
var text_67;
var text_68;
var text_69;
var text_70;
var key_resp_14;
var A_A_saClock;
var sound_vowels_10;
var text_46;
var text_47;
var text_48;
var text_49;
var text_50;
var key_resp_10;
var saClock;
var sound_vowels_30;
var text_146;
var text_147;
var text_148;
var text_149;
var text_150;
var key_resp_30;
var AsaAsapAClock;
var sound_vowels_23;
var text_111;
var text_112;
var text_113;
var text_114;
var text_115;
var key_resp_23;
var usousopsoClock;
var sound_vowels_15;
var text_71;
var text_72;
var text_73;
var text_74;
var text_75;
var key_resp_15;
var AAsapAClock;
var sound_vowels_12;
var text_56;
var text_57;
var text_58;
var text_59;
var text_60;
var key_resp_12;
var AjoApjoClock;
var sound_vowels_19;
var text_91;
var text_92;
var text_93;
var text_94;
var text_95;
var key_resp_19;
var AAsapsaClock;
var sound_vowels_13;
var text_61;
var text_62;
var text_63;
var text_64;
var text_65;
var key_resp_13;
var usosopsoClock;
var sound_vowels_17;
var text_81;
var text_82;
var text_83;
var text_84;
var text_85;
var key_resp_17;
var A_sa_A_Clock;
var sound_vowels_3;
var text_11;
var text_12;
var text_13;
var text_14;
var text_15;
var key_resp_3;
var u_u_soClock;
var sound_vowels_4;
var text_16;
var text_17;
var text_18;
var text_19;
var text_20;
var key_resp_4;
var AsaApAClock;
var sound_vowels_21;
var text_101;
var text_102;
var text_103;
var text_104;
var text_105;
var key_resp_21;
var upsoClock;
var sound_vowels_18;
var text_86;
var text_87;
var text_88;
var text_89;
var text_90;
var key_resp_18;
var AsaApsaClock;
var sound_vowels_22;
var text_106;
var text_107;
var text_108;
var text_109;
var text_110;
var key_resp_22;
var joAjoApAClock;
var sound_vowels_5;
var text_21;
var text_22;
var text_23;
var text_24;
var text_25;
var key_resp_5;
var A_sa_saClock;
var sound_vowels_7;
var text_31;
var text_32;
var text_33;
var text_34;
var text_35;
var key_resp_7;
var globalClock;
var routineTimer;
async function experimentInit() {
  // Initialize components for Routine "trial"
  trialClock = new util.Clock();
  sound_vowels = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joja.wav',
    secs: (- 1),
    });
  sound_vowels.setVolume(1.0);
  text = new visual.TextStim({
    win: psychoJS.window,
    name: 'text',
    text: 'Listen to a pair of vowels. Please answer whether they are the same vowels or not. It will be played in 3 seconds.',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_2 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_2',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_3 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_3',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_4 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_4',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_5 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_5',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "A_sa_A_sasecond"
  A_sa_A_sasecondClock = new util.Clock();
  A_saandA_sa = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/A.sa+A.sa.wav',
    secs: (- 1),
    });
  A_saandA_sa.setVolume(1.0);
  text_6 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_6',
    text: 'It was a trial. Now please answer whether the vowels are the same or not. It will take about 20 minutes\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_7 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_7',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_8 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_8',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_9 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_9',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_10 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_10',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_2 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "usousopu"
  usousopuClock = new util.Clock();
  sound_vowels_91 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/usousopu.wav',
    secs: (- 1),
    });
  sound_vowels_91.setVolume(1.0);
  text_451 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_451',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_452 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_452',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_453 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_453',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_454 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_454',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_455 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_455',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_91 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "uusopso"
  uusopsoClock = new util.Clock();
  sound_vowels_92 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/uusopso.wav',
    secs: (- 1),
    });
  sound_vowels_92.setVolume(1.0);
  text_456 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_456',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_457 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_457',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_458 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_458',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_459 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_459',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_460 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_460',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_92 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sousopu"
  sousopuClock = new util.Clock();
  sound_vowels_85 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sousopu.wav',
    secs: (- 1),
    });
  sound_vowels_85.setVolume(1.0);
  text_421 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_421',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_422 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_422',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_423 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_423',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_424 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_424',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_425 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_425',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_85 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_sa"
  sa_ja_saClock = new util.Clock();
  sound_vowels_77 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+sa.wav',
    secs: (- 1),
    });
  sound_vowels_77.setVolume(1.0);
  text_381 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_381',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_382 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_382',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_383 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_383',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_384 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_384',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_385 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_385',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_77 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "u_so_so"
  u_so_soClock = new util.Clock();
  sound_vowels_86 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/u.so+so.wav',
    secs: (- 1),
    });
  sound_vowels_86.setVolume(1.0);
  text_426 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_426',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_427 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_427',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_428 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_428',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_429 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_429',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_430 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_430',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_86 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sojojopjo"
  sojojopjoClock = new util.Clock();
  sound_vowels_45 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sojojopjo.wav',
    secs: (- 1),
    });
  sound_vowels_45.setVolume(1.0);
  text_221 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_221',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_222 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_222',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_223 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_223',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_224 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_224',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_225 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_225',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_45 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "u_so_u_so"
  u_so_u_soClock = new util.Clock();
  sound_vowels_87 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/u.so+u.so.wav',
    secs: (- 1),
    });
  sound_vowels_87.setVolume(1.0);
  text_431 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_431',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_432 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_432',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_433 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_433',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_434 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_434',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_435 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_435',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_87 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_sa_ja"
  sa_ja_sa_jaClock = new util.Clock();
  sound_vowels_76 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+sa.ja.wav',
    secs: (- 1),
    });
  sound_vowels_76.setVolume(1.0);
  text_376 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_376',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_377 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_377',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_378 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_378',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_379 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_379',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_380 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_380',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_76 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "so_u_so"
  so_u_soClock = new util.Clock();
  sound_vowels_84 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/so+u.so.wav',
    secs: (- 1),
    });
  sound_vowels_84.setVolume(1.0);
  text_416 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_416',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_417 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_417',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_418 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_418',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_419 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_419',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_420 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_420',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_84 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jo_jo_A"
  jo_jo_AClock = new util.Clock();
  sound_vowels_73 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jo+jo.A.wav',
    secs: (- 1),
    });
  sound_vowels_73.setVolume(1.0);
  text_361 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_361',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_362 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_362',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_363 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_363',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_364 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_364',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_365 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_365',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_73 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "u_so_u"
  u_so_uClock = new util.Clock();
  sound_vowels_88 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/u.so+u.wav',
    secs: (- 1),
    });
  sound_vowels_88.setVolume(1.0);
  text_436 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_436',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_437 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_437',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_438 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_438',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_439 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_439',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_440 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_440',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_88 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_ja"
  sa_ja_jaClock = new util.Clock();
  sound_vowels_75 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+ja.wav',
    secs: (- 1),
    });
  sound_vowels_75.setVolume(1.0);
  text_371 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_371',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_372 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_372',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_373 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_373',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_374 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_374',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_375 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_375',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_75 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "usosopu"
  usosopuClock = new util.Clock();
  sound_vowels_89 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/usosopu.wav',
    secs: (- 1),
    });
  sound_vowels_89.setVolume(1.0);
  text_441 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_441',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_442 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_442',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_443 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_443',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_444 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_444',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_445 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_445',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_89 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "so_so_jo"
  so_so_joClock = new util.Clock();
  sound_vowels_83 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/so+so.jo.wav',
    secs: (- 1),
    });
  sound_vowels_83.setVolume(1.0);
  text_411 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_411',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_412 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_412',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_413 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_413',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_414 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_414',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_415 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_415',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_83 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "ja_sa_ja"
  ja_sa_jaClock = new util.Clock();
  sound_vowels_69 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/ja+sa.ja.wav',
    secs: (- 1),
    });
  sound_vowels_69.setVolume(1.0);
  text_341 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_341',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_342 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_342',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_343 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_343',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_344 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_344',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_345 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_345',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_69 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_A_sapsa"
  sa_A_sapsaClock = new util.Clock();
  sound_vowels_68 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa+A.sapsa.wav',
    secs: (- 1),
    });
  sound_vowels_68.setVolume(1.0);
  text_336 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_336',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_337 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_337',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_338 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_338',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_339 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_339',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_340 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_340',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_68 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jo_A_A"
  jo_A_AClock = new util.Clock();
  sound_vowels_70 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jo.A+A.wav',
    secs: (- 1),
    });
  sound_vowels_70.setVolume(1.0);
  text_346 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_346',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_347 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_347',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_348 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_348',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_349 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_349',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_350 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_350',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_70 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "usoupu"
  usoupuClock = new util.Clock();
  sound_vowels_90 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/usoupu.wav',
    secs: (- 1),
    });
  sound_vowels_90.setVolume(1.0);
  text_446 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_446',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_447 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_447',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_448 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_448',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_449 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_449',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_450 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_450',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_90 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "ja_sa_japja"
  ja_sa_japjaClock = new util.Clock();
  sound_vowels_58 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/ja+sa.japja.wav',
    secs: (- 1),
    });
  sound_vowels_58.setVolume(1.0);
  text_286 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_286',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_287 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_287',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_288 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_288',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_289 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_289',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_290 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_290',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_58 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "joAApjo"
  joAApjoClock = new util.Clock();
  sound_vowels_40 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joAApjo.wav',
    secs: (- 1),
    });
  sound_vowels_40.setVolume(1.0);
  text_196 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_196',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_197 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_197',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_198 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_198',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_199 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_199',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_200 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_200',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_40 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "saAsapA"
  saAsapAClock = new util.Clock();
  sound_vowels_44 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/saAsapA.wav',
    secs: (- 1),
    });
  sound_vowels_44.setVolume(1.0);
  text_216 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_216',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_217 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_217',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_218 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_218',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_219 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_219',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_220 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_220',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_44 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "ja_sa_japsa"
  ja_sa_japsaClock = new util.Clock();
  sound_vowels_59 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/ja+sa.japsa.wav',
    secs: (- 1),
    });
  sound_vowels_59.setVolume(1.0);
  text_291 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_291',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_292 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_292',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_293 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_293',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_294 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_294',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_295 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_295',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_59 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sopjo"
  sopjoClock = new util.Clock();
  sound_vowels_39 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sopjo.wav',
    secs: (- 1),
    });
  sound_vowels_39.setVolume(1.0);
  text_191 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_191',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_192 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_192',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_193 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_193',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_194 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_194',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_195 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_195',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_39 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_A_sa"
  sa_A_saClock = new util.Clock();
  sound_vowels_78 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa+A.sa.wav',
    secs: (- 1),
    });
  sound_vowels_78.setVolume(1.0);
  text_386 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_386',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_387 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_387',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_388 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_388',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_389 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_389',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_390 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_390',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_78 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jojoApjo"
  jojoApjoClock = new util.Clock();
  sound_vowels_48 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jojoApjo.wav',
    secs: (- 1),
    });
  sound_vowels_48.setVolume(1.0);
  text_236 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_236',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_237 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_237',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_238 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_238',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_239 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_239',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_240 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_240',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_48 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "uusopu"
  uusopuClock = new util.Clock();
  sound_vowels_93 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/uusopu.wav',
    secs: (- 1),
    });
  sound_vowels_93.setVolume(1.0);
  text_461 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_461',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_462 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_462',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_463 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_463',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_464 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_464',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_465 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_465',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_93 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sojosojopjo"
  sojosojopjoClock = new util.Clock();
  sound_vowels_54 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sojosojopjo.wav',
    secs: (- 1),
    });
  sound_vowels_54.setVolume(1.0);
  text_266 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_266',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_267 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_267',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_268 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_268',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_269 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_269',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_270 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_270',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_54 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sosojopso"
  sosojopsoClock = new util.Clock();
  sound_vowels_50 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sosojopso.wav',
    secs: (- 1),
    });
  sound_vowels_50.setVolume(1.0);
  text_246 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_246',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_247 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_247',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_248 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_248',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_249 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_249',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_250 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_250',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_50 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "A_sa_sapsa"
  A_sa_sapsaClock = new util.Clock();
  sound_vowels_8 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/A.sa+sapsa.wav',
    secs: (- 1),
    });
  sound_vowels_8.setVolume(1.0);
  text_36 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_36',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_37 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_37',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_38 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_38',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_39 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_39',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_40 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_40',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_8 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jo_A_jo_A"
  jo_A_jo_AClock = new util.Clock();
  sound_vowels_71 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jo.A+jo.A.wav',
    secs: (- 1),
    });
  sound_vowels_71.setVolume(1.0);
  text_351 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_351',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_352 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_352',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_353 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_353',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_354 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_354',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_355 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_355',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_71 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jo_so_jo"
  jo_so_joClock = new util.Clock();
  sound_vowels_74 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jo+so.jo.wav',
    secs: (- 1),
    });
  sound_vowels_74.setVolume(1.0);
  text_366 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_366',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_367 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_367',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_368 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_368',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_369 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_369',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_370 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_370',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_74 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sojosojopso"
  sojosojopsoClock = new util.Clock();
  sound_vowels_51 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sojosojopso.wav',
    secs: (- 1),
    });
  sound_vowels_51.setVolume(1.0);
  text_251 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_251',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_252 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_252',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_253 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_253',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_254 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_254',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_255 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_255',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_51 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "josojopjo"
  josojopjoClock = new util.Clock();
  sound_vowels_49 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/josojopjo.wav',
    secs: (- 1),
    });
  sound_vowels_49.setVolume(1.0);
  text_241 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_241',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_242 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_242',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_243 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_243',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_244 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_244',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_245 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_245',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_49 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "joAjoApjo"
  joAjoApjoClock = new util.Clock();
  sound_vowels_47 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joAjoApjo.wav',
    secs: (- 1),
    });
  sound_vowels_47.setVolume(1.0);
  text_231 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_231',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_232 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_232',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_233 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_233',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_234 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_234',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_235 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_235',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_47 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "so_jo_jo"
  so_jo_joClock = new util.Clock();
  sound_vowels_80 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/so.jo+jo.wav',
    secs: (- 1),
    });
  sound_vowels_80.setVolume(1.0);
  text_396 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_396',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_397 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_397',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_398 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_398',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_399 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_399',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_400 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_400',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_80 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sousopso"
  sousopsoClock = new util.Clock();
  sound_vowels_46 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sousopso.wav',
    secs: (- 1),
    });
  sound_vowels_46.setVolume(1.0);
  text_226 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_226',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_227 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_227',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_228 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_228',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_229 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_229',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_230 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_230',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_46 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_sa_ja"
  sa_sa_jaClock = new util.Clock();
  sound_vowels_79 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa+sa.ja.wav',
    secs: (- 1),
    });
  sound_vowels_79.setVolume(1.0);
  text_391 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_391',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_392 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_392',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_393 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_393',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_394 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_394',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_395 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_395',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_79 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "joAjopjo"
  joAjopjoClock = new util.Clock();
  sound_vowels_42 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joAjopjo.wav',
    secs: (- 1),
    });
  sound_vowels_42.setVolume(1.0);
  text_206 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_206',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_207 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_207',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_208 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_208',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_209 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_209',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_210 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_210',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_42 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_sa_japsa"
  sa_sa_japsaClock = new util.Clock();
  sound_vowels_60 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa+sa.japsa.wav',
    secs: (- 1),
    });
  sound_vowels_60.setVolume(1.0);
  text_296 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_296',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_297 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_297',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_298 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_298',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_299 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_299',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_300 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_300',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_60 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jo_A_jo"
  jo_A_joClock = new util.Clock();
  sound_vowels_72 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jo.A+jo.wav',
    secs: (- 1),
    });
  sound_vowels_72.setVolume(1.0);
  text_356 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_356',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_357 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_357',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_358 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_358',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_359 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_359',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_360 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_360',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_72 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sojosopjo"
  sojosopjoClock = new util.Clock();
  sound_vowels_53 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sojosopjo.wav',
    secs: (- 1),
    });
  sound_vowels_53.setVolume(1.0);
  text_261 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_261',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_262 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_262',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_263 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_263',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_264 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_264',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_265 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_265',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_53 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_japja"
  sa_ja_japjaClock = new util.Clock();
  sound_vowels_62 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+japja.wav',
    secs: (- 1),
    });
  sound_vowels_62.setVolume(1.0);
  text_306 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_306',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_307 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_307',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_308 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_308',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_309 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_309',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_310 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_310',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_62 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "joAjopA"
  joAjopAClock = new util.Clock();
  sound_vowels_41 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joAjopA.wav',
    secs: (- 1),
    });
  sound_vowels_41.setVolume(1.0);
  text_201 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_201',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_202 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_202',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_203 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_203',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_204 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_204',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_205 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_205',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_41 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sapja"
  sapjaClock = new util.Clock();
  sound_vowels_37 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sapja.wav',
    secs: (- 1),
    });
  sound_vowels_37.setVolume(1.0);
  text_181 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_181',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_182 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_182',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_183 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_183',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_184 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_184',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_185 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_185',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_37 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_sa_japja"
  sa_ja_sa_japjaClock = new util.Clock();
  sound_vowels_64 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+sa.japja.wav',
    secs: (- 1),
    });
  sound_vowels_64.setVolume(1.0);
  text_316 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_316',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_317 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_317',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_318 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_318',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_319 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_319',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_320 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_320',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_64 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "josojopso"
  josojopsoClock = new util.Clock();
  sound_vowels_57 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/josojopso.wav',
    secs: (- 1),
    });
  sound_vowels_57.setVolume(1.0);
  text_281 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_281',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_282 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_282',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_283 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_283',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_284 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_284',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_285 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_285',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_57 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "so_jo_so_jo"
  so_jo_so_joClock = new util.Clock();
  sound_vowels_81 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/so.jo+so.jo.wav',
    secs: (- 1),
    });
  sound_vowels_81.setVolume(1.0);
  text_401 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_401',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_402 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_402',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_403 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_403',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_404 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_404',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_405 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_405',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_81 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_sa_japja"
  sa_sa_japjaClock = new util.Clock();
  sound_vowels_61 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa+sa.japja.wav',
    secs: (- 1),
    });
  sound_vowels_61.setVolume(1.0);
  text_301 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_301',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_302 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_302',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_303 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_303',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_304 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_304',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_305 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_305',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_61 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sojojopso"
  sojojopsoClock = new util.Clock();
  sound_vowels_52 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sojojopso.wav',
    secs: (- 1),
    });
  sound_vowels_52.setVolume(1.0);
  text_256 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_256',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_257 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_257',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_258 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_258',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_259 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_259',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_260 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_260',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_52 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jojoApA"
  jojoApAClock = new util.Clock();
  sound_vowels_43 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jojoApA.wav',
    secs: (- 1),
    });
  sound_vowels_43.setVolume(1.0);
  text_211 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_211',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_212 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_212',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_213 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_213',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_214 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_214',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_215 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_215',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_43 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "so_jo_so"
  so_jo_soClock = new util.Clock();
  sound_vowels_82 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/so.jo+so.wav',
    secs: (- 1),
    });
  sound_vowels_82.setVolume(1.0);
  text_406 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_406',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_407 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_407',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_408 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_408',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_409 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_409',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_410 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_410',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_82 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "joAApA"
  joAApAClock = new util.Clock();
  sound_vowels_38 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joAApA.wav',
    secs: (- 1),
    });
  sound_vowels_38.setVolume(1.0);
  text_186 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_186',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_187 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_187',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_188 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_188',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_189 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_189',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_190 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_190',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_38 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sojosopso"
  sojosopsoClock = new util.Clock();
  sound_vowels_55 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sojosopso.wav',
    secs: (- 1),
    });
  sound_vowels_55.setVolume(1.0);
  text_271 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_271',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_272 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_272',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_273 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_273',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_274 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_274',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_275 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_275',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_55 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "usa"
  usaClock = new util.Clock();
  sound_vowels_33 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/usa.wav',
    secs: (- 1),
    });
  sound_vowels_33.setVolume(1.0);
  text_161 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_161',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_162 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_162',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_163 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_163',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_164 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_164',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_165 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_165',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_33 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "soja"
  sojaClock = new util.Clock();
  sound_vowels_36 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/soja.wav',
    secs: (- 1),
    });
  sound_vowels_36.setVolume(1.0);
  text_176 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_176',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_177 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_177',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_178 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_178',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_179 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_179',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_180 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_180',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_36 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AsaAsapsa"
  AsaAsapsaClock = new util.Clock();
  sound_vowels_24 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AsaAsapsa.wav',
    secs: (- 1),
    });
  sound_vowels_24.setVolume(1.0);
  text_116 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_116',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_117 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_117',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_118 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_118',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_119 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_119',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_120 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_120',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_24 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "uja"
  ujaClock = new util.Clock();
  sound_vowels_34 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/uja.wav',
    secs: (- 1),
    });
  sound_vowels_34.setVolume(1.0);
  text_166 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_166',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_167 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_167',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_168 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_168',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_169 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_169',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_170 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_170',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_34 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_sapsa"
  sa_ja_sapsaClock = new util.Clock();
  sound_vowels_67 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+sapsa.wav',
    secs: (- 1),
    });
  sound_vowels_67.setVolume(1.0);
  text_331 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_331',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_332 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_332',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_333 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_333',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_334 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_334',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_335 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_335',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_67 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "u"
  uClock = new util.Clock();
  sound_vowels_31 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/u.wav',
    secs: (- 1),
    });
  sound_vowels_31.setVolume(1.0);
  text_151 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_151',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_152 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_152',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_153 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_153',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_154 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_154',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_155 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_155',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_31 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_sapja"
  sa_ja_sapjaClock = new util.Clock();
  sound_vowels_66 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+sapja.wav',
    secs: (- 1),
    });
  sound_vowels_66.setVolume(1.0);
  text_326 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_326',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_327 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_327',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_328 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_328',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_329 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_329',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_330 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_330',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_66 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jopA"
  jopAClock = new util.Clock();
  sound_vowels_32 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jopA.wav',
    secs: (- 1),
    });
  sound_vowels_32.setVolume(1.0);
  text_156 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_156',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_157 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_157',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_158 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_158',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_159 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_159',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_160 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_160',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_32 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "usoupso"
  usoupsoClock = new util.Clock();
  sound_vowels_16 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/usoupso.wav',
    secs: (- 1),
    });
  sound_vowels_16.setVolume(1.0);
  text_76 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_76',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_77 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_77',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_78 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_78',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_79 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_79',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_80 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_80',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_16 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sosojopjo"
  sosojopjoClock = new util.Clock();
  sound_vowels_56 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sosojopjo.wav',
    secs: (- 1),
    });
  sound_vowels_56.setVolume(1.0);
  text_276 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_276',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_277 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_277',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_278 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_278',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_279 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_279',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_280 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_280',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_56 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sosa"
  sosaClock = new util.Clock();
  sound_vowels_35 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sosa.wav',
    secs: (- 1),
    });
  sound_vowels_35.setVolume(1.0);
  text_171 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_171',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_172 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_172',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_173 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_173',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_174 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_174',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_175 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_175',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_35 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "A"
  AClock = new util.Clock();
  sound_vowels_9 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/A.wav',
    secs: (- 1),
    });
  sound_vowels_9.setVolume(1.0);
  text_41 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_41',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_42 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_42',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_43 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_43',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_44 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_44',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_45 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_45',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_9 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_japsa"
  sa_ja_japsaClock = new util.Clock();
  sound_vowels_63 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+japsa.wav',
    secs: (- 1),
    });
  sound_vowels_63.setVolume(1.0);
  text_311 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_311',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_312 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_312',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_313 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_313',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_314 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_314',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_315 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_315',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_63 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "Apsa"
  ApsaClock = new util.Clock();
  sound_vowels_20 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/Apsa.wav',
    secs: (- 1),
    });
  sound_vowels_20.setVolume(1.0);
  text_96 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_96',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_97 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_97',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_98 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_98',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_99 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_99',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_100 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_100',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_20 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa_ja_sa_japsa"
  sa_ja_sa_japsaClock = new util.Clock();
  sound_vowels_65 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.ja+sa.japsa.wav',
    secs: (- 1),
    });
  sound_vowels_65.setVolume(1.0);
  text_321 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_321',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_322 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_322',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_323 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_323',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_324 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_324',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_325 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_325',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_65 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "A_jo_A"
  A_jo_AClock = new util.Clock();
  sound_vowels_11 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/A+jo.A.wav',
    secs: (- 1),
    });
  sound_vowels_11.setVolume(1.0);
  text_51 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_51',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_52 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_52',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_53 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_53',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_54 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_54',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_55 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_55',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_11 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "jo"
  joClock = new util.Clock();
  sound_vowels_27 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/jo.wav',
    secs: (- 1),
    });
  sound_vowels_27.setVolume(1.0);
  text_131 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_131',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_132 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_132',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_133 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_133',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_134 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_134',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_135 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_135',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_27 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "so"
  soClock = new util.Clock();
  sound_vowels_29 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/so.wav',
    secs: (- 1),
    });
  sound_vowels_29.setVolume(1.0);
  text_141 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_141',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_142 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_142',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_143 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_143',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_144 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_144',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_145 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_145',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_29 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "joja"
  jojaClock = new util.Clock();
  sound_vowels_28 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joja.wav',
    secs: (- 1),
    });
  sound_vowels_28.setVolume(1.0);
  text_136 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_136',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_137 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_137',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_138 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_138',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_139 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_139',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_140 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_140',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_28 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "ja"
  jaClock = new util.Clock();
  sound_vowels_26 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/ja.wav',
    secs: (- 1),
    });
  sound_vowels_26.setVolume(1.0);
  text_126 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_126',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_127 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_127',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_128 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_128',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_129 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_129',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_130 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_130',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_26 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AsasapA"
  AsasapAClock = new util.Clock();
  sound_vowels_25 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AsasapA.wav',
    secs: (- 1),
    });
  sound_vowels_25.setVolume(1.0);
  text_121 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_121',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_122 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_122',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_123 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_123',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_124 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_124',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_125 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_125',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_25 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AjoApA"
  AjoApAClock = new util.Clock();
  sound_vowels_14 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AjoApA.wav',
    secs: (- 1),
    });
  sound_vowels_14.setVolume(1.0);
  text_66 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_66',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_67 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_67',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_68 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_68',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_69 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_69',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_70 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_70',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_14 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "A_A_sa"
  A_A_saClock = new util.Clock();
  sound_vowels_10 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/A+A.sa.wav',
    secs: (- 1),
    });
  sound_vowels_10.setVolume(1.0);
  text_46 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_46',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_47 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_47',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_48 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_48',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_49 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_49',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_50 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_50',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_10 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "sa"
  saClock = new util.Clock();
  sound_vowels_30 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/sa.wav',
    secs: (- 1),
    });
  sound_vowels_30.setVolume(1.0);
  text_146 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_146',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_147 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_147',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_148 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_148',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_149 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_149',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_150 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_150',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_30 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AsaAsapA"
  AsaAsapAClock = new util.Clock();
  sound_vowels_23 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AsaAsapA.wav',
    secs: (- 1),
    });
  sound_vowels_23.setVolume(1.0);
  text_111 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_111',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_112 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_112',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_113 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_113',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_114 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_114',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_115 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_115',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_23 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "usousopso"
  usousopsoClock = new util.Clock();
  sound_vowels_15 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/usousopso.wav',
    secs: (- 1),
    });
  sound_vowels_15.setVolume(1.0);
  text_71 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_71',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_72 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_72',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_73 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_73',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_74 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_74',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_75 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_75',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_15 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AAsapA"
  AAsapAClock = new util.Clock();
  sound_vowels_12 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AAsapA.wav',
    secs: (- 1),
    });
  sound_vowels_12.setVolume(1.0);
  text_56 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_56',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_57 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_57',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_58 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_58',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_59 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_59',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_60 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_60',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_12 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AjoApjo"
  AjoApjoClock = new util.Clock();
  sound_vowels_19 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AjoApjo.wav',
    secs: (- 1),
    });
  sound_vowels_19.setVolume(1.0);
  text_91 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_91',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_92 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_92',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_93 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_93',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_94 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_94',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_95 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_95',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_19 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AAsapsa"
  AAsapsaClock = new util.Clock();
  sound_vowels_13 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AAsapsa.wav',
    secs: (- 1),
    });
  sound_vowels_13.setVolume(1.0);
  text_61 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_61',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_62 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_62',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_63 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_63',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_64 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_64',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_65 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_65',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_13 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "usosopso"
  usosopsoClock = new util.Clock();
  sound_vowels_17 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/usosopso.wav',
    secs: (- 1),
    });
  sound_vowels_17.setVolume(1.0);
  text_81 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_81',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_82 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_82',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_83 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_83',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_84 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_84',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_85 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_85',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_17 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "A_sa_A_"
  A_sa_A_Clock = new util.Clock();
  sound_vowels_3 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/A.sa+A.wav',
    secs: (- 1),
    });
  sound_vowels_3.setVolume(1.0);
  text_11 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_11',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_12 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_12',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_13 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_13',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_14 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_14',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_15 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_15',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_3 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "u_u_so"
  u_u_soClock = new util.Clock();
  sound_vowels_4 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/u+u.so.wav',
    secs: (- 1),
    });
  sound_vowels_4.setVolume(1.0);
  text_16 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_16',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_17 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_17',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_18 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_18',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_19 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_19',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_20 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_20',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_4 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AsaApA"
  AsaApAClock = new util.Clock();
  sound_vowels_21 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AsaApA.wav',
    secs: (- 1),
    });
  sound_vowels_21.setVolume(1.0);
  text_101 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_101',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_102 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_102',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_103 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_103',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_104 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_104',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_105 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_105',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_21 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "upso"
  upsoClock = new util.Clock();
  sound_vowels_18 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/upso.wav',
    secs: (- 1),
    });
  sound_vowels_18.setVolume(1.0);
  text_86 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_86',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_87 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_87',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_88 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_88',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_89 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_89',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_90 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_90',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_18 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "AsaApsa"
  AsaApsaClock = new util.Clock();
  sound_vowels_22 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/AsaApsa.wav',
    secs: (- 1),
    });
  sound_vowels_22.setVolume(1.0);
  text_106 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_106',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_107 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_107',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_108 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_108',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_109 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_109',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_110 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_110',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_22 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "joAjoApA"
  joAjoApAClock = new util.Clock();
  sound_vowels_5 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/joAjoApA.wav',
    secs: (- 1),
    });
  sound_vowels_5.setVolume(1.0);
  text_21 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_21',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_22 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_22',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_23 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_23',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_24 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_24',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_25 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_25',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_5 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Initialize components for Routine "A_sa_sa"
  A_sa_saClock = new util.Clock();
  sound_vowels_7 = new sound.Sound({
    win: psychoJS.window,
    value: 'mainpairs/A.sa+sa.wav',
    secs: (- 1),
    });
  sound_vowels_7.setVolume(1.0);
  text_31 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_31',
    text: 'Next vowels will be played.\n\n',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -1.0 
  });
  
  text_32 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_32',
    text: 'If you think the voewls were the same. press "y" on your keyboard now. Otherwise, press "n".',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -2.0 
  });
  
  text_33 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_33',
    text: '3',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -3.0 
  });
  
  text_34 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_34',
    text: '2',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -4.0 
  });
  
  text_35 = new visual.TextStim({
    win: psychoJS.window,
    name: 'text_35',
    text: '1',
    font: 'Open Sans',
    units: undefined, 
    pos: [0, 0], height: 0.05,  wrapWidth: undefined, ori: 0.0,
    languageStyle: 'LTR',
    color: new util.Color('white'),  opacity: undefined,
    depth: -5.0 
  });
  
  key_resp_7 = new core.Keyboard({psychoJS: psychoJS, clock: new util.Clock(), waitForStart: true});
  
  // Create some handy timers
  globalClock = new util.Clock();  // to track the time since experiment started
  routineTimer = new util.CountdownTimer();  // to track time remaining of each (non-slip) routine
  
  return Scheduler.Event.NEXT;
}


var t;
var frameN;
var continueRoutine;
var _key_resp_allKeys;
var trialComponents;
function trialRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'trial' ---
    t = 0;
    trialClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(23.000000);
    // update component parameters for each repeat
    sound_vowels.secs=3.5;
    sound_vowels.setVolume(1.0);
    key_resp.keys = undefined;
    key_resp.rt = undefined;
    _key_resp_allKeys = [];
    // keep track of which components have finished
    trialComponents = [];
    trialComponents.push(sound_vowels);
    trialComponents.push(text);
    trialComponents.push(text_2);
    trialComponents.push(text_3);
    trialComponents.push(text_4);
    trialComponents.push(text_5);
    trialComponents.push(key_resp);
    
    trialComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


var frameRemains;
function trialRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'trial' ---
    // get current time
    t = trialClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels
    if (t >= 9 && sound_vowels.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels.tStart = t;  // (not accounting for frame time here)
      sound_vowels.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels.play(); });  // screen flip
      sound_vowels.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 9 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels.status = PsychoJS.Status.FINISHED;
    }
    
    // *text* updates
    if (t >= 0.0 && text.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text.tStart = t;  // (not accounting for frame time here)
      text.frameNStart = frameN;  // exact frame index
      
      text.setAutoDraw(true);
    }

    frameRemains = 0.0 + 5.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text.setAutoDraw(false);
    }
    
    // *text_2* updates
    if (t >= 13.0 && text_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_2.tStart = t;  // (not accounting for frame time here)
      text_2.frameNStart = frameN;  // exact frame index
      
      text_2.setAutoDraw(true);
    }

    frameRemains = 13.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_2.setAutoDraw(false);
    }
    
    // *text_3* updates
    if (t >= 6 && text_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_3.tStart = t;  // (not accounting for frame time here)
      text_3.frameNStart = frameN;  // exact frame index
      
      text_3.setAutoDraw(true);
    }

    frameRemains = 6 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_3.setAutoDraw(false);
    }
    
    // *text_4* updates
    if (t >= 7.0 && text_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_4.tStart = t;  // (not accounting for frame time here)
      text_4.frameNStart = frameN;  // exact frame index
      
      text_4.setAutoDraw(true);
    }

    frameRemains = 7.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_4.setAutoDraw(false);
    }
    
    // *text_5* updates
    if (t >= 8.0 && text_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_5.tStart = t;  // (not accounting for frame time here)
      text_5.frameNStart = frameN;  // exact frame index
      
      text_5.setAutoDraw(true);
    }

    frameRemains = 8.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_5.setAutoDraw(false);
    }
    
    // *key_resp* updates
    if (t >= 13.0 && key_resp.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp.tStart = t;  // (not accounting for frame time here)
      key_resp.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp.clearEvents(); });
    }

    frameRemains = 13.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_allKeys = _key_resp_allKeys.concat(theseKeys);
      if (_key_resp_allKeys.length > 0) {
        key_resp.keys = _key_resp_allKeys[_key_resp_allKeys.length - 1].name;  // just the last key pressed
        key_resp.rt = _key_resp_allKeys[_key_resp_allKeys.length - 1].rt;
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    trialComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function trialRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'trial' ---
    trialComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels.stop();  // ensure sound has stopped at end of routine
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp.corr, level);
    }
    psychoJS.experiment.addData('key_resp.keys', key_resp.keys);
    if (typeof key_resp.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp.rt', key_resp.rt);
        routineTimer.reset();
        }
    
    key_resp.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_2_allKeys;
var A_sa_A_sasecondComponents;
function A_sa_A_sasecondRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'A_sa_A_sasecond' ---
    t = 0;
    A_sa_A_sasecondClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(23.500000);
    // update component parameters for each repeat
    A_saandA_sa.secs=3.5;
    A_saandA_sa.setVolume(1.0);
    key_resp_2.keys = undefined;
    key_resp_2.rt = undefined;
    _key_resp_2_allKeys = [];
    // keep track of which components have finished
    A_sa_A_sasecondComponents = [];
    A_sa_A_sasecondComponents.push(A_saandA_sa);
    A_sa_A_sasecondComponents.push(text_6);
    A_sa_A_sasecondComponents.push(text_7);
    A_sa_A_sasecondComponents.push(text_8);
    A_sa_A_sasecondComponents.push(text_9);
    A_sa_A_sasecondComponents.push(text_10);
    A_sa_A_sasecondComponents.push(key_resp_2);
    
    A_sa_A_sasecondComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function A_sa_A_sasecondRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'A_sa_A_sasecond' ---
    // get current time
    t = A_sa_A_sasecondClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop A_saandA_sa
    if (t >= 9 && A_saandA_sa.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      A_saandA_sa.tStart = t;  // (not accounting for frame time here)
      A_saandA_sa.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ A_saandA_sa.play(); });  // screen flip
      A_saandA_sa.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 9 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (A_saandA_sa.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        A_saandA_sa.stop();  // stop the sound (if longer than duration)
      }
      A_saandA_sa.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_6* updates
    if (t >= 0.0 && text_6.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_6.tStart = t;  // (not accounting for frame time here)
      text_6.frameNStart = frameN;  // exact frame index
      
      text_6.setAutoDraw(true);
    }

    frameRemains = 0.0 + 5.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_6.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_6.setAutoDraw(false);
    }
    
    // *text_7* updates
    if (t >= 13.5 && text_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_7.tStart = t;  // (not accounting for frame time here)
      text_7.frameNStart = frameN;  // exact frame index
      
      text_7.setAutoDraw(true);
    }

    frameRemains = 13.5 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_7.setAutoDraw(false);
    }
    
    // *text_8* updates
    if (t >= 6 && text_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_8.tStart = t;  // (not accounting for frame time here)
      text_8.frameNStart = frameN;  // exact frame index
      
      text_8.setAutoDraw(true);
    }

    frameRemains = 6 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_8.setAutoDraw(false);
    }
    
    // *text_9* updates
    if (t >= 7.0 && text_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_9.tStart = t;  // (not accounting for frame time here)
      text_9.frameNStart = frameN;  // exact frame index
      
      text_9.setAutoDraw(true);
    }

    frameRemains = 7.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_9.setAutoDraw(false);
    }
    
    // *text_10* updates
    if (t >= 8.0 && text_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_10.tStart = t;  // (not accounting for frame time here)
      text_10.frameNStart = frameN;  // exact frame index
      
      text_10.setAutoDraw(true);
    }

    frameRemains = 8.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_10.setAutoDraw(false);
    }
    
    // *key_resp_2* updates
    if (t >= 13.5 && key_resp_2.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_2.tStart = t;  // (not accounting for frame time here)
      key_resp_2.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_2.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_2.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_2.clearEvents(); });
    }

    frameRemains = 13.5 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_2.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_2.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_2.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_2.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_2_allKeys = _key_resp_2_allKeys.concat(theseKeys);
      if (_key_resp_2_allKeys.length > 0) {
        key_resp_2.keys = _key_resp_2_allKeys[_key_resp_2_allKeys.length - 1].name;  // just the last key pressed
        key_resp_2.rt = _key_resp_2_allKeys[_key_resp_2_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_2.keys == 'y') {
            key_resp_2.corr = 1;
        } else {
            key_resp_2.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    A_sa_A_sasecondComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function A_sa_A_sasecondRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'A_sa_A_sasecond' ---
    A_sa_A_sasecondComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    A_saandA_sa.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_2.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_2.corr = 1;  // correct non-response
      } else {
         key_resp_2.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_2.corr, level);
    }
    psychoJS.experiment.addData('key_resp_2.keys', key_resp_2.keys);
    psychoJS.experiment.addData('key_resp_2.corr', key_resp_2.corr);
    if (typeof key_resp_2.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_2.rt', key_resp_2.rt);
        routineTimer.reset();
        }
    
    key_resp_2.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_91_allKeys;
var usousopuComponents;
function usousopuRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'usousopu' ---
    t = 0;
    usousopuClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_91.secs=3.5;
    sound_vowels_91.setVolume(1.0);
    key_resp_91.keys = undefined;
    key_resp_91.rt = undefined;
    _key_resp_91_allKeys = [];
    // keep track of which components have finished
    usousopuComponents = [];
    usousopuComponents.push(sound_vowels_91);
    usousopuComponents.push(text_451);
    usousopuComponents.push(text_452);
    usousopuComponents.push(text_453);
    usousopuComponents.push(text_454);
    usousopuComponents.push(text_455);
    usousopuComponents.push(key_resp_91);
    
    usousopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function usousopuRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'usousopu' ---
    // get current time
    t = usousopuClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_91
    if (t >= 5 && sound_vowels_91.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_91.tStart = t;  // (not accounting for frame time here)
      sound_vowels_91.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_91.play(); });  // screen flip
      sound_vowels_91.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_91.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_91.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_91.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_451* updates
    if (t >= 0.0 && text_451.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_451.tStart = t;  // (not accounting for frame time here)
      text_451.frameNStart = frameN;  // exact frame index
      
      text_451.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_451.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_451.setAutoDraw(false);
    }
    
    // *text_452* updates
    if (t >= 9.0 && text_452.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_452.tStart = t;  // (not accounting for frame time here)
      text_452.frameNStart = frameN;  // exact frame index
      
      text_452.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_452.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_452.setAutoDraw(false);
    }
    
    // *text_453* updates
    if (t >= 2 && text_453.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_453.tStart = t;  // (not accounting for frame time here)
      text_453.frameNStart = frameN;  // exact frame index
      
      text_453.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_453.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_453.setAutoDraw(false);
    }
    
    // *text_454* updates
    if (t >= 3.0 && text_454.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_454.tStart = t;  // (not accounting for frame time here)
      text_454.frameNStart = frameN;  // exact frame index
      
      text_454.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_454.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_454.setAutoDraw(false);
    }
    
    // *text_455* updates
    if (t >= 4.0 && text_455.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_455.tStart = t;  // (not accounting for frame time here)
      text_455.frameNStart = frameN;  // exact frame index
      
      text_455.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_455.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_455.setAutoDraw(false);
    }
    
    // *key_resp_91* updates
    if (t >= 9.0 && key_resp_91.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_91.tStart = t;  // (not accounting for frame time here)
      key_resp_91.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_91.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_91.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_91.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_91.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_91.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_91.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_91.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_91_allKeys = _key_resp_91_allKeys.concat(theseKeys);
      if (_key_resp_91_allKeys.length > 0) {
        key_resp_91.keys = _key_resp_91_allKeys[_key_resp_91_allKeys.length - 1].name;  // just the last key pressed
        key_resp_91.rt = _key_resp_91_allKeys[_key_resp_91_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_91.keys == 'n') {
            key_resp_91.corr = 1;
        } else {
            key_resp_91.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    usousopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function usousopuRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'usousopu' ---
    usousopuComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_91.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_91.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_91.corr = 1;  // correct non-response
      } else {
         key_resp_91.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_91.corr, level);
    }
    psychoJS.experiment.addData('key_resp_91.keys', key_resp_91.keys);
    psychoJS.experiment.addData('key_resp_91.corr', key_resp_91.corr);
    if (typeof key_resp_91.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_91.rt', key_resp_91.rt);
        routineTimer.reset();
        }
    
    key_resp_91.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_92_allKeys;
var uusopsoComponents;
function uusopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'uusopso' ---
    t = 0;
    uusopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_92.secs=3.5;
    sound_vowels_92.setVolume(1.0);
    key_resp_92.keys = undefined;
    key_resp_92.rt = undefined;
    _key_resp_92_allKeys = [];
    // keep track of which components have finished
    uusopsoComponents = [];
    uusopsoComponents.push(sound_vowels_92);
    uusopsoComponents.push(text_456);
    uusopsoComponents.push(text_457);
    uusopsoComponents.push(text_458);
    uusopsoComponents.push(text_459);
    uusopsoComponents.push(text_460);
    uusopsoComponents.push(key_resp_92);
    
    uusopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function uusopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'uusopso' ---
    // get current time
    t = uusopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_92
    if (t >= 5 && sound_vowels_92.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_92.tStart = t;  // (not accounting for frame time here)
      sound_vowels_92.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_92.play(); });  // screen flip
      sound_vowels_92.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_92.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_92.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_92.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_456* updates
    if (t >= 0.0 && text_456.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_456.tStart = t;  // (not accounting for frame time here)
      text_456.frameNStart = frameN;  // exact frame index
      
      text_456.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_456.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_456.setAutoDraw(false);
    }
    
    // *text_457* updates
    if (t >= 9.0 && text_457.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_457.tStart = t;  // (not accounting for frame time here)
      text_457.frameNStart = frameN;  // exact frame index
      
      text_457.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_457.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_457.setAutoDraw(false);
    }
    
    // *text_458* updates
    if (t >= 2 && text_458.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_458.tStart = t;  // (not accounting for frame time here)
      text_458.frameNStart = frameN;  // exact frame index
      
      text_458.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_458.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_458.setAutoDraw(false);
    }
    
    // *text_459* updates
    if (t >= 3.0 && text_459.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_459.tStart = t;  // (not accounting for frame time here)
      text_459.frameNStart = frameN;  // exact frame index
      
      text_459.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_459.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_459.setAutoDraw(false);
    }
    
    // *text_460* updates
    if (t >= 4.0 && text_460.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_460.tStart = t;  // (not accounting for frame time here)
      text_460.frameNStart = frameN;  // exact frame index
      
      text_460.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_460.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_460.setAutoDraw(false);
    }
    
    // *key_resp_92* updates
    if (t >= 9.0 && key_resp_92.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_92.tStart = t;  // (not accounting for frame time here)
      key_resp_92.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_92.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_92.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_92.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_92.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_92.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_92.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_92.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_92_allKeys = _key_resp_92_allKeys.concat(theseKeys);
      if (_key_resp_92_allKeys.length > 0) {
        key_resp_92.keys = _key_resp_92_allKeys[_key_resp_92_allKeys.length - 1].name;  // just the last key pressed
        key_resp_92.rt = _key_resp_92_allKeys[_key_resp_92_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_92.keys == 'n') {
            key_resp_92.corr = 1;
        } else {
            key_resp_92.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    uusopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function uusopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'uusopso' ---
    uusopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_92.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_92.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_92.corr = 1;  // correct non-response
      } else {
         key_resp_92.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_92.corr, level);
    }
    psychoJS.experiment.addData('key_resp_92.keys', key_resp_92.keys);
    psychoJS.experiment.addData('key_resp_92.corr', key_resp_92.corr);
    if (typeof key_resp_92.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_92.rt', key_resp_92.rt);
        routineTimer.reset();
        }
    
    key_resp_92.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_85_allKeys;
var sousopuComponents;
function sousopuRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sousopu' ---
    t = 0;
    sousopuClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_85.secs=3.5;
    sound_vowels_85.setVolume(1.0);
    key_resp_85.keys = undefined;
    key_resp_85.rt = undefined;
    _key_resp_85_allKeys = [];
    // keep track of which components have finished
    sousopuComponents = [];
    sousopuComponents.push(sound_vowels_85);
    sousopuComponents.push(text_421);
    sousopuComponents.push(text_422);
    sousopuComponents.push(text_423);
    sousopuComponents.push(text_424);
    sousopuComponents.push(text_425);
    sousopuComponents.push(key_resp_85);
    
    sousopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sousopuRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sousopu' ---
    // get current time
    t = sousopuClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_85
    if (t >= 5 && sound_vowels_85.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_85.tStart = t;  // (not accounting for frame time here)
      sound_vowels_85.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_85.play(); });  // screen flip
      sound_vowels_85.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_85.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_85.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_85.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_421* updates
    if (t >= 0.0 && text_421.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_421.tStart = t;  // (not accounting for frame time here)
      text_421.frameNStart = frameN;  // exact frame index
      
      text_421.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_421.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_421.setAutoDraw(false);
    }
    
    // *text_422* updates
    if (t >= 9.0 && text_422.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_422.tStart = t;  // (not accounting for frame time here)
      text_422.frameNStart = frameN;  // exact frame index
      
      text_422.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_422.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_422.setAutoDraw(false);
    }
    
    // *text_423* updates
    if (t >= 2 && text_423.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_423.tStart = t;  // (not accounting for frame time here)
      text_423.frameNStart = frameN;  // exact frame index
      
      text_423.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_423.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_423.setAutoDraw(false);
    }
    
    // *text_424* updates
    if (t >= 3.0 && text_424.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_424.tStart = t;  // (not accounting for frame time here)
      text_424.frameNStart = frameN;  // exact frame index
      
      text_424.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_424.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_424.setAutoDraw(false);
    }
    
    // *text_425* updates
    if (t >= 4.0 && text_425.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_425.tStart = t;  // (not accounting for frame time here)
      text_425.frameNStart = frameN;  // exact frame index
      
      text_425.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_425.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_425.setAutoDraw(false);
    }
    
    // *key_resp_85* updates
    if (t >= 9.0 && key_resp_85.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_85.tStart = t;  // (not accounting for frame time here)
      key_resp_85.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_85.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_85.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_85.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_85.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_85.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_85.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_85.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_85_allKeys = _key_resp_85_allKeys.concat(theseKeys);
      if (_key_resp_85_allKeys.length > 0) {
        key_resp_85.keys = _key_resp_85_allKeys[_key_resp_85_allKeys.length - 1].name;  // just the last key pressed
        key_resp_85.rt = _key_resp_85_allKeys[_key_resp_85_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_85.keys == 'n') {
            key_resp_85.corr = 1;
        } else {
            key_resp_85.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sousopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sousopuRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sousopu' ---
    sousopuComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_85.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_85.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_85.corr = 1;  // correct non-response
      } else {
         key_resp_85.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_85.corr, level);
    }
    psychoJS.experiment.addData('key_resp_85.keys', key_resp_85.keys);
    psychoJS.experiment.addData('key_resp_85.corr', key_resp_85.corr);
    if (typeof key_resp_85.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_85.rt', key_resp_85.rt);
        routineTimer.reset();
        }
    
    key_resp_85.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_77_allKeys;
var sa_ja_saComponents;
function sa_ja_saRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_sa' ---
    t = 0;
    sa_ja_saClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_77.secs=3.5;
    sound_vowels_77.setVolume(1.0);
    key_resp_77.keys = undefined;
    key_resp_77.rt = undefined;
    _key_resp_77_allKeys = [];
    // keep track of which components have finished
    sa_ja_saComponents = [];
    sa_ja_saComponents.push(sound_vowels_77);
    sa_ja_saComponents.push(text_381);
    sa_ja_saComponents.push(text_382);
    sa_ja_saComponents.push(text_383);
    sa_ja_saComponents.push(text_384);
    sa_ja_saComponents.push(text_385);
    sa_ja_saComponents.push(key_resp_77);
    
    sa_ja_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_saRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_sa' ---
    // get current time
    t = sa_ja_saClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_77
    if (t >= 5 && sound_vowels_77.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_77.tStart = t;  // (not accounting for frame time here)
      sound_vowels_77.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_77.play(); });  // screen flip
      sound_vowels_77.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_77.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_77.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_77.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_381* updates
    if (t >= 0.0 && text_381.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_381.tStart = t;  // (not accounting for frame time here)
      text_381.frameNStart = frameN;  // exact frame index
      
      text_381.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_381.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_381.setAutoDraw(false);
    }
    
    // *text_382* updates
    if (t >= 9.0 && text_382.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_382.tStart = t;  // (not accounting for frame time here)
      text_382.frameNStart = frameN;  // exact frame index
      
      text_382.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_382.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_382.setAutoDraw(false);
    }
    
    // *text_383* updates
    if (t >= 2 && text_383.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_383.tStart = t;  // (not accounting for frame time here)
      text_383.frameNStart = frameN;  // exact frame index
      
      text_383.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_383.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_383.setAutoDraw(false);
    }
    
    // *text_384* updates
    if (t >= 3.0 && text_384.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_384.tStart = t;  // (not accounting for frame time here)
      text_384.frameNStart = frameN;  // exact frame index
      
      text_384.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_384.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_384.setAutoDraw(false);
    }
    
    // *text_385* updates
    if (t >= 4.0 && text_385.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_385.tStart = t;  // (not accounting for frame time here)
      text_385.frameNStart = frameN;  // exact frame index
      
      text_385.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_385.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_385.setAutoDraw(false);
    }
    
    // *key_resp_77* updates
    if (t >= 9.0 && key_resp_77.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_77.tStart = t;  // (not accounting for frame time here)
      key_resp_77.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_77.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_77.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_77.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_77.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_77.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_77.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_77.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_77_allKeys = _key_resp_77_allKeys.concat(theseKeys);
      if (_key_resp_77_allKeys.length > 0) {
        key_resp_77.keys = _key_resp_77_allKeys[_key_resp_77_allKeys.length - 1].name;  // just the last key pressed
        key_resp_77.rt = _key_resp_77_allKeys[_key_resp_77_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_77.keys == 'y') {
            key_resp_77.corr = 1;
        } else {
            key_resp_77.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_saRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_sa' ---
    sa_ja_saComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_77.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_77.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_77.corr = 1;  // correct non-response
      } else {
         key_resp_77.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_77.corr, level);
    }
    psychoJS.experiment.addData('key_resp_77.keys', key_resp_77.keys);
    psychoJS.experiment.addData('key_resp_77.corr', key_resp_77.corr);
    if (typeof key_resp_77.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_77.rt', key_resp_77.rt);
        routineTimer.reset();
        }
    
    key_resp_77.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_86_allKeys;
var u_so_soComponents;
function u_so_soRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'u_so_so' ---
    t = 0;
    u_so_soClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_86.secs=3.5;
    sound_vowels_86.setVolume(1.0);
    key_resp_86.keys = undefined;
    key_resp_86.rt = undefined;
    _key_resp_86_allKeys = [];
    // keep track of which components have finished
    u_so_soComponents = [];
    u_so_soComponents.push(sound_vowels_86);
    u_so_soComponents.push(text_426);
    u_so_soComponents.push(text_427);
    u_so_soComponents.push(text_428);
    u_so_soComponents.push(text_429);
    u_so_soComponents.push(text_430);
    u_so_soComponents.push(key_resp_86);
    
    u_so_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function u_so_soRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'u_so_so' ---
    // get current time
    t = u_so_soClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_86
    if (t >= 5 && sound_vowels_86.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_86.tStart = t;  // (not accounting for frame time here)
      sound_vowels_86.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_86.play(); });  // screen flip
      sound_vowels_86.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_86.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_86.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_86.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_426* updates
    if (t >= 0.0 && text_426.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_426.tStart = t;  // (not accounting for frame time here)
      text_426.frameNStart = frameN;  // exact frame index
      
      text_426.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_426.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_426.setAutoDraw(false);
    }
    
    // *text_427* updates
    if (t >= 9.0 && text_427.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_427.tStart = t;  // (not accounting for frame time here)
      text_427.frameNStart = frameN;  // exact frame index
      
      text_427.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_427.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_427.setAutoDraw(false);
    }
    
    // *text_428* updates
    if (t >= 2 && text_428.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_428.tStart = t;  // (not accounting for frame time here)
      text_428.frameNStart = frameN;  // exact frame index
      
      text_428.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_428.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_428.setAutoDraw(false);
    }
    
    // *text_429* updates
    if (t >= 3.0 && text_429.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_429.tStart = t;  // (not accounting for frame time here)
      text_429.frameNStart = frameN;  // exact frame index
      
      text_429.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_429.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_429.setAutoDraw(false);
    }
    
    // *text_430* updates
    if (t >= 4.0 && text_430.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_430.tStart = t;  // (not accounting for frame time here)
      text_430.frameNStart = frameN;  // exact frame index
      
      text_430.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_430.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_430.setAutoDraw(false);
    }
    
    // *key_resp_86* updates
    if (t >= 9.0 && key_resp_86.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_86.tStart = t;  // (not accounting for frame time here)
      key_resp_86.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_86.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_86.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_86.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_86.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_86.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_86.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_86.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_86_allKeys = _key_resp_86_allKeys.concat(theseKeys);
      if (_key_resp_86_allKeys.length > 0) {
        key_resp_86.keys = _key_resp_86_allKeys[_key_resp_86_allKeys.length - 1].name;  // just the last key pressed
        key_resp_86.rt = _key_resp_86_allKeys[_key_resp_86_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_86.keys == 'y') {
            key_resp_86.corr = 1;
        } else {
            key_resp_86.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    u_so_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function u_so_soRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'u_so_so' ---
    u_so_soComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_86.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_86.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_86.corr = 1;  // correct non-response
      } else {
         key_resp_86.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_86.corr, level);
    }
    psychoJS.experiment.addData('key_resp_86.keys', key_resp_86.keys);
    psychoJS.experiment.addData('key_resp_86.corr', key_resp_86.corr);
    if (typeof key_resp_86.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_86.rt', key_resp_86.rt);
        routineTimer.reset();
        }
    
    key_resp_86.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_45_allKeys;
var sojojopjoComponents;
function sojojopjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sojojopjo' ---
    t = 0;
    sojojopjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_45.secs=3.5;
    sound_vowels_45.setVolume(1.0);
    key_resp_45.keys = undefined;
    key_resp_45.rt = undefined;
    _key_resp_45_allKeys = [];
    // keep track of which components have finished
    sojojopjoComponents = [];
    sojojopjoComponents.push(sound_vowels_45);
    sojojopjoComponents.push(text_221);
    sojojopjoComponents.push(text_222);
    sojojopjoComponents.push(text_223);
    sojojopjoComponents.push(text_224);
    sojojopjoComponents.push(text_225);
    sojojopjoComponents.push(key_resp_45);
    
    sojojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sojojopjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sojojopjo' ---
    // get current time
    t = sojojopjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_45
    if (t >= 5 && sound_vowels_45.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_45.tStart = t;  // (not accounting for frame time here)
      sound_vowels_45.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_45.play(); });  // screen flip
      sound_vowels_45.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_45.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_45.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_45.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_221* updates
    if (t >= 0.0 && text_221.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_221.tStart = t;  // (not accounting for frame time here)
      text_221.frameNStart = frameN;  // exact frame index
      
      text_221.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_221.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_221.setAutoDraw(false);
    }
    
    // *text_222* updates
    if (t >= 9.0 && text_222.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_222.tStart = t;  // (not accounting for frame time here)
      text_222.frameNStart = frameN;  // exact frame index
      
      text_222.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_222.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_222.setAutoDraw(false);
    }
    
    // *text_223* updates
    if (t >= 2 && text_223.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_223.tStart = t;  // (not accounting for frame time here)
      text_223.frameNStart = frameN;  // exact frame index
      
      text_223.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_223.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_223.setAutoDraw(false);
    }
    
    // *text_224* updates
    if (t >= 3.0 && text_224.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_224.tStart = t;  // (not accounting for frame time here)
      text_224.frameNStart = frameN;  // exact frame index
      
      text_224.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_224.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_224.setAutoDraw(false);
    }
    
    // *text_225* updates
    if (t >= 4.0 && text_225.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_225.tStart = t;  // (not accounting for frame time here)
      text_225.frameNStart = frameN;  // exact frame index
      
      text_225.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_225.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_225.setAutoDraw(false);
    }
    
    // *key_resp_45* updates
    if (t >= 9.0 && key_resp_45.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_45.tStart = t;  // (not accounting for frame time here)
      key_resp_45.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_45.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_45.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_45.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_45.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_45.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_45.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_45.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_45_allKeys = _key_resp_45_allKeys.concat(theseKeys);
      if (_key_resp_45_allKeys.length > 0) {
        key_resp_45.keys = _key_resp_45_allKeys[_key_resp_45_allKeys.length - 1].name;  // just the last key pressed
        key_resp_45.rt = _key_resp_45_allKeys[_key_resp_45_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_45.keys == 'n') {
            key_resp_45.corr = 1;
        } else {
            key_resp_45.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sojojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sojojopjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sojojopjo' ---
    sojojopjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_45.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_45.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_45.corr = 1;  // correct non-response
      } else {
         key_resp_45.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_45.corr, level);
    }
    psychoJS.experiment.addData('key_resp_45.keys', key_resp_45.keys);
    psychoJS.experiment.addData('key_resp_45.corr', key_resp_45.corr);
    if (typeof key_resp_45.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_45.rt', key_resp_45.rt);
        routineTimer.reset();
        }
    
    key_resp_45.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_87_allKeys;
var u_so_u_soComponents;
function u_so_u_soRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'u_so_u_so' ---
    t = 0;
    u_so_u_soClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_87.secs=3.5;
    sound_vowels_87.setVolume(1.0);
    key_resp_87.keys = undefined;
    key_resp_87.rt = undefined;
    _key_resp_87_allKeys = [];
    // keep track of which components have finished
    u_so_u_soComponents = [];
    u_so_u_soComponents.push(sound_vowels_87);
    u_so_u_soComponents.push(text_431);
    u_so_u_soComponents.push(text_432);
    u_so_u_soComponents.push(text_433);
    u_so_u_soComponents.push(text_434);
    u_so_u_soComponents.push(text_435);
    u_so_u_soComponents.push(key_resp_87);
    
    u_so_u_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function u_so_u_soRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'u_so_u_so' ---
    // get current time
    t = u_so_u_soClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_87
    if (t >= 5 && sound_vowels_87.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_87.tStart = t;  // (not accounting for frame time here)
      sound_vowels_87.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_87.play(); });  // screen flip
      sound_vowels_87.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_87.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_87.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_87.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_431* updates
    if (t >= 0.0 && text_431.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_431.tStart = t;  // (not accounting for frame time here)
      text_431.frameNStart = frameN;  // exact frame index
      
      text_431.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_431.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_431.setAutoDraw(false);
    }
    
    // *text_432* updates
    if (t >= 9.0 && text_432.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_432.tStart = t;  // (not accounting for frame time here)
      text_432.frameNStart = frameN;  // exact frame index
      
      text_432.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_432.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_432.setAutoDraw(false);
    }
    
    // *text_433* updates
    if (t >= 2 && text_433.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_433.tStart = t;  // (not accounting for frame time here)
      text_433.frameNStart = frameN;  // exact frame index
      
      text_433.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_433.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_433.setAutoDraw(false);
    }
    
    // *text_434* updates
    if (t >= 3.0 && text_434.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_434.tStart = t;  // (not accounting for frame time here)
      text_434.frameNStart = frameN;  // exact frame index
      
      text_434.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_434.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_434.setAutoDraw(false);
    }
    
    // *text_435* updates
    if (t >= 4.0 && text_435.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_435.tStart = t;  // (not accounting for frame time here)
      text_435.frameNStart = frameN;  // exact frame index
      
      text_435.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_435.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_435.setAutoDraw(false);
    }
    
    // *key_resp_87* updates
    if (t >= 9.0 && key_resp_87.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_87.tStart = t;  // (not accounting for frame time here)
      key_resp_87.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_87.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_87.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_87.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_87.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_87.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_87.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_87.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_87_allKeys = _key_resp_87_allKeys.concat(theseKeys);
      if (_key_resp_87_allKeys.length > 0) {
        key_resp_87.keys = _key_resp_87_allKeys[_key_resp_87_allKeys.length - 1].name;  // just the last key pressed
        key_resp_87.rt = _key_resp_87_allKeys[_key_resp_87_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_87.keys == 'y') {
            key_resp_87.corr = 1;
        } else {
            key_resp_87.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    u_so_u_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function u_so_u_soRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'u_so_u_so' ---
    u_so_u_soComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_87.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_87.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_87.corr = 1;  // correct non-response
      } else {
         key_resp_87.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_87.corr, level);
    }
    psychoJS.experiment.addData('key_resp_87.keys', key_resp_87.keys);
    psychoJS.experiment.addData('key_resp_87.corr', key_resp_87.corr);
    if (typeof key_resp_87.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_87.rt', key_resp_87.rt);
        routineTimer.reset();
        }
    
    key_resp_87.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_76_allKeys;
var sa_ja_sa_jaComponents;
function sa_ja_sa_jaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_sa_ja' ---
    t = 0;
    sa_ja_sa_jaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_76.secs=3.5;
    sound_vowels_76.setVolume(1.0);
    key_resp_76.keys = undefined;
    key_resp_76.rt = undefined;
    _key_resp_76_allKeys = [];
    // keep track of which components have finished
    sa_ja_sa_jaComponents = [];
    sa_ja_sa_jaComponents.push(sound_vowels_76);
    sa_ja_sa_jaComponents.push(text_376);
    sa_ja_sa_jaComponents.push(text_377);
    sa_ja_sa_jaComponents.push(text_378);
    sa_ja_sa_jaComponents.push(text_379);
    sa_ja_sa_jaComponents.push(text_380);
    sa_ja_sa_jaComponents.push(key_resp_76);
    
    sa_ja_sa_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_sa_jaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_sa_ja' ---
    // get current time
    t = sa_ja_sa_jaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_76
    if (t >= 5 && sound_vowels_76.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_76.tStart = t;  // (not accounting for frame time here)
      sound_vowels_76.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_76.play(); });  // screen flip
      sound_vowels_76.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_76.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_76.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_76.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_376* updates
    if (t >= 0.0 && text_376.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_376.tStart = t;  // (not accounting for frame time here)
      text_376.frameNStart = frameN;  // exact frame index
      
      text_376.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_376.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_376.setAutoDraw(false);
    }
    
    // *text_377* updates
    if (t >= 9.0 && text_377.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_377.tStart = t;  // (not accounting for frame time here)
      text_377.frameNStart = frameN;  // exact frame index
      
      text_377.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_377.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_377.setAutoDraw(false);
    }
    
    // *text_378* updates
    if (t >= 2 && text_378.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_378.tStart = t;  // (not accounting for frame time here)
      text_378.frameNStart = frameN;  // exact frame index
      
      text_378.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_378.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_378.setAutoDraw(false);
    }
    
    // *text_379* updates
    if (t >= 3.0 && text_379.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_379.tStart = t;  // (not accounting for frame time here)
      text_379.frameNStart = frameN;  // exact frame index
      
      text_379.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_379.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_379.setAutoDraw(false);
    }
    
    // *text_380* updates
    if (t >= 4.0 && text_380.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_380.tStart = t;  // (not accounting for frame time here)
      text_380.frameNStart = frameN;  // exact frame index
      
      text_380.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_380.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_380.setAutoDraw(false);
    }
    
    // *key_resp_76* updates
    if (t >= 9.0 && key_resp_76.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_76.tStart = t;  // (not accounting for frame time here)
      key_resp_76.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_76.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_76.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_76.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_76.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_76.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_76.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_76.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_76_allKeys = _key_resp_76_allKeys.concat(theseKeys);
      if (_key_resp_76_allKeys.length > 0) {
        key_resp_76.keys = _key_resp_76_allKeys[_key_resp_76_allKeys.length - 1].name;  // just the last key pressed
        key_resp_76.rt = _key_resp_76_allKeys[_key_resp_76_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_76.keys == 'y') {
            key_resp_76.corr = 1;
        } else {
            key_resp_76.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_sa_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_sa_jaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_sa_ja' ---
    sa_ja_sa_jaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_76.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_76.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_76.corr = 1;  // correct non-response
      } else {
         key_resp_76.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_76.corr, level);
    }
    psychoJS.experiment.addData('key_resp_76.keys', key_resp_76.keys);
    psychoJS.experiment.addData('key_resp_76.corr', key_resp_76.corr);
    if (typeof key_resp_76.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_76.rt', key_resp_76.rt);
        routineTimer.reset();
        }
    
    key_resp_76.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_84_allKeys;
var so_u_soComponents;
function so_u_soRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'so_u_so' ---
    t = 0;
    so_u_soClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_84.secs=3.5;
    sound_vowels_84.setVolume(1.0);
    key_resp_84.keys = undefined;
    key_resp_84.rt = undefined;
    _key_resp_84_allKeys = [];
    // keep track of which components have finished
    so_u_soComponents = [];
    so_u_soComponents.push(sound_vowels_84);
    so_u_soComponents.push(text_416);
    so_u_soComponents.push(text_417);
    so_u_soComponents.push(text_418);
    so_u_soComponents.push(text_419);
    so_u_soComponents.push(text_420);
    so_u_soComponents.push(key_resp_84);
    
    so_u_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function so_u_soRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'so_u_so' ---
    // get current time
    t = so_u_soClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_84
    if (t >= 5 && sound_vowels_84.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_84.tStart = t;  // (not accounting for frame time here)
      sound_vowels_84.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_84.play(); });  // screen flip
      sound_vowels_84.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_84.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_84.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_84.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_416* updates
    if (t >= 0.0 && text_416.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_416.tStart = t;  // (not accounting for frame time here)
      text_416.frameNStart = frameN;  // exact frame index
      
      text_416.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_416.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_416.setAutoDraw(false);
    }
    
    // *text_417* updates
    if (t >= 9.0 && text_417.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_417.tStart = t;  // (not accounting for frame time here)
      text_417.frameNStart = frameN;  // exact frame index
      
      text_417.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_417.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_417.setAutoDraw(false);
    }
    
    // *text_418* updates
    if (t >= 2 && text_418.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_418.tStart = t;  // (not accounting for frame time here)
      text_418.frameNStart = frameN;  // exact frame index
      
      text_418.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_418.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_418.setAutoDraw(false);
    }
    
    // *text_419* updates
    if (t >= 3.0 && text_419.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_419.tStart = t;  // (not accounting for frame time here)
      text_419.frameNStart = frameN;  // exact frame index
      
      text_419.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_419.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_419.setAutoDraw(false);
    }
    
    // *text_420* updates
    if (t >= 4.0 && text_420.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_420.tStart = t;  // (not accounting for frame time here)
      text_420.frameNStart = frameN;  // exact frame index
      
      text_420.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_420.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_420.setAutoDraw(false);
    }
    
    // *key_resp_84* updates
    if (t >= 9.0 && key_resp_84.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_84.tStart = t;  // (not accounting for frame time here)
      key_resp_84.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_84.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_84.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_84.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_84.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_84.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_84.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_84.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_84_allKeys = _key_resp_84_allKeys.concat(theseKeys);
      if (_key_resp_84_allKeys.length > 0) {
        key_resp_84.keys = _key_resp_84_allKeys[_key_resp_84_allKeys.length - 1].name;  // just the last key pressed
        key_resp_84.rt = _key_resp_84_allKeys[_key_resp_84_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_84.keys == 'y') {
            key_resp_84.corr = 1;
        } else {
            key_resp_84.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    so_u_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function so_u_soRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'so_u_so' ---
    so_u_soComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_84.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_84.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_84.corr = 1;  // correct non-response
      } else {
         key_resp_84.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_84.corr, level);
    }
    psychoJS.experiment.addData('key_resp_84.keys', key_resp_84.keys);
    psychoJS.experiment.addData('key_resp_84.corr', key_resp_84.corr);
    if (typeof key_resp_84.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_84.rt', key_resp_84.rt);
        routineTimer.reset();
        }
    
    key_resp_84.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_73_allKeys;
var jo_jo_AComponents;
function jo_jo_ARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jo_jo_A' ---
    t = 0;
    jo_jo_AClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_73.secs=3.5;
    sound_vowels_73.setVolume(1.0);
    key_resp_73.keys = undefined;
    key_resp_73.rt = undefined;
    _key_resp_73_allKeys = [];
    // keep track of which components have finished
    jo_jo_AComponents = [];
    jo_jo_AComponents.push(sound_vowels_73);
    jo_jo_AComponents.push(text_361);
    jo_jo_AComponents.push(text_362);
    jo_jo_AComponents.push(text_363);
    jo_jo_AComponents.push(text_364);
    jo_jo_AComponents.push(text_365);
    jo_jo_AComponents.push(key_resp_73);
    
    jo_jo_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jo_jo_ARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jo_jo_A' ---
    // get current time
    t = jo_jo_AClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_73
    if (t >= 5 && sound_vowels_73.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_73.tStart = t;  // (not accounting for frame time here)
      sound_vowels_73.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_73.play(); });  // screen flip
      sound_vowels_73.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_73.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_73.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_73.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_361* updates
    if (t >= 0.0 && text_361.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_361.tStart = t;  // (not accounting for frame time here)
      text_361.frameNStart = frameN;  // exact frame index
      
      text_361.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_361.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_361.setAutoDraw(false);
    }
    
    // *text_362* updates
    if (t >= 9.0 && text_362.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_362.tStart = t;  // (not accounting for frame time here)
      text_362.frameNStart = frameN;  // exact frame index
      
      text_362.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_362.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_362.setAutoDraw(false);
    }
    
    // *text_363* updates
    if (t >= 2 && text_363.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_363.tStart = t;  // (not accounting for frame time here)
      text_363.frameNStart = frameN;  // exact frame index
      
      text_363.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_363.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_363.setAutoDraw(false);
    }
    
    // *text_364* updates
    if (t >= 3.0 && text_364.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_364.tStart = t;  // (not accounting for frame time here)
      text_364.frameNStart = frameN;  // exact frame index
      
      text_364.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_364.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_364.setAutoDraw(false);
    }
    
    // *text_365* updates
    if (t >= 4.0 && text_365.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_365.tStart = t;  // (not accounting for frame time here)
      text_365.frameNStart = frameN;  // exact frame index
      
      text_365.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_365.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_365.setAutoDraw(false);
    }
    
    // *key_resp_73* updates
    if (t >= 9.0 && key_resp_73.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_73.tStart = t;  // (not accounting for frame time here)
      key_resp_73.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_73.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_73.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_73.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_73.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_73.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_73.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_73.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_73_allKeys = _key_resp_73_allKeys.concat(theseKeys);
      if (_key_resp_73_allKeys.length > 0) {
        key_resp_73.keys = _key_resp_73_allKeys[_key_resp_73_allKeys.length - 1].name;  // just the last key pressed
        key_resp_73.rt = _key_resp_73_allKeys[_key_resp_73_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_73.keys == 'y') {
            key_resp_73.corr = 1;
        } else {
            key_resp_73.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jo_jo_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jo_jo_ARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jo_jo_A' ---
    jo_jo_AComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_73.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_73.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_73.corr = 1;  // correct non-response
      } else {
         key_resp_73.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_73.corr, level);
    }
    psychoJS.experiment.addData('key_resp_73.keys', key_resp_73.keys);
    psychoJS.experiment.addData('key_resp_73.corr', key_resp_73.corr);
    if (typeof key_resp_73.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_73.rt', key_resp_73.rt);
        routineTimer.reset();
        }
    
    key_resp_73.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_88_allKeys;
var u_so_uComponents;
function u_so_uRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'u_so_u' ---
    t = 0;
    u_so_uClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_88.secs=3.5;
    sound_vowels_88.setVolume(1.0);
    key_resp_88.keys = undefined;
    key_resp_88.rt = undefined;
    _key_resp_88_allKeys = [];
    // keep track of which components have finished
    u_so_uComponents = [];
    u_so_uComponents.push(sound_vowels_88);
    u_so_uComponents.push(text_436);
    u_so_uComponents.push(text_437);
    u_so_uComponents.push(text_438);
    u_so_uComponents.push(text_439);
    u_so_uComponents.push(text_440);
    u_so_uComponents.push(key_resp_88);
    
    u_so_uComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function u_so_uRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'u_so_u' ---
    // get current time
    t = u_so_uClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_88
    if (t >= 5 && sound_vowels_88.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_88.tStart = t;  // (not accounting for frame time here)
      sound_vowels_88.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_88.play(); });  // screen flip
      sound_vowels_88.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_88.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_88.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_88.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_436* updates
    if (t >= 0.0 && text_436.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_436.tStart = t;  // (not accounting for frame time here)
      text_436.frameNStart = frameN;  // exact frame index
      
      text_436.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_436.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_436.setAutoDraw(false);
    }
    
    // *text_437* updates
    if (t >= 9.0 && text_437.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_437.tStart = t;  // (not accounting for frame time here)
      text_437.frameNStart = frameN;  // exact frame index
      
      text_437.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_437.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_437.setAutoDraw(false);
    }
    
    // *text_438* updates
    if (t >= 2 && text_438.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_438.tStart = t;  // (not accounting for frame time here)
      text_438.frameNStart = frameN;  // exact frame index
      
      text_438.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_438.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_438.setAutoDraw(false);
    }
    
    // *text_439* updates
    if (t >= 3.0 && text_439.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_439.tStart = t;  // (not accounting for frame time here)
      text_439.frameNStart = frameN;  // exact frame index
      
      text_439.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_439.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_439.setAutoDraw(false);
    }
    
    // *text_440* updates
    if (t >= 4.0 && text_440.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_440.tStart = t;  // (not accounting for frame time here)
      text_440.frameNStart = frameN;  // exact frame index
      
      text_440.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_440.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_440.setAutoDraw(false);
    }
    
    // *key_resp_88* updates
    if (t >= 9.0 && key_resp_88.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_88.tStart = t;  // (not accounting for frame time here)
      key_resp_88.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_88.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_88.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_88.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_88.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_88.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_88.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_88.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_88_allKeys = _key_resp_88_allKeys.concat(theseKeys);
      if (_key_resp_88_allKeys.length > 0) {
        key_resp_88.keys = _key_resp_88_allKeys[_key_resp_88_allKeys.length - 1].name;  // just the last key pressed
        key_resp_88.rt = _key_resp_88_allKeys[_key_resp_88_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_88.keys == 'y') {
            key_resp_88.corr = 1;
        } else {
            key_resp_88.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    u_so_uComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function u_so_uRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'u_so_u' ---
    u_so_uComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_88.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_88.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_88.corr = 1;  // correct non-response
      } else {
         key_resp_88.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_88.corr, level);
    }
    psychoJS.experiment.addData('key_resp_88.keys', key_resp_88.keys);
    psychoJS.experiment.addData('key_resp_88.corr', key_resp_88.corr);
    if (typeof key_resp_88.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_88.rt', key_resp_88.rt);
        routineTimer.reset();
        }
    
    key_resp_88.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_75_allKeys;
var sa_ja_jaComponents;
function sa_ja_jaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_ja' ---
    t = 0;
    sa_ja_jaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_75.secs=3.5;
    sound_vowels_75.setVolume(1.0);
    key_resp_75.keys = undefined;
    key_resp_75.rt = undefined;
    _key_resp_75_allKeys = [];
    // keep track of which components have finished
    sa_ja_jaComponents = [];
    sa_ja_jaComponents.push(sound_vowels_75);
    sa_ja_jaComponents.push(text_371);
    sa_ja_jaComponents.push(text_372);
    sa_ja_jaComponents.push(text_373);
    sa_ja_jaComponents.push(text_374);
    sa_ja_jaComponents.push(text_375);
    sa_ja_jaComponents.push(key_resp_75);
    
    sa_ja_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_jaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_ja' ---
    // get current time
    t = sa_ja_jaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_75
    if (t >= 5 && sound_vowels_75.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_75.tStart = t;  // (not accounting for frame time here)
      sound_vowels_75.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_75.play(); });  // screen flip
      sound_vowels_75.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_75.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_75.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_75.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_371* updates
    if (t >= 0.0 && text_371.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_371.tStart = t;  // (not accounting for frame time here)
      text_371.frameNStart = frameN;  // exact frame index
      
      text_371.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_371.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_371.setAutoDraw(false);
    }
    
    // *text_372* updates
    if (t >= 9.0 && text_372.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_372.tStart = t;  // (not accounting for frame time here)
      text_372.frameNStart = frameN;  // exact frame index
      
      text_372.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_372.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_372.setAutoDraw(false);
    }
    
    // *text_373* updates
    if (t >= 2 && text_373.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_373.tStart = t;  // (not accounting for frame time here)
      text_373.frameNStart = frameN;  // exact frame index
      
      text_373.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_373.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_373.setAutoDraw(false);
    }
    
    // *text_374* updates
    if (t >= 3.0 && text_374.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_374.tStart = t;  // (not accounting for frame time here)
      text_374.frameNStart = frameN;  // exact frame index
      
      text_374.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_374.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_374.setAutoDraw(false);
    }
    
    // *text_375* updates
    if (t >= 4.0 && text_375.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_375.tStart = t;  // (not accounting for frame time here)
      text_375.frameNStart = frameN;  // exact frame index
      
      text_375.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_375.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_375.setAutoDraw(false);
    }
    
    // *key_resp_75* updates
    if (t >= 9.0 && key_resp_75.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_75.tStart = t;  // (not accounting for frame time here)
      key_resp_75.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_75.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_75.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_75.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_75.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_75.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_75.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_75.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_75_allKeys = _key_resp_75_allKeys.concat(theseKeys);
      if (_key_resp_75_allKeys.length > 0) {
        key_resp_75.keys = _key_resp_75_allKeys[_key_resp_75_allKeys.length - 1].name;  // just the last key pressed
        key_resp_75.rt = _key_resp_75_allKeys[_key_resp_75_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_75.keys == 'y') {
            key_resp_75.corr = 1;
        } else {
            key_resp_75.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_jaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_ja' ---
    sa_ja_jaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_75.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_75.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_75.corr = 1;  // correct non-response
      } else {
         key_resp_75.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_75.corr, level);
    }
    psychoJS.experiment.addData('key_resp_75.keys', key_resp_75.keys);
    psychoJS.experiment.addData('key_resp_75.corr', key_resp_75.corr);
    if (typeof key_resp_75.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_75.rt', key_resp_75.rt);
        routineTimer.reset();
        }
    
    key_resp_75.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_89_allKeys;
var usosopuComponents;
function usosopuRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'usosopu' ---
    t = 0;
    usosopuClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_89.secs=3.5;
    sound_vowels_89.setVolume(1.0);
    key_resp_89.keys = undefined;
    key_resp_89.rt = undefined;
    _key_resp_89_allKeys = [];
    // keep track of which components have finished
    usosopuComponents = [];
    usosopuComponents.push(sound_vowels_89);
    usosopuComponents.push(text_441);
    usosopuComponents.push(text_442);
    usosopuComponents.push(text_443);
    usosopuComponents.push(text_444);
    usosopuComponents.push(text_445);
    usosopuComponents.push(key_resp_89);
    
    usosopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function usosopuRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'usosopu' ---
    // get current time
    t = usosopuClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_89
    if (t >= 5 && sound_vowels_89.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_89.tStart = t;  // (not accounting for frame time here)
      sound_vowels_89.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_89.play(); });  // screen flip
      sound_vowels_89.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_89.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_89.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_89.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_441* updates
    if (t >= 0.0 && text_441.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_441.tStart = t;  // (not accounting for frame time here)
      text_441.frameNStart = frameN;  // exact frame index
      
      text_441.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_441.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_441.setAutoDraw(false);
    }
    
    // *text_442* updates
    if (t >= 9.0 && text_442.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_442.tStart = t;  // (not accounting for frame time here)
      text_442.frameNStart = frameN;  // exact frame index
      
      text_442.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_442.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_442.setAutoDraw(false);
    }
    
    // *text_443* updates
    if (t >= 2 && text_443.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_443.tStart = t;  // (not accounting for frame time here)
      text_443.frameNStart = frameN;  // exact frame index
      
      text_443.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_443.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_443.setAutoDraw(false);
    }
    
    // *text_444* updates
    if (t >= 3.0 && text_444.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_444.tStart = t;  // (not accounting for frame time here)
      text_444.frameNStart = frameN;  // exact frame index
      
      text_444.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_444.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_444.setAutoDraw(false);
    }
    
    // *text_445* updates
    if (t >= 4.0 && text_445.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_445.tStart = t;  // (not accounting for frame time here)
      text_445.frameNStart = frameN;  // exact frame index
      
      text_445.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_445.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_445.setAutoDraw(false);
    }
    
    // *key_resp_89* updates
    if (t >= 9.0 && key_resp_89.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_89.tStart = t;  // (not accounting for frame time here)
      key_resp_89.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_89.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_89.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_89.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_89.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_89.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_89.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_89.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_89_allKeys = _key_resp_89_allKeys.concat(theseKeys);
      if (_key_resp_89_allKeys.length > 0) {
        key_resp_89.keys = _key_resp_89_allKeys[_key_resp_89_allKeys.length - 1].name;  // just the last key pressed
        key_resp_89.rt = _key_resp_89_allKeys[_key_resp_89_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_89.keys == 'n') {
            key_resp_89.corr = 1;
        } else {
            key_resp_89.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    usosopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function usosopuRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'usosopu' ---
    usosopuComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_89.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_89.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_89.corr = 1;  // correct non-response
      } else {
         key_resp_89.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_89.corr, level);
    }
    psychoJS.experiment.addData('key_resp_89.keys', key_resp_89.keys);
    psychoJS.experiment.addData('key_resp_89.corr', key_resp_89.corr);
    if (typeof key_resp_89.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_89.rt', key_resp_89.rt);
        routineTimer.reset();
        }
    
    key_resp_89.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_83_allKeys;
var so_so_joComponents;
function so_so_joRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'so_so_jo' ---
    t = 0;
    so_so_joClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_83.secs=3.5;
    sound_vowels_83.setVolume(1.0);
    key_resp_83.keys = undefined;
    key_resp_83.rt = undefined;
    _key_resp_83_allKeys = [];
    // keep track of which components have finished
    so_so_joComponents = [];
    so_so_joComponents.push(sound_vowels_83);
    so_so_joComponents.push(text_411);
    so_so_joComponents.push(text_412);
    so_so_joComponents.push(text_413);
    so_so_joComponents.push(text_414);
    so_so_joComponents.push(text_415);
    so_so_joComponents.push(key_resp_83);
    
    so_so_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function so_so_joRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'so_so_jo' ---
    // get current time
    t = so_so_joClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_83
    if (t >= 5 && sound_vowels_83.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_83.tStart = t;  // (not accounting for frame time here)
      sound_vowels_83.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_83.play(); });  // screen flip
      sound_vowels_83.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_83.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_83.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_83.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_411* updates
    if (t >= 0.0 && text_411.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_411.tStart = t;  // (not accounting for frame time here)
      text_411.frameNStart = frameN;  // exact frame index
      
      text_411.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_411.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_411.setAutoDraw(false);
    }
    
    // *text_412* updates
    if (t >= 9.0 && text_412.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_412.tStart = t;  // (not accounting for frame time here)
      text_412.frameNStart = frameN;  // exact frame index
      
      text_412.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_412.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_412.setAutoDraw(false);
    }
    
    // *text_413* updates
    if (t >= 2 && text_413.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_413.tStart = t;  // (not accounting for frame time here)
      text_413.frameNStart = frameN;  // exact frame index
      
      text_413.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_413.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_413.setAutoDraw(false);
    }
    
    // *text_414* updates
    if (t >= 3.0 && text_414.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_414.tStart = t;  // (not accounting for frame time here)
      text_414.frameNStart = frameN;  // exact frame index
      
      text_414.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_414.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_414.setAutoDraw(false);
    }
    
    // *text_415* updates
    if (t >= 4.0 && text_415.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_415.tStart = t;  // (not accounting for frame time here)
      text_415.frameNStart = frameN;  // exact frame index
      
      text_415.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_415.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_415.setAutoDraw(false);
    }
    
    // *key_resp_83* updates
    if (t >= 9.0 && key_resp_83.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_83.tStart = t;  // (not accounting for frame time here)
      key_resp_83.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_83.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_83.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_83.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_83.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_83.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_83.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_83.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_83_allKeys = _key_resp_83_allKeys.concat(theseKeys);
      if (_key_resp_83_allKeys.length > 0) {
        key_resp_83.keys = _key_resp_83_allKeys[_key_resp_83_allKeys.length - 1].name;  // just the last key pressed
        key_resp_83.rt = _key_resp_83_allKeys[_key_resp_83_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_83.keys == 'y') {
            key_resp_83.corr = 1;
        } else {
            key_resp_83.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    so_so_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function so_so_joRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'so_so_jo' ---
    so_so_joComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_83.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_83.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_83.corr = 1;  // correct non-response
      } else {
         key_resp_83.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_83.corr, level);
    }
    psychoJS.experiment.addData('key_resp_83.keys', key_resp_83.keys);
    psychoJS.experiment.addData('key_resp_83.corr', key_resp_83.corr);
    if (typeof key_resp_83.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_83.rt', key_resp_83.rt);
        routineTimer.reset();
        }
    
    key_resp_83.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_69_allKeys;
var ja_sa_jaComponents;
function ja_sa_jaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'ja_sa_ja' ---
    t = 0;
    ja_sa_jaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_69.secs=3.5;
    sound_vowels_69.setVolume(1.0);
    key_resp_69.keys = undefined;
    key_resp_69.rt = undefined;
    _key_resp_69_allKeys = [];
    // keep track of which components have finished
    ja_sa_jaComponents = [];
    ja_sa_jaComponents.push(sound_vowels_69);
    ja_sa_jaComponents.push(text_341);
    ja_sa_jaComponents.push(text_342);
    ja_sa_jaComponents.push(text_343);
    ja_sa_jaComponents.push(text_344);
    ja_sa_jaComponents.push(text_345);
    ja_sa_jaComponents.push(key_resp_69);
    
    ja_sa_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function ja_sa_jaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'ja_sa_ja' ---
    // get current time
    t = ja_sa_jaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_69
    if (t >= 5 && sound_vowels_69.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_69.tStart = t;  // (not accounting for frame time here)
      sound_vowels_69.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_69.play(); });  // screen flip
      sound_vowels_69.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_69.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_69.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_69.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_341* updates
    if (t >= 0.0 && text_341.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_341.tStart = t;  // (not accounting for frame time here)
      text_341.frameNStart = frameN;  // exact frame index
      
      text_341.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_341.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_341.setAutoDraw(false);
    }
    
    // *text_342* updates
    if (t >= 9.0 && text_342.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_342.tStart = t;  // (not accounting for frame time here)
      text_342.frameNStart = frameN;  // exact frame index
      
      text_342.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_342.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_342.setAutoDraw(false);
    }
    
    // *text_343* updates
    if (t >= 2 && text_343.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_343.tStart = t;  // (not accounting for frame time here)
      text_343.frameNStart = frameN;  // exact frame index
      
      text_343.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_343.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_343.setAutoDraw(false);
    }
    
    // *text_344* updates
    if (t >= 3.0 && text_344.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_344.tStart = t;  // (not accounting for frame time here)
      text_344.frameNStart = frameN;  // exact frame index
      
      text_344.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_344.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_344.setAutoDraw(false);
    }
    
    // *text_345* updates
    if (t >= 4.0 && text_345.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_345.tStart = t;  // (not accounting for frame time here)
      text_345.frameNStart = frameN;  // exact frame index
      
      text_345.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_345.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_345.setAutoDraw(false);
    }
    
    // *key_resp_69* updates
    if (t >= 9.0 && key_resp_69.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_69.tStart = t;  // (not accounting for frame time here)
      key_resp_69.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_69.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_69.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_69.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_69.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_69.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_69.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_69.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_69_allKeys = _key_resp_69_allKeys.concat(theseKeys);
      if (_key_resp_69_allKeys.length > 0) {
        key_resp_69.keys = _key_resp_69_allKeys[_key_resp_69_allKeys.length - 1].name;  // just the last key pressed
        key_resp_69.rt = _key_resp_69_allKeys[_key_resp_69_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_69.keys == 'y') {
            key_resp_69.corr = 1;
        } else {
            key_resp_69.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    ja_sa_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ja_sa_jaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'ja_sa_ja' ---
    ja_sa_jaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_69.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_69.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_69.corr = 1;  // correct non-response
      } else {
         key_resp_69.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_69.corr, level);
    }
    psychoJS.experiment.addData('key_resp_69.keys', key_resp_69.keys);
    psychoJS.experiment.addData('key_resp_69.corr', key_resp_69.corr);
    if (typeof key_resp_69.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_69.rt', key_resp_69.rt);
        routineTimer.reset();
        }
    
    key_resp_69.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_68_allKeys;
var sa_A_sapsaComponents;
function sa_A_sapsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_A_sapsa' ---
    t = 0;
    sa_A_sapsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_68.secs=3.5;
    sound_vowels_68.setVolume(1.0);
    key_resp_68.keys = undefined;
    key_resp_68.rt = undefined;
    _key_resp_68_allKeys = [];
    // keep track of which components have finished
    sa_A_sapsaComponents = [];
    sa_A_sapsaComponents.push(sound_vowels_68);
    sa_A_sapsaComponents.push(text_336);
    sa_A_sapsaComponents.push(text_337);
    sa_A_sapsaComponents.push(text_338);
    sa_A_sapsaComponents.push(text_339);
    sa_A_sapsaComponents.push(text_340);
    sa_A_sapsaComponents.push(key_resp_68);
    
    sa_A_sapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_A_sapsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_A_sapsa' ---
    // get current time
    t = sa_A_sapsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_68
    if (t >= 5 && sound_vowels_68.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_68.tStart = t;  // (not accounting for frame time here)
      sound_vowels_68.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_68.play(); });  // screen flip
      sound_vowels_68.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_68.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_68.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_68.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_336* updates
    if (t >= 0.0 && text_336.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_336.tStart = t;  // (not accounting for frame time here)
      text_336.frameNStart = frameN;  // exact frame index
      
      text_336.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_336.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_336.setAutoDraw(false);
    }
    
    // *text_337* updates
    if (t >= 9.0 && text_337.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_337.tStart = t;  // (not accounting for frame time here)
      text_337.frameNStart = frameN;  // exact frame index
      
      text_337.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_337.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_337.setAutoDraw(false);
    }
    
    // *text_338* updates
    if (t >= 2 && text_338.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_338.tStart = t;  // (not accounting for frame time here)
      text_338.frameNStart = frameN;  // exact frame index
      
      text_338.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_338.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_338.setAutoDraw(false);
    }
    
    // *text_339* updates
    if (t >= 3.0 && text_339.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_339.tStart = t;  // (not accounting for frame time here)
      text_339.frameNStart = frameN;  // exact frame index
      
      text_339.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_339.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_339.setAutoDraw(false);
    }
    
    // *text_340* updates
    if (t >= 4.0 && text_340.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_340.tStart = t;  // (not accounting for frame time here)
      text_340.frameNStart = frameN;  // exact frame index
      
      text_340.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_340.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_340.setAutoDraw(false);
    }
    
    // *key_resp_68* updates
    if (t >= 9.0 && key_resp_68.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_68.tStart = t;  // (not accounting for frame time here)
      key_resp_68.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_68.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_68.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_68.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_68.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_68.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_68.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_68.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_68_allKeys = _key_resp_68_allKeys.concat(theseKeys);
      if (_key_resp_68_allKeys.length > 0) {
        key_resp_68.keys = _key_resp_68_allKeys[_key_resp_68_allKeys.length - 1].name;  // just the last key pressed
        key_resp_68.rt = _key_resp_68_allKeys[_key_resp_68_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_68.keys == 'n') {
            key_resp_68.corr = 1;
        } else {
            key_resp_68.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_A_sapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_A_sapsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_A_sapsa' ---
    sa_A_sapsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_68.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_68.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_68.corr = 1;  // correct non-response
      } else {
         key_resp_68.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_68.corr, level);
    }
    psychoJS.experiment.addData('key_resp_68.keys', key_resp_68.keys);
    psychoJS.experiment.addData('key_resp_68.corr', key_resp_68.corr);
    if (typeof key_resp_68.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_68.rt', key_resp_68.rt);
        routineTimer.reset();
        }
    
    key_resp_68.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_70_allKeys;
var jo_A_AComponents;
function jo_A_ARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jo_A_A' ---
    t = 0;
    jo_A_AClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_70.secs=3.5;
    sound_vowels_70.setVolume(1.0);
    key_resp_70.keys = undefined;
    key_resp_70.rt = undefined;
    _key_resp_70_allKeys = [];
    // keep track of which components have finished
    jo_A_AComponents = [];
    jo_A_AComponents.push(sound_vowels_70);
    jo_A_AComponents.push(text_346);
    jo_A_AComponents.push(text_347);
    jo_A_AComponents.push(text_348);
    jo_A_AComponents.push(text_349);
    jo_A_AComponents.push(text_350);
    jo_A_AComponents.push(key_resp_70);
    
    jo_A_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jo_A_ARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jo_A_A' ---
    // get current time
    t = jo_A_AClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_70
    if (t >= 5 && sound_vowels_70.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_70.tStart = t;  // (not accounting for frame time here)
      sound_vowels_70.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_70.play(); });  // screen flip
      sound_vowels_70.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_70.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_70.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_70.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_346* updates
    if (t >= 0.0 && text_346.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_346.tStart = t;  // (not accounting for frame time here)
      text_346.frameNStart = frameN;  // exact frame index
      
      text_346.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_346.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_346.setAutoDraw(false);
    }
    
    // *text_347* updates
    if (t >= 9.0 && text_347.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_347.tStart = t;  // (not accounting for frame time here)
      text_347.frameNStart = frameN;  // exact frame index
      
      text_347.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_347.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_347.setAutoDraw(false);
    }
    
    // *text_348* updates
    if (t >= 2 && text_348.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_348.tStart = t;  // (not accounting for frame time here)
      text_348.frameNStart = frameN;  // exact frame index
      
      text_348.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_348.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_348.setAutoDraw(false);
    }
    
    // *text_349* updates
    if (t >= 3.0 && text_349.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_349.tStart = t;  // (not accounting for frame time here)
      text_349.frameNStart = frameN;  // exact frame index
      
      text_349.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_349.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_349.setAutoDraw(false);
    }
    
    // *text_350* updates
    if (t >= 4.0 && text_350.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_350.tStart = t;  // (not accounting for frame time here)
      text_350.frameNStart = frameN;  // exact frame index
      
      text_350.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_350.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_350.setAutoDraw(false);
    }
    
    // *key_resp_70* updates
    if (t >= 9.0 && key_resp_70.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_70.tStart = t;  // (not accounting for frame time here)
      key_resp_70.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_70.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_70.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_70.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_70.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_70.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_70.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_70.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_70_allKeys = _key_resp_70_allKeys.concat(theseKeys);
      if (_key_resp_70_allKeys.length > 0) {
        key_resp_70.keys = _key_resp_70_allKeys[_key_resp_70_allKeys.length - 1].name;  // just the last key pressed
        key_resp_70.rt = _key_resp_70_allKeys[_key_resp_70_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_70.keys == 'y') {
            key_resp_70.corr = 1;
        } else {
            key_resp_70.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jo_A_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jo_A_ARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jo_A_A' ---
    jo_A_AComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_70.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_70.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_70.corr = 1;  // correct non-response
      } else {
         key_resp_70.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_70.corr, level);
    }
    psychoJS.experiment.addData('key_resp_70.keys', key_resp_70.keys);
    psychoJS.experiment.addData('key_resp_70.corr', key_resp_70.corr);
    if (typeof key_resp_70.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_70.rt', key_resp_70.rt);
        routineTimer.reset();
        }
    
    key_resp_70.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_90_allKeys;
var usoupuComponents;
function usoupuRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'usoupu' ---
    t = 0;
    usoupuClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_90.secs=3.5;
    sound_vowels_90.setVolume(1.0);
    key_resp_90.keys = undefined;
    key_resp_90.rt = undefined;
    _key_resp_90_allKeys = [];
    // keep track of which components have finished
    usoupuComponents = [];
    usoupuComponents.push(sound_vowels_90);
    usoupuComponents.push(text_446);
    usoupuComponents.push(text_447);
    usoupuComponents.push(text_448);
    usoupuComponents.push(text_449);
    usoupuComponents.push(text_450);
    usoupuComponents.push(key_resp_90);
    
    usoupuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function usoupuRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'usoupu' ---
    // get current time
    t = usoupuClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_90
    if (t >= 5 && sound_vowels_90.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_90.tStart = t;  // (not accounting for frame time here)
      sound_vowels_90.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_90.play(); });  // screen flip
      sound_vowels_90.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_90.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_90.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_90.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_446* updates
    if (t >= 0.0 && text_446.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_446.tStart = t;  // (not accounting for frame time here)
      text_446.frameNStart = frameN;  // exact frame index
      
      text_446.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_446.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_446.setAutoDraw(false);
    }
    
    // *text_447* updates
    if (t >= 9.0 && text_447.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_447.tStart = t;  // (not accounting for frame time here)
      text_447.frameNStart = frameN;  // exact frame index
      
      text_447.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_447.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_447.setAutoDraw(false);
    }
    
    // *text_448* updates
    if (t >= 2 && text_448.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_448.tStart = t;  // (not accounting for frame time here)
      text_448.frameNStart = frameN;  // exact frame index
      
      text_448.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_448.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_448.setAutoDraw(false);
    }
    
    // *text_449* updates
    if (t >= 3.0 && text_449.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_449.tStart = t;  // (not accounting for frame time here)
      text_449.frameNStart = frameN;  // exact frame index
      
      text_449.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_449.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_449.setAutoDraw(false);
    }
    
    // *text_450* updates
    if (t >= 4.0 && text_450.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_450.tStart = t;  // (not accounting for frame time here)
      text_450.frameNStart = frameN;  // exact frame index
      
      text_450.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_450.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_450.setAutoDraw(false);
    }
    
    // *key_resp_90* updates
    if (t >= 9.0 && key_resp_90.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_90.tStart = t;  // (not accounting for frame time here)
      key_resp_90.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_90.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_90.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_90.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_90.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_90.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_90.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_90.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_90_allKeys = _key_resp_90_allKeys.concat(theseKeys);
      if (_key_resp_90_allKeys.length > 0) {
        key_resp_90.keys = _key_resp_90_allKeys[_key_resp_90_allKeys.length - 1].name;  // just the last key pressed
        key_resp_90.rt = _key_resp_90_allKeys[_key_resp_90_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_90.keys == 'n') {
            key_resp_90.corr = 1;
        } else {
            key_resp_90.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    usoupuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function usoupuRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'usoupu' ---
    usoupuComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_90.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_90.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_90.corr = 1;  // correct non-response
      } else {
         key_resp_90.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_90.corr, level);
    }
    psychoJS.experiment.addData('key_resp_90.keys', key_resp_90.keys);
    psychoJS.experiment.addData('key_resp_90.corr', key_resp_90.corr);
    if (typeof key_resp_90.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_90.rt', key_resp_90.rt);
        routineTimer.reset();
        }
    
    key_resp_90.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_58_allKeys;
var ja_sa_japjaComponents;
function ja_sa_japjaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'ja_sa_japja' ---
    t = 0;
    ja_sa_japjaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_58.secs=3.5;
    sound_vowels_58.setVolume(1.0);
    key_resp_58.keys = undefined;
    key_resp_58.rt = undefined;
    _key_resp_58_allKeys = [];
    // keep track of which components have finished
    ja_sa_japjaComponents = [];
    ja_sa_japjaComponents.push(sound_vowels_58);
    ja_sa_japjaComponents.push(text_286);
    ja_sa_japjaComponents.push(text_287);
    ja_sa_japjaComponents.push(text_288);
    ja_sa_japjaComponents.push(text_289);
    ja_sa_japjaComponents.push(text_290);
    ja_sa_japjaComponents.push(key_resp_58);
    
    ja_sa_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function ja_sa_japjaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'ja_sa_japja' ---
    // get current time
    t = ja_sa_japjaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_58
    if (t >= 5 && sound_vowels_58.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_58.tStart = t;  // (not accounting for frame time here)
      sound_vowels_58.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_58.play(); });  // screen flip
      sound_vowels_58.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_58.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_58.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_58.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_286* updates
    if (t >= 0.0 && text_286.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_286.tStart = t;  // (not accounting for frame time here)
      text_286.frameNStart = frameN;  // exact frame index
      
      text_286.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_286.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_286.setAutoDraw(false);
    }
    
    // *text_287* updates
    if (t >= 9.0 && text_287.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_287.tStart = t;  // (not accounting for frame time here)
      text_287.frameNStart = frameN;  // exact frame index
      
      text_287.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_287.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_287.setAutoDraw(false);
    }
    
    // *text_288* updates
    if (t >= 2 && text_288.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_288.tStart = t;  // (not accounting for frame time here)
      text_288.frameNStart = frameN;  // exact frame index
      
      text_288.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_288.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_288.setAutoDraw(false);
    }
    
    // *text_289* updates
    if (t >= 3.0 && text_289.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_289.tStart = t;  // (not accounting for frame time here)
      text_289.frameNStart = frameN;  // exact frame index
      
      text_289.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_289.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_289.setAutoDraw(false);
    }
    
    // *text_290* updates
    if (t >= 4.0 && text_290.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_290.tStart = t;  // (not accounting for frame time here)
      text_290.frameNStart = frameN;  // exact frame index
      
      text_290.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_290.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_290.setAutoDraw(false);
    }
    
    // *key_resp_58* updates
    if (t >= 9.0 && key_resp_58.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_58.tStart = t;  // (not accounting for frame time here)
      key_resp_58.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_58.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_58.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_58.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_58.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_58.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_58.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_58.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_58_allKeys = _key_resp_58_allKeys.concat(theseKeys);
      if (_key_resp_58_allKeys.length > 0) {
        key_resp_58.keys = _key_resp_58_allKeys[_key_resp_58_allKeys.length - 1].name;  // just the last key pressed
        key_resp_58.rt = _key_resp_58_allKeys[_key_resp_58_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_58.keys == 'n') {
            key_resp_58.corr = 1;
        } else {
            key_resp_58.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    ja_sa_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ja_sa_japjaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'ja_sa_japja' ---
    ja_sa_japjaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_58.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_58.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_58.corr = 1;  // correct non-response
      } else {
         key_resp_58.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_58.corr, level);
    }
    psychoJS.experiment.addData('key_resp_58.keys', key_resp_58.keys);
    psychoJS.experiment.addData('key_resp_58.corr', key_resp_58.corr);
    if (typeof key_resp_58.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_58.rt', key_resp_58.rt);
        routineTimer.reset();
        }
    
    key_resp_58.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_40_allKeys;
var joAApjoComponents;
function joAApjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'joAApjo' ---
    t = 0;
    joAApjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_40.secs=3.5;
    sound_vowels_40.setVolume(1.0);
    key_resp_40.keys = undefined;
    key_resp_40.rt = undefined;
    _key_resp_40_allKeys = [];
    // keep track of which components have finished
    joAApjoComponents = [];
    joAApjoComponents.push(sound_vowels_40);
    joAApjoComponents.push(text_196);
    joAApjoComponents.push(text_197);
    joAApjoComponents.push(text_198);
    joAApjoComponents.push(text_199);
    joAApjoComponents.push(text_200);
    joAApjoComponents.push(key_resp_40);
    
    joAApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function joAApjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'joAApjo' ---
    // get current time
    t = joAApjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_40
    if (t >= 5 && sound_vowels_40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_40.tStart = t;  // (not accounting for frame time here)
      sound_vowels_40.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_40.play(); });  // screen flip
      sound_vowels_40.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_40.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_40.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_40.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_196* updates
    if (t >= 0.0 && text_196.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_196.tStart = t;  // (not accounting for frame time here)
      text_196.frameNStart = frameN;  // exact frame index
      
      text_196.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_196.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_196.setAutoDraw(false);
    }
    
    // *text_197* updates
    if (t >= 9.0 && text_197.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_197.tStart = t;  // (not accounting for frame time here)
      text_197.frameNStart = frameN;  // exact frame index
      
      text_197.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_197.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_197.setAutoDraw(false);
    }
    
    // *text_198* updates
    if (t >= 2 && text_198.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_198.tStart = t;  // (not accounting for frame time here)
      text_198.frameNStart = frameN;  // exact frame index
      
      text_198.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_198.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_198.setAutoDraw(false);
    }
    
    // *text_199* updates
    if (t >= 3.0 && text_199.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_199.tStart = t;  // (not accounting for frame time here)
      text_199.frameNStart = frameN;  // exact frame index
      
      text_199.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_199.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_199.setAutoDraw(false);
    }
    
    // *text_200* updates
    if (t >= 4.0 && text_200.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_200.tStart = t;  // (not accounting for frame time here)
      text_200.frameNStart = frameN;  // exact frame index
      
      text_200.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_200.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_200.setAutoDraw(false);
    }
    
    // *key_resp_40* updates
    if (t >= 9.0 && key_resp_40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_40.tStart = t;  // (not accounting for frame time here)
      key_resp_40.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_40.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_40.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_40.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_40.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_40.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_40.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_40.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_40_allKeys = _key_resp_40_allKeys.concat(theseKeys);
      if (_key_resp_40_allKeys.length > 0) {
        key_resp_40.keys = _key_resp_40_allKeys[_key_resp_40_allKeys.length - 1].name;  // just the last key pressed
        key_resp_40.rt = _key_resp_40_allKeys[_key_resp_40_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_40.keys == 'n') {
            key_resp_40.corr = 1;
        } else {
            key_resp_40.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    joAApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function joAApjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'joAApjo' ---
    joAApjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_40.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_40.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_40.corr = 1;  // correct non-response
      } else {
         key_resp_40.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_40.corr, level);
    }
    psychoJS.experiment.addData('key_resp_40.keys', key_resp_40.keys);
    psychoJS.experiment.addData('key_resp_40.corr', key_resp_40.corr);
    if (typeof key_resp_40.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_40.rt', key_resp_40.rt);
        routineTimer.reset();
        }
    
    key_resp_40.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_44_allKeys;
var saAsapAComponents;
function saAsapARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'saAsapA' ---
    t = 0;
    saAsapAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_44.secs=3.5;
    sound_vowels_44.setVolume(1.0);
    key_resp_44.keys = undefined;
    key_resp_44.rt = undefined;
    _key_resp_44_allKeys = [];
    // keep track of which components have finished
    saAsapAComponents = [];
    saAsapAComponents.push(sound_vowels_44);
    saAsapAComponents.push(text_216);
    saAsapAComponents.push(text_217);
    saAsapAComponents.push(text_218);
    saAsapAComponents.push(text_219);
    saAsapAComponents.push(text_220);
    saAsapAComponents.push(key_resp_44);
    
    saAsapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function saAsapARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'saAsapA' ---
    // get current time
    t = saAsapAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_44
    if (t >= 5 && sound_vowels_44.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_44.tStart = t;  // (not accounting for frame time here)
      sound_vowels_44.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_44.play(); });  // screen flip
      sound_vowels_44.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_44.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_44.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_44.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_216* updates
    if (t >= 0.0 && text_216.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_216.tStart = t;  // (not accounting for frame time here)
      text_216.frameNStart = frameN;  // exact frame index
      
      text_216.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_216.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_216.setAutoDraw(false);
    }
    
    // *text_217* updates
    if (t >= 9.0 && text_217.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_217.tStart = t;  // (not accounting for frame time here)
      text_217.frameNStart = frameN;  // exact frame index
      
      text_217.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_217.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_217.setAutoDraw(false);
    }
    
    // *text_218* updates
    if (t >= 2 && text_218.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_218.tStart = t;  // (not accounting for frame time here)
      text_218.frameNStart = frameN;  // exact frame index
      
      text_218.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_218.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_218.setAutoDraw(false);
    }
    
    // *text_219* updates
    if (t >= 3.0 && text_219.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_219.tStart = t;  // (not accounting for frame time here)
      text_219.frameNStart = frameN;  // exact frame index
      
      text_219.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_219.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_219.setAutoDraw(false);
    }
    
    // *text_220* updates
    if (t >= 4.0 && text_220.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_220.tStart = t;  // (not accounting for frame time here)
      text_220.frameNStart = frameN;  // exact frame index
      
      text_220.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_220.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_220.setAutoDraw(false);
    }
    
    // *key_resp_44* updates
    if (t >= 9.0 && key_resp_44.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_44.tStart = t;  // (not accounting for frame time here)
      key_resp_44.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_44.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_44.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_44.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_44.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_44.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_44.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_44.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_44_allKeys = _key_resp_44_allKeys.concat(theseKeys);
      if (_key_resp_44_allKeys.length > 0) {
        key_resp_44.keys = _key_resp_44_allKeys[_key_resp_44_allKeys.length - 1].name;  // just the last key pressed
        key_resp_44.rt = _key_resp_44_allKeys[_key_resp_44_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_44.keys == 'n') {
            key_resp_44.corr = 1;
        } else {
            key_resp_44.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    saAsapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function saAsapARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'saAsapA' ---
    saAsapAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_44.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_44.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_44.corr = 1;  // correct non-response
      } else {
         key_resp_44.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_44.corr, level);
    }
    psychoJS.experiment.addData('key_resp_44.keys', key_resp_44.keys);
    psychoJS.experiment.addData('key_resp_44.corr', key_resp_44.corr);
    if (typeof key_resp_44.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_44.rt', key_resp_44.rt);
        routineTimer.reset();
        }
    
    key_resp_44.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_59_allKeys;
var ja_sa_japsaComponents;
function ja_sa_japsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'ja_sa_japsa' ---
    t = 0;
    ja_sa_japsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_59.secs=3.5;
    sound_vowels_59.setVolume(1.0);
    key_resp_59.keys = undefined;
    key_resp_59.rt = undefined;
    _key_resp_59_allKeys = [];
    // keep track of which components have finished
    ja_sa_japsaComponents = [];
    ja_sa_japsaComponents.push(sound_vowels_59);
    ja_sa_japsaComponents.push(text_291);
    ja_sa_japsaComponents.push(text_292);
    ja_sa_japsaComponents.push(text_293);
    ja_sa_japsaComponents.push(text_294);
    ja_sa_japsaComponents.push(text_295);
    ja_sa_japsaComponents.push(key_resp_59);
    
    ja_sa_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function ja_sa_japsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'ja_sa_japsa' ---
    // get current time
    t = ja_sa_japsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_59
    if (t >= 5 && sound_vowels_59.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_59.tStart = t;  // (not accounting for frame time here)
      sound_vowels_59.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_59.play(); });  // screen flip
      sound_vowels_59.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_59.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_59.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_59.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_291* updates
    if (t >= 0.0 && text_291.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_291.tStart = t;  // (not accounting for frame time here)
      text_291.frameNStart = frameN;  // exact frame index
      
      text_291.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_291.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_291.setAutoDraw(false);
    }
    
    // *text_292* updates
    if (t >= 9.0 && text_292.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_292.tStart = t;  // (not accounting for frame time here)
      text_292.frameNStart = frameN;  // exact frame index
      
      text_292.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_292.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_292.setAutoDraw(false);
    }
    
    // *text_293* updates
    if (t >= 2 && text_293.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_293.tStart = t;  // (not accounting for frame time here)
      text_293.frameNStart = frameN;  // exact frame index
      
      text_293.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_293.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_293.setAutoDraw(false);
    }
    
    // *text_294* updates
    if (t >= 3.0 && text_294.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_294.tStart = t;  // (not accounting for frame time here)
      text_294.frameNStart = frameN;  // exact frame index
      
      text_294.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_294.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_294.setAutoDraw(false);
    }
    
    // *text_295* updates
    if (t >= 4.0 && text_295.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_295.tStart = t;  // (not accounting for frame time here)
      text_295.frameNStart = frameN;  // exact frame index
      
      text_295.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_295.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_295.setAutoDraw(false);
    }
    
    // *key_resp_59* updates
    if (t >= 9.0 && key_resp_59.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_59.tStart = t;  // (not accounting for frame time here)
      key_resp_59.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_59.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_59.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_59.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_59.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_59.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_59.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_59.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_59_allKeys = _key_resp_59_allKeys.concat(theseKeys);
      if (_key_resp_59_allKeys.length > 0) {
        key_resp_59.keys = _key_resp_59_allKeys[_key_resp_59_allKeys.length - 1].name;  // just the last key pressed
        key_resp_59.rt = _key_resp_59_allKeys[_key_resp_59_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_59.keys == 'n') {
            key_resp_59.corr = 1;
        } else {
            key_resp_59.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    ja_sa_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ja_sa_japsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'ja_sa_japsa' ---
    ja_sa_japsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_59.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_59.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_59.corr = 1;  // correct non-response
      } else {
         key_resp_59.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_59.corr, level);
    }
    psychoJS.experiment.addData('key_resp_59.keys', key_resp_59.keys);
    psychoJS.experiment.addData('key_resp_59.corr', key_resp_59.corr);
    if (typeof key_resp_59.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_59.rt', key_resp_59.rt);
        routineTimer.reset();
        }
    
    key_resp_59.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_39_allKeys;
var sopjoComponents;
function sopjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sopjo' ---
    t = 0;
    sopjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_39.secs=3.5;
    sound_vowels_39.setVolume(1.0);
    key_resp_39.keys = undefined;
    key_resp_39.rt = undefined;
    _key_resp_39_allKeys = [];
    // keep track of which components have finished
    sopjoComponents = [];
    sopjoComponents.push(sound_vowels_39);
    sopjoComponents.push(text_191);
    sopjoComponents.push(text_192);
    sopjoComponents.push(text_193);
    sopjoComponents.push(text_194);
    sopjoComponents.push(text_195);
    sopjoComponents.push(key_resp_39);
    
    sopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sopjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sopjo' ---
    // get current time
    t = sopjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_39
    if (t >= 5 && sound_vowels_39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_39.tStart = t;  // (not accounting for frame time here)
      sound_vowels_39.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_39.play(); });  // screen flip
      sound_vowels_39.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_39.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_39.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_39.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_191* updates
    if (t >= 0.0 && text_191.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_191.tStart = t;  // (not accounting for frame time here)
      text_191.frameNStart = frameN;  // exact frame index
      
      text_191.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_191.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_191.setAutoDraw(false);
    }
    
    // *text_192* updates
    if (t >= 9.0 && text_192.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_192.tStart = t;  // (not accounting for frame time here)
      text_192.frameNStart = frameN;  // exact frame index
      
      text_192.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_192.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_192.setAutoDraw(false);
    }
    
    // *text_193* updates
    if (t >= 2 && text_193.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_193.tStart = t;  // (not accounting for frame time here)
      text_193.frameNStart = frameN;  // exact frame index
      
      text_193.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_193.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_193.setAutoDraw(false);
    }
    
    // *text_194* updates
    if (t >= 3.0 && text_194.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_194.tStart = t;  // (not accounting for frame time here)
      text_194.frameNStart = frameN;  // exact frame index
      
      text_194.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_194.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_194.setAutoDraw(false);
    }
    
    // *text_195* updates
    if (t >= 4.0 && text_195.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_195.tStart = t;  // (not accounting for frame time here)
      text_195.frameNStart = frameN;  // exact frame index
      
      text_195.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_195.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_195.setAutoDraw(false);
    }
    
    // *key_resp_39* updates
    if (t >= 9.0 && key_resp_39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_39.tStart = t;  // (not accounting for frame time here)
      key_resp_39.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_39.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_39.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_39.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_39.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_39.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_39.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_39.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_39_allKeys = _key_resp_39_allKeys.concat(theseKeys);
      if (_key_resp_39_allKeys.length > 0) {
        key_resp_39.keys = _key_resp_39_allKeys[_key_resp_39_allKeys.length - 1].name;  // just the last key pressed
        key_resp_39.rt = _key_resp_39_allKeys[_key_resp_39_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_39.keys == 'n') {
            key_resp_39.corr = 1;
        } else {
            key_resp_39.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sopjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sopjo' ---
    sopjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_39.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_39.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_39.corr = 1;  // correct non-response
      } else {
         key_resp_39.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_39.corr, level);
    }
    psychoJS.experiment.addData('key_resp_39.keys', key_resp_39.keys);
    psychoJS.experiment.addData('key_resp_39.corr', key_resp_39.corr);
    if (typeof key_resp_39.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_39.rt', key_resp_39.rt);
        routineTimer.reset();
        }
    
    key_resp_39.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_78_allKeys;
var sa_A_saComponents;
function sa_A_saRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_A_sa' ---
    t = 0;
    sa_A_saClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_78.secs=3.5;
    sound_vowels_78.setVolume(1.0);
    key_resp_78.keys = undefined;
    key_resp_78.rt = undefined;
    _key_resp_78_allKeys = [];
    // keep track of which components have finished
    sa_A_saComponents = [];
    sa_A_saComponents.push(sound_vowels_78);
    sa_A_saComponents.push(text_386);
    sa_A_saComponents.push(text_387);
    sa_A_saComponents.push(text_388);
    sa_A_saComponents.push(text_389);
    sa_A_saComponents.push(text_390);
    sa_A_saComponents.push(key_resp_78);
    
    sa_A_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_A_saRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_A_sa' ---
    // get current time
    t = sa_A_saClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_78
    if (t >= 5 && sound_vowels_78.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_78.tStart = t;  // (not accounting for frame time here)
      sound_vowels_78.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_78.play(); });  // screen flip
      sound_vowels_78.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_78.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_78.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_78.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_386* updates
    if (t >= 0.0 && text_386.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_386.tStart = t;  // (not accounting for frame time here)
      text_386.frameNStart = frameN;  // exact frame index
      
      text_386.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_386.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_386.setAutoDraw(false);
    }
    
    // *text_387* updates
    if (t >= 9.0 && text_387.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_387.tStart = t;  // (not accounting for frame time here)
      text_387.frameNStart = frameN;  // exact frame index
      
      text_387.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_387.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_387.setAutoDraw(false);
    }
    
    // *text_388* updates
    if (t >= 2 && text_388.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_388.tStart = t;  // (not accounting for frame time here)
      text_388.frameNStart = frameN;  // exact frame index
      
      text_388.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_388.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_388.setAutoDraw(false);
    }
    
    // *text_389* updates
    if (t >= 3.0 && text_389.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_389.tStart = t;  // (not accounting for frame time here)
      text_389.frameNStart = frameN;  // exact frame index
      
      text_389.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_389.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_389.setAutoDraw(false);
    }
    
    // *text_390* updates
    if (t >= 4.0 && text_390.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_390.tStart = t;  // (not accounting for frame time here)
      text_390.frameNStart = frameN;  // exact frame index
      
      text_390.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_390.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_390.setAutoDraw(false);
    }
    
    // *key_resp_78* updates
    if (t >= 9.0 && key_resp_78.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_78.tStart = t;  // (not accounting for frame time here)
      key_resp_78.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_78.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_78.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_78.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_78.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_78.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_78.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_78.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_78_allKeys = _key_resp_78_allKeys.concat(theseKeys);
      if (_key_resp_78_allKeys.length > 0) {
        key_resp_78.keys = _key_resp_78_allKeys[_key_resp_78_allKeys.length - 1].name;  // just the last key pressed
        key_resp_78.rt = _key_resp_78_allKeys[_key_resp_78_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_78.keys == 'y') {
            key_resp_78.corr = 1;
        } else {
            key_resp_78.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_A_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_A_saRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_A_sa' ---
    sa_A_saComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_78.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_78.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_78.corr = 1;  // correct non-response
      } else {
         key_resp_78.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_78.corr, level);
    }
    psychoJS.experiment.addData('key_resp_78.keys', key_resp_78.keys);
    psychoJS.experiment.addData('key_resp_78.corr', key_resp_78.corr);
    if (typeof key_resp_78.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_78.rt', key_resp_78.rt);
        routineTimer.reset();
        }
    
    key_resp_78.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_48_allKeys;
var jojoApjoComponents;
function jojoApjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jojoApjo' ---
    t = 0;
    jojoApjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_48.secs=3.5;
    sound_vowels_48.setVolume(1.0);
    key_resp_48.keys = undefined;
    key_resp_48.rt = undefined;
    _key_resp_48_allKeys = [];
    // keep track of which components have finished
    jojoApjoComponents = [];
    jojoApjoComponents.push(sound_vowels_48);
    jojoApjoComponents.push(text_236);
    jojoApjoComponents.push(text_237);
    jojoApjoComponents.push(text_238);
    jojoApjoComponents.push(text_239);
    jojoApjoComponents.push(text_240);
    jojoApjoComponents.push(key_resp_48);
    
    jojoApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jojoApjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jojoApjo' ---
    // get current time
    t = jojoApjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_48
    if (t >= 5 && sound_vowels_48.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_48.tStart = t;  // (not accounting for frame time here)
      sound_vowels_48.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_48.play(); });  // screen flip
      sound_vowels_48.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_48.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_48.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_48.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_236* updates
    if (t >= 0.0 && text_236.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_236.tStart = t;  // (not accounting for frame time here)
      text_236.frameNStart = frameN;  // exact frame index
      
      text_236.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_236.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_236.setAutoDraw(false);
    }
    
    // *text_237* updates
    if (t >= 9.0 && text_237.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_237.tStart = t;  // (not accounting for frame time here)
      text_237.frameNStart = frameN;  // exact frame index
      
      text_237.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_237.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_237.setAutoDraw(false);
    }
    
    // *text_238* updates
    if (t >= 2 && text_238.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_238.tStart = t;  // (not accounting for frame time here)
      text_238.frameNStart = frameN;  // exact frame index
      
      text_238.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_238.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_238.setAutoDraw(false);
    }
    
    // *text_239* updates
    if (t >= 3.0 && text_239.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_239.tStart = t;  // (not accounting for frame time here)
      text_239.frameNStart = frameN;  // exact frame index
      
      text_239.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_239.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_239.setAutoDraw(false);
    }
    
    // *text_240* updates
    if (t >= 4.0 && text_240.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_240.tStart = t;  // (not accounting for frame time here)
      text_240.frameNStart = frameN;  // exact frame index
      
      text_240.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_240.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_240.setAutoDraw(false);
    }
    
    // *key_resp_48* updates
    if (t >= 9.0 && key_resp_48.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_48.tStart = t;  // (not accounting for frame time here)
      key_resp_48.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_48.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_48.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_48.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_48.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_48.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_48.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_48.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_48_allKeys = _key_resp_48_allKeys.concat(theseKeys);
      if (_key_resp_48_allKeys.length > 0) {
        key_resp_48.keys = _key_resp_48_allKeys[_key_resp_48_allKeys.length - 1].name;  // just the last key pressed
        key_resp_48.rt = _key_resp_48_allKeys[_key_resp_48_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_48.keys == 'n') {
            key_resp_48.corr = 1;
        } else {
            key_resp_48.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jojoApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jojoApjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jojoApjo' ---
    jojoApjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_48.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_48.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_48.corr = 1;  // correct non-response
      } else {
         key_resp_48.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_48.corr, level);
    }
    psychoJS.experiment.addData('key_resp_48.keys', key_resp_48.keys);
    psychoJS.experiment.addData('key_resp_48.corr', key_resp_48.corr);
    if (typeof key_resp_48.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_48.rt', key_resp_48.rt);
        routineTimer.reset();
        }
    
    key_resp_48.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_93_allKeys;
var uusopuComponents;
function uusopuRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'uusopu' ---
    t = 0;
    uusopuClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_93.secs=3.5;
    sound_vowels_93.setVolume(1.0);
    key_resp_93.keys = undefined;
    key_resp_93.rt = undefined;
    _key_resp_93_allKeys = [];
    // keep track of which components have finished
    uusopuComponents = [];
    uusopuComponents.push(sound_vowels_93);
    uusopuComponents.push(text_461);
    uusopuComponents.push(text_462);
    uusopuComponents.push(text_463);
    uusopuComponents.push(text_464);
    uusopuComponents.push(text_465);
    uusopuComponents.push(key_resp_93);
    
    uusopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function uusopuRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'uusopu' ---
    // get current time
    t = uusopuClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_93
    if (t >= 5 && sound_vowels_93.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_93.tStart = t;  // (not accounting for frame time here)
      sound_vowels_93.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_93.play(); });  // screen flip
      sound_vowels_93.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_93.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_93.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_93.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_461* updates
    if (t >= 0.0 && text_461.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_461.tStart = t;  // (not accounting for frame time here)
      text_461.frameNStart = frameN;  // exact frame index
      
      text_461.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_461.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_461.setAutoDraw(false);
    }
    
    // *text_462* updates
    if (t >= 9.0 && text_462.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_462.tStart = t;  // (not accounting for frame time here)
      text_462.frameNStart = frameN;  // exact frame index
      
      text_462.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_462.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_462.setAutoDraw(false);
    }
    
    // *text_463* updates
    if (t >= 2 && text_463.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_463.tStart = t;  // (not accounting for frame time here)
      text_463.frameNStart = frameN;  // exact frame index
      
      text_463.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_463.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_463.setAutoDraw(false);
    }
    
    // *text_464* updates
    if (t >= 3.0 && text_464.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_464.tStart = t;  // (not accounting for frame time here)
      text_464.frameNStart = frameN;  // exact frame index
      
      text_464.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_464.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_464.setAutoDraw(false);
    }
    
    // *text_465* updates
    if (t >= 4.0 && text_465.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_465.tStart = t;  // (not accounting for frame time here)
      text_465.frameNStart = frameN;  // exact frame index
      
      text_465.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_465.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_465.setAutoDraw(false);
    }
    
    // *key_resp_93* updates
    if (t >= 9.0 && key_resp_93.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_93.tStart = t;  // (not accounting for frame time here)
      key_resp_93.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_93.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_93.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_93.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_93.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_93.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_93.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_93.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_93_allKeys = _key_resp_93_allKeys.concat(theseKeys);
      if (_key_resp_93_allKeys.length > 0) {
        key_resp_93.keys = _key_resp_93_allKeys[_key_resp_93_allKeys.length - 1].name;  // just the last key pressed
        key_resp_93.rt = _key_resp_93_allKeys[_key_resp_93_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_93.keys == 'n') {
            key_resp_93.corr = 1;
        } else {
            key_resp_93.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    uusopuComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function uusopuRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'uusopu' ---
    uusopuComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_93.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_93.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_93.corr = 1;  // correct non-response
      } else {
         key_resp_93.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_93.corr, level);
    }
    psychoJS.experiment.addData('key_resp_93.keys', key_resp_93.keys);
    psychoJS.experiment.addData('key_resp_93.corr', key_resp_93.corr);
    if (typeof key_resp_93.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_93.rt', key_resp_93.rt);
        routineTimer.reset();
        }
    
    key_resp_93.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_54_allKeys;
var sojosojopjoComponents;
function sojosojopjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sojosojopjo' ---
    t = 0;
    sojosojopjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_54.secs=3.5;
    sound_vowels_54.setVolume(1.0);
    key_resp_54.keys = undefined;
    key_resp_54.rt = undefined;
    _key_resp_54_allKeys = [];
    // keep track of which components have finished
    sojosojopjoComponents = [];
    sojosojopjoComponents.push(sound_vowels_54);
    sojosojopjoComponents.push(text_266);
    sojosojopjoComponents.push(text_267);
    sojosojopjoComponents.push(text_268);
    sojosojopjoComponents.push(text_269);
    sojosojopjoComponents.push(text_270);
    sojosojopjoComponents.push(key_resp_54);
    
    sojosojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sojosojopjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sojosojopjo' ---
    // get current time
    t = sojosojopjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_54
    if (t >= 5 && sound_vowels_54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_54.tStart = t;  // (not accounting for frame time here)
      sound_vowels_54.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_54.play(); });  // screen flip
      sound_vowels_54.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_54.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_54.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_54.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_266* updates
    if (t >= 0.0 && text_266.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_266.tStart = t;  // (not accounting for frame time here)
      text_266.frameNStart = frameN;  // exact frame index
      
      text_266.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_266.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_266.setAutoDraw(false);
    }
    
    // *text_267* updates
    if (t >= 9.0 && text_267.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_267.tStart = t;  // (not accounting for frame time here)
      text_267.frameNStart = frameN;  // exact frame index
      
      text_267.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_267.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_267.setAutoDraw(false);
    }
    
    // *text_268* updates
    if (t >= 2 && text_268.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_268.tStart = t;  // (not accounting for frame time here)
      text_268.frameNStart = frameN;  // exact frame index
      
      text_268.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_268.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_268.setAutoDraw(false);
    }
    
    // *text_269* updates
    if (t >= 3.0 && text_269.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_269.tStart = t;  // (not accounting for frame time here)
      text_269.frameNStart = frameN;  // exact frame index
      
      text_269.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_269.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_269.setAutoDraw(false);
    }
    
    // *text_270* updates
    if (t >= 4.0 && text_270.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_270.tStart = t;  // (not accounting for frame time here)
      text_270.frameNStart = frameN;  // exact frame index
      
      text_270.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_270.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_270.setAutoDraw(false);
    }
    
    // *key_resp_54* updates
    if (t >= 9.0 && key_resp_54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_54.tStart = t;  // (not accounting for frame time here)
      key_resp_54.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_54.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_54.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_54.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_54.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_54.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_54.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_54.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_54_allKeys = _key_resp_54_allKeys.concat(theseKeys);
      if (_key_resp_54_allKeys.length > 0) {
        key_resp_54.keys = _key_resp_54_allKeys[_key_resp_54_allKeys.length - 1].name;  // just the last key pressed
        key_resp_54.rt = _key_resp_54_allKeys[_key_resp_54_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_54.keys == 'n') {
            key_resp_54.corr = 1;
        } else {
            key_resp_54.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sojosojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sojosojopjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sojosojopjo' ---
    sojosojopjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_54.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_54.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_54.corr = 1;  // correct non-response
      } else {
         key_resp_54.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_54.corr, level);
    }
    psychoJS.experiment.addData('key_resp_54.keys', key_resp_54.keys);
    psychoJS.experiment.addData('key_resp_54.corr', key_resp_54.corr);
    if (typeof key_resp_54.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_54.rt', key_resp_54.rt);
        routineTimer.reset();
        }
    
    key_resp_54.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_50_allKeys;
var sosojopsoComponents;
function sosojopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sosojopso' ---
    t = 0;
    sosojopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_50.secs=3.5;
    sound_vowels_50.setVolume(1.0);
    key_resp_50.keys = undefined;
    key_resp_50.rt = undefined;
    _key_resp_50_allKeys = [];
    // keep track of which components have finished
    sosojopsoComponents = [];
    sosojopsoComponents.push(sound_vowels_50);
    sosojopsoComponents.push(text_246);
    sosojopsoComponents.push(text_247);
    sosojopsoComponents.push(text_248);
    sosojopsoComponents.push(text_249);
    sosojopsoComponents.push(text_250);
    sosojopsoComponents.push(key_resp_50);
    
    sosojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sosojopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sosojopso' ---
    // get current time
    t = sosojopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_50
    if (t >= 5 && sound_vowels_50.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_50.tStart = t;  // (not accounting for frame time here)
      sound_vowels_50.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_50.play(); });  // screen flip
      sound_vowels_50.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_50.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_50.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_50.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_246* updates
    if (t >= 0.0 && text_246.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_246.tStart = t;  // (not accounting for frame time here)
      text_246.frameNStart = frameN;  // exact frame index
      
      text_246.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_246.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_246.setAutoDraw(false);
    }
    
    // *text_247* updates
    if (t >= 9.0 && text_247.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_247.tStart = t;  // (not accounting for frame time here)
      text_247.frameNStart = frameN;  // exact frame index
      
      text_247.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_247.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_247.setAutoDraw(false);
    }
    
    // *text_248* updates
    if (t >= 2 && text_248.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_248.tStart = t;  // (not accounting for frame time here)
      text_248.frameNStart = frameN;  // exact frame index
      
      text_248.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_248.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_248.setAutoDraw(false);
    }
    
    // *text_249* updates
    if (t >= 3.0 && text_249.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_249.tStart = t;  // (not accounting for frame time here)
      text_249.frameNStart = frameN;  // exact frame index
      
      text_249.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_249.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_249.setAutoDraw(false);
    }
    
    // *text_250* updates
    if (t >= 4.0 && text_250.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_250.tStart = t;  // (not accounting for frame time here)
      text_250.frameNStart = frameN;  // exact frame index
      
      text_250.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_250.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_250.setAutoDraw(false);
    }
    
    // *key_resp_50* updates
    if (t >= 9.0 && key_resp_50.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_50.tStart = t;  // (not accounting for frame time here)
      key_resp_50.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_50.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_50.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_50.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_50.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_50.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_50.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_50.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_50_allKeys = _key_resp_50_allKeys.concat(theseKeys);
      if (_key_resp_50_allKeys.length > 0) {
        key_resp_50.keys = _key_resp_50_allKeys[_key_resp_50_allKeys.length - 1].name;  // just the last key pressed
        key_resp_50.rt = _key_resp_50_allKeys[_key_resp_50_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_50.keys == 'n') {
            key_resp_50.corr = 1;
        } else {
            key_resp_50.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sosojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sosojopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sosojopso' ---
    sosojopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_50.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_50.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_50.corr = 1;  // correct non-response
      } else {
         key_resp_50.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_50.corr, level);
    }
    psychoJS.experiment.addData('key_resp_50.keys', key_resp_50.keys);
    psychoJS.experiment.addData('key_resp_50.corr', key_resp_50.corr);
    if (typeof key_resp_50.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_50.rt', key_resp_50.rt);
        routineTimer.reset();
        }
    
    key_resp_50.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_8_allKeys;
var A_sa_sapsaComponents;
function A_sa_sapsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'A_sa_sapsa' ---
    t = 0;
    A_sa_sapsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_8.secs=3.5;
    sound_vowels_8.setVolume(1.0);
    key_resp_8.keys = undefined;
    key_resp_8.rt = undefined;
    _key_resp_8_allKeys = [];
    // keep track of which components have finished
    A_sa_sapsaComponents = [];
    A_sa_sapsaComponents.push(sound_vowels_8);
    A_sa_sapsaComponents.push(text_36);
    A_sa_sapsaComponents.push(text_37);
    A_sa_sapsaComponents.push(text_38);
    A_sa_sapsaComponents.push(text_39);
    A_sa_sapsaComponents.push(text_40);
    A_sa_sapsaComponents.push(key_resp_8);
    
    A_sa_sapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function A_sa_sapsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'A_sa_sapsa' ---
    // get current time
    t = A_sa_sapsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_8
    if (t >= 5 && sound_vowels_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_8.tStart = t;  // (not accounting for frame time here)
      sound_vowels_8.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_8.play(); });  // screen flip
      sound_vowels_8.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_8.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_8.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_36* updates
    if (t >= 0.0 && text_36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_36.tStart = t;  // (not accounting for frame time here)
      text_36.frameNStart = frameN;  // exact frame index
      
      text_36.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_36.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_36.setAutoDraw(false);
    }
    
    // *text_37* updates
    if (t >= 9.0 && text_37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_37.tStart = t;  // (not accounting for frame time here)
      text_37.frameNStart = frameN;  // exact frame index
      
      text_37.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_37.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_37.setAutoDraw(false);
    }
    
    // *text_38* updates
    if (t >= 2 && text_38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_38.tStart = t;  // (not accounting for frame time here)
      text_38.frameNStart = frameN;  // exact frame index
      
      text_38.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_38.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_38.setAutoDraw(false);
    }
    
    // *text_39* updates
    if (t >= 3.0 && text_39.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_39.tStart = t;  // (not accounting for frame time here)
      text_39.frameNStart = frameN;  // exact frame index
      
      text_39.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_39.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_39.setAutoDraw(false);
    }
    
    // *text_40* updates
    if (t >= 4.0 && text_40.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_40.tStart = t;  // (not accounting for frame time here)
      text_40.frameNStart = frameN;  // exact frame index
      
      text_40.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_40.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_40.setAutoDraw(false);
    }
    
    // *key_resp_8* updates
    if (t >= 9.0 && key_resp_8.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_8.tStart = t;  // (not accounting for frame time here)
      key_resp_8.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_8.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_8.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_8.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_8.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_8.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_8.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_8.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_8_allKeys = _key_resp_8_allKeys.concat(theseKeys);
      if (_key_resp_8_allKeys.length > 0) {
        key_resp_8.keys = _key_resp_8_allKeys[_key_resp_8_allKeys.length - 1].name;  // just the last key pressed
        key_resp_8.rt = _key_resp_8_allKeys[_key_resp_8_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_8.keys == 'y') {
            key_resp_8.corr = 1;
        } else {
            key_resp_8.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    A_sa_sapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function A_sa_sapsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'A_sa_sapsa' ---
    A_sa_sapsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_8.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_8.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_8.corr = 1;  // correct non-response
      } else {
         key_resp_8.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_8.corr, level);
    }
    psychoJS.experiment.addData('key_resp_8.keys', key_resp_8.keys);
    psychoJS.experiment.addData('key_resp_8.corr', key_resp_8.corr);
    if (typeof key_resp_8.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_8.rt', key_resp_8.rt);
        routineTimer.reset();
        }
    
    key_resp_8.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_71_allKeys;
var jo_A_jo_AComponents;
function jo_A_jo_ARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jo_A_jo_A' ---
    t = 0;
    jo_A_jo_AClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_71.secs=3.5;
    sound_vowels_71.setVolume(1.0);
    key_resp_71.keys = undefined;
    key_resp_71.rt = undefined;
    _key_resp_71_allKeys = [];
    // keep track of which components have finished
    jo_A_jo_AComponents = [];
    jo_A_jo_AComponents.push(sound_vowels_71);
    jo_A_jo_AComponents.push(text_351);
    jo_A_jo_AComponents.push(text_352);
    jo_A_jo_AComponents.push(text_353);
    jo_A_jo_AComponents.push(text_354);
    jo_A_jo_AComponents.push(text_355);
    jo_A_jo_AComponents.push(key_resp_71);
    
    jo_A_jo_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jo_A_jo_ARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jo_A_jo_A' ---
    // get current time
    t = jo_A_jo_AClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_71
    if (t >= 5 && sound_vowels_71.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_71.tStart = t;  // (not accounting for frame time here)
      sound_vowels_71.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_71.play(); });  // screen flip
      sound_vowels_71.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_71.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_71.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_71.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_351* updates
    if (t >= 0.0 && text_351.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_351.tStart = t;  // (not accounting for frame time here)
      text_351.frameNStart = frameN;  // exact frame index
      
      text_351.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_351.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_351.setAutoDraw(false);
    }
    
    // *text_352* updates
    if (t >= 9.0 && text_352.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_352.tStart = t;  // (not accounting for frame time here)
      text_352.frameNStart = frameN;  // exact frame index
      
      text_352.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_352.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_352.setAutoDraw(false);
    }
    
    // *text_353* updates
    if (t >= 2 && text_353.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_353.tStart = t;  // (not accounting for frame time here)
      text_353.frameNStart = frameN;  // exact frame index
      
      text_353.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_353.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_353.setAutoDraw(false);
    }
    
    // *text_354* updates
    if (t >= 3.0 && text_354.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_354.tStart = t;  // (not accounting for frame time here)
      text_354.frameNStart = frameN;  // exact frame index
      
      text_354.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_354.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_354.setAutoDraw(false);
    }
    
    // *text_355* updates
    if (t >= 4.0 && text_355.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_355.tStart = t;  // (not accounting for frame time here)
      text_355.frameNStart = frameN;  // exact frame index
      
      text_355.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_355.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_355.setAutoDraw(false);
    }
    
    // *key_resp_71* updates
    if (t >= 9.0 && key_resp_71.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_71.tStart = t;  // (not accounting for frame time here)
      key_resp_71.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_71.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_71.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_71.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_71.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_71.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_71.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_71.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_71_allKeys = _key_resp_71_allKeys.concat(theseKeys);
      if (_key_resp_71_allKeys.length > 0) {
        key_resp_71.keys = _key_resp_71_allKeys[_key_resp_71_allKeys.length - 1].name;  // just the last key pressed
        key_resp_71.rt = _key_resp_71_allKeys[_key_resp_71_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_71.keys == 'y') {
            key_resp_71.corr = 1;
        } else {
            key_resp_71.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jo_A_jo_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jo_A_jo_ARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jo_A_jo_A' ---
    jo_A_jo_AComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_71.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_71.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_71.corr = 1;  // correct non-response
      } else {
         key_resp_71.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_71.corr, level);
    }
    psychoJS.experiment.addData('key_resp_71.keys', key_resp_71.keys);
    psychoJS.experiment.addData('key_resp_71.corr', key_resp_71.corr);
    if (typeof key_resp_71.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_71.rt', key_resp_71.rt);
        routineTimer.reset();
        }
    
    key_resp_71.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_74_allKeys;
var jo_so_joComponents;
function jo_so_joRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jo_so_jo' ---
    t = 0;
    jo_so_joClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_74.secs=3.5;
    sound_vowels_74.setVolume(1.0);
    key_resp_74.keys = undefined;
    key_resp_74.rt = undefined;
    _key_resp_74_allKeys = [];
    // keep track of which components have finished
    jo_so_joComponents = [];
    jo_so_joComponents.push(sound_vowels_74);
    jo_so_joComponents.push(text_366);
    jo_so_joComponents.push(text_367);
    jo_so_joComponents.push(text_368);
    jo_so_joComponents.push(text_369);
    jo_so_joComponents.push(text_370);
    jo_so_joComponents.push(key_resp_74);
    
    jo_so_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jo_so_joRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jo_so_jo' ---
    // get current time
    t = jo_so_joClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_74
    if (t >= 5 && sound_vowels_74.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_74.tStart = t;  // (not accounting for frame time here)
      sound_vowels_74.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_74.play(); });  // screen flip
      sound_vowels_74.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_74.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_74.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_74.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_366* updates
    if (t >= 0.0 && text_366.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_366.tStart = t;  // (not accounting for frame time here)
      text_366.frameNStart = frameN;  // exact frame index
      
      text_366.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_366.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_366.setAutoDraw(false);
    }
    
    // *text_367* updates
    if (t >= 9.0 && text_367.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_367.tStart = t;  // (not accounting for frame time here)
      text_367.frameNStart = frameN;  // exact frame index
      
      text_367.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_367.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_367.setAutoDraw(false);
    }
    
    // *text_368* updates
    if (t >= 2 && text_368.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_368.tStart = t;  // (not accounting for frame time here)
      text_368.frameNStart = frameN;  // exact frame index
      
      text_368.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_368.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_368.setAutoDraw(false);
    }
    
    // *text_369* updates
    if (t >= 3.0 && text_369.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_369.tStart = t;  // (not accounting for frame time here)
      text_369.frameNStart = frameN;  // exact frame index
      
      text_369.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_369.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_369.setAutoDraw(false);
    }
    
    // *text_370* updates
    if (t >= 4.0 && text_370.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_370.tStart = t;  // (not accounting for frame time here)
      text_370.frameNStart = frameN;  // exact frame index
      
      text_370.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_370.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_370.setAutoDraw(false);
    }
    
    // *key_resp_74* updates
    if (t >= 9.0 && key_resp_74.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_74.tStart = t;  // (not accounting for frame time here)
      key_resp_74.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_74.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_74.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_74.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_74.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_74.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_74.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_74.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_74_allKeys = _key_resp_74_allKeys.concat(theseKeys);
      if (_key_resp_74_allKeys.length > 0) {
        key_resp_74.keys = _key_resp_74_allKeys[_key_resp_74_allKeys.length - 1].name;  // just the last key pressed
        key_resp_74.rt = _key_resp_74_allKeys[_key_resp_74_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_74.keys == 'y') {
            key_resp_74.corr = 1;
        } else {
            key_resp_74.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jo_so_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jo_so_joRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jo_so_jo' ---
    jo_so_joComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_74.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_74.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_74.corr = 1;  // correct non-response
      } else {
         key_resp_74.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_74.corr, level);
    }
    psychoJS.experiment.addData('key_resp_74.keys', key_resp_74.keys);
    psychoJS.experiment.addData('key_resp_74.corr', key_resp_74.corr);
    if (typeof key_resp_74.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_74.rt', key_resp_74.rt);
        routineTimer.reset();
        }
    
    key_resp_74.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_51_allKeys;
var sojosojopsoComponents;
function sojosojopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sojosojopso' ---
    t = 0;
    sojosojopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_51.secs=3.5;
    sound_vowels_51.setVolume(1.0);
    key_resp_51.keys = undefined;
    key_resp_51.rt = undefined;
    _key_resp_51_allKeys = [];
    // keep track of which components have finished
    sojosojopsoComponents = [];
    sojosojopsoComponents.push(sound_vowels_51);
    sojosojopsoComponents.push(text_251);
    sojosojopsoComponents.push(text_252);
    sojosojopsoComponents.push(text_253);
    sojosojopsoComponents.push(text_254);
    sojosojopsoComponents.push(text_255);
    sojosojopsoComponents.push(key_resp_51);
    
    sojosojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sojosojopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sojosojopso' ---
    // get current time
    t = sojosojopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_51
    if (t >= 5 && sound_vowels_51.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_51.tStart = t;  // (not accounting for frame time here)
      sound_vowels_51.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_51.play(); });  // screen flip
      sound_vowels_51.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_51.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_51.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_51.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_251* updates
    if (t >= 0.0 && text_251.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_251.tStart = t;  // (not accounting for frame time here)
      text_251.frameNStart = frameN;  // exact frame index
      
      text_251.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_251.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_251.setAutoDraw(false);
    }
    
    // *text_252* updates
    if (t >= 9.0 && text_252.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_252.tStart = t;  // (not accounting for frame time here)
      text_252.frameNStart = frameN;  // exact frame index
      
      text_252.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_252.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_252.setAutoDraw(false);
    }
    
    // *text_253* updates
    if (t >= 2 && text_253.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_253.tStart = t;  // (not accounting for frame time here)
      text_253.frameNStart = frameN;  // exact frame index
      
      text_253.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_253.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_253.setAutoDraw(false);
    }
    
    // *text_254* updates
    if (t >= 3.0 && text_254.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_254.tStart = t;  // (not accounting for frame time here)
      text_254.frameNStart = frameN;  // exact frame index
      
      text_254.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_254.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_254.setAutoDraw(false);
    }
    
    // *text_255* updates
    if (t >= 4.0 && text_255.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_255.tStart = t;  // (not accounting for frame time here)
      text_255.frameNStart = frameN;  // exact frame index
      
      text_255.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_255.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_255.setAutoDraw(false);
    }
    
    // *key_resp_51* updates
    if (t >= 9.0 && key_resp_51.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_51.tStart = t;  // (not accounting for frame time here)
      key_resp_51.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_51.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_51.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_51.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_51.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_51.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_51.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_51.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_51_allKeys = _key_resp_51_allKeys.concat(theseKeys);
      if (_key_resp_51_allKeys.length > 0) {
        key_resp_51.keys = _key_resp_51_allKeys[_key_resp_51_allKeys.length - 1].name;  // just the last key pressed
        key_resp_51.rt = _key_resp_51_allKeys[_key_resp_51_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_51.keys == 'n') {
            key_resp_51.corr = 1;
        } else {
            key_resp_51.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sojosojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sojosojopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sojosojopso' ---
    sojosojopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_51.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_51.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_51.corr = 1;  // correct non-response
      } else {
         key_resp_51.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_51.corr, level);
    }
    psychoJS.experiment.addData('key_resp_51.keys', key_resp_51.keys);
    psychoJS.experiment.addData('key_resp_51.corr', key_resp_51.corr);
    if (typeof key_resp_51.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_51.rt', key_resp_51.rt);
        routineTimer.reset();
        }
    
    key_resp_51.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_49_allKeys;
var josojopjoComponents;
function josojopjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'josojopjo' ---
    t = 0;
    josojopjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_49.secs=3.5;
    sound_vowels_49.setVolume(1.0);
    key_resp_49.keys = undefined;
    key_resp_49.rt = undefined;
    _key_resp_49_allKeys = [];
    // keep track of which components have finished
    josojopjoComponents = [];
    josojopjoComponents.push(sound_vowels_49);
    josojopjoComponents.push(text_241);
    josojopjoComponents.push(text_242);
    josojopjoComponents.push(text_243);
    josojopjoComponents.push(text_244);
    josojopjoComponents.push(text_245);
    josojopjoComponents.push(key_resp_49);
    
    josojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function josojopjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'josojopjo' ---
    // get current time
    t = josojopjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_49
    if (t >= 5 && sound_vowels_49.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_49.tStart = t;  // (not accounting for frame time here)
      sound_vowels_49.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_49.play(); });  // screen flip
      sound_vowels_49.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_49.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_49.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_49.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_241* updates
    if (t >= 0.0 && text_241.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_241.tStart = t;  // (not accounting for frame time here)
      text_241.frameNStart = frameN;  // exact frame index
      
      text_241.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_241.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_241.setAutoDraw(false);
    }
    
    // *text_242* updates
    if (t >= 9.0 && text_242.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_242.tStart = t;  // (not accounting for frame time here)
      text_242.frameNStart = frameN;  // exact frame index
      
      text_242.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_242.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_242.setAutoDraw(false);
    }
    
    // *text_243* updates
    if (t >= 2 && text_243.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_243.tStart = t;  // (not accounting for frame time here)
      text_243.frameNStart = frameN;  // exact frame index
      
      text_243.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_243.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_243.setAutoDraw(false);
    }
    
    // *text_244* updates
    if (t >= 3.0 && text_244.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_244.tStart = t;  // (not accounting for frame time here)
      text_244.frameNStart = frameN;  // exact frame index
      
      text_244.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_244.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_244.setAutoDraw(false);
    }
    
    // *text_245* updates
    if (t >= 4.0 && text_245.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_245.tStart = t;  // (not accounting for frame time here)
      text_245.frameNStart = frameN;  // exact frame index
      
      text_245.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_245.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_245.setAutoDraw(false);
    }
    
    // *key_resp_49* updates
    if (t >= 9.0 && key_resp_49.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_49.tStart = t;  // (not accounting for frame time here)
      key_resp_49.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_49.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_49.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_49.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_49.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_49.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_49.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_49.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_49_allKeys = _key_resp_49_allKeys.concat(theseKeys);
      if (_key_resp_49_allKeys.length > 0) {
        key_resp_49.keys = _key_resp_49_allKeys[_key_resp_49_allKeys.length - 1].name;  // just the last key pressed
        key_resp_49.rt = _key_resp_49_allKeys[_key_resp_49_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_49.keys == 'n') {
            key_resp_49.corr = 1;
        } else {
            key_resp_49.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    josojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function josojopjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'josojopjo' ---
    josojopjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_49.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_49.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_49.corr = 1;  // correct non-response
      } else {
         key_resp_49.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_49.corr, level);
    }
    psychoJS.experiment.addData('key_resp_49.keys', key_resp_49.keys);
    psychoJS.experiment.addData('key_resp_49.corr', key_resp_49.corr);
    if (typeof key_resp_49.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_49.rt', key_resp_49.rt);
        routineTimer.reset();
        }
    
    key_resp_49.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_47_allKeys;
var joAjoApjoComponents;
function joAjoApjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'joAjoApjo' ---
    t = 0;
    joAjoApjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_47.secs=3.5;
    sound_vowels_47.setVolume(1.0);
    key_resp_47.keys = undefined;
    key_resp_47.rt = undefined;
    _key_resp_47_allKeys = [];
    // keep track of which components have finished
    joAjoApjoComponents = [];
    joAjoApjoComponents.push(sound_vowels_47);
    joAjoApjoComponents.push(text_231);
    joAjoApjoComponents.push(text_232);
    joAjoApjoComponents.push(text_233);
    joAjoApjoComponents.push(text_234);
    joAjoApjoComponents.push(text_235);
    joAjoApjoComponents.push(key_resp_47);
    
    joAjoApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function joAjoApjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'joAjoApjo' ---
    // get current time
    t = joAjoApjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_47
    if (t >= 5 && sound_vowels_47.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_47.tStart = t;  // (not accounting for frame time here)
      sound_vowels_47.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_47.play(); });  // screen flip
      sound_vowels_47.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_47.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_47.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_47.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_231* updates
    if (t >= 0.0 && text_231.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_231.tStart = t;  // (not accounting for frame time here)
      text_231.frameNStart = frameN;  // exact frame index
      
      text_231.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_231.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_231.setAutoDraw(false);
    }
    
    // *text_232* updates
    if (t >= 9.0 && text_232.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_232.tStart = t;  // (not accounting for frame time here)
      text_232.frameNStart = frameN;  // exact frame index
      
      text_232.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_232.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_232.setAutoDraw(false);
    }
    
    // *text_233* updates
    if (t >= 2 && text_233.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_233.tStart = t;  // (not accounting for frame time here)
      text_233.frameNStart = frameN;  // exact frame index
      
      text_233.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_233.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_233.setAutoDraw(false);
    }
    
    // *text_234* updates
    if (t >= 3.0 && text_234.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_234.tStart = t;  // (not accounting for frame time here)
      text_234.frameNStart = frameN;  // exact frame index
      
      text_234.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_234.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_234.setAutoDraw(false);
    }
    
    // *text_235* updates
    if (t >= 4.0 && text_235.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_235.tStart = t;  // (not accounting for frame time here)
      text_235.frameNStart = frameN;  // exact frame index
      
      text_235.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_235.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_235.setAutoDraw(false);
    }
    
    // *key_resp_47* updates
    if (t >= 9.0 && key_resp_47.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_47.tStart = t;  // (not accounting for frame time here)
      key_resp_47.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_47.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_47.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_47.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_47.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_47.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_47.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_47.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_47_allKeys = _key_resp_47_allKeys.concat(theseKeys);
      if (_key_resp_47_allKeys.length > 0) {
        key_resp_47.keys = _key_resp_47_allKeys[_key_resp_47_allKeys.length - 1].name;  // just the last key pressed
        key_resp_47.rt = _key_resp_47_allKeys[_key_resp_47_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_47.keys == 'n') {
            key_resp_47.corr = 1;
        } else {
            key_resp_47.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    joAjoApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function joAjoApjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'joAjoApjo' ---
    joAjoApjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_47.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_47.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_47.corr = 1;  // correct non-response
      } else {
         key_resp_47.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_47.corr, level);
    }
    psychoJS.experiment.addData('key_resp_47.keys', key_resp_47.keys);
    psychoJS.experiment.addData('key_resp_47.corr', key_resp_47.corr);
    if (typeof key_resp_47.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_47.rt', key_resp_47.rt);
        routineTimer.reset();
        }
    
    key_resp_47.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_80_allKeys;
var so_jo_joComponents;
function so_jo_joRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'so_jo_jo' ---
    t = 0;
    so_jo_joClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_80.secs=3.5;
    sound_vowels_80.setVolume(1.0);
    key_resp_80.keys = undefined;
    key_resp_80.rt = undefined;
    _key_resp_80_allKeys = [];
    // keep track of which components have finished
    so_jo_joComponents = [];
    so_jo_joComponents.push(sound_vowels_80);
    so_jo_joComponents.push(text_396);
    so_jo_joComponents.push(text_397);
    so_jo_joComponents.push(text_398);
    so_jo_joComponents.push(text_399);
    so_jo_joComponents.push(text_400);
    so_jo_joComponents.push(key_resp_80);
    
    so_jo_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function so_jo_joRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'so_jo_jo' ---
    // get current time
    t = so_jo_joClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_80
    if (t >= 5 && sound_vowels_80.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_80.tStart = t;  // (not accounting for frame time here)
      sound_vowels_80.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_80.play(); });  // screen flip
      sound_vowels_80.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_80.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_80.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_80.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_396* updates
    if (t >= 0.0 && text_396.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_396.tStart = t;  // (not accounting for frame time here)
      text_396.frameNStart = frameN;  // exact frame index
      
      text_396.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_396.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_396.setAutoDraw(false);
    }
    
    // *text_397* updates
    if (t >= 9.0 && text_397.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_397.tStart = t;  // (not accounting for frame time here)
      text_397.frameNStart = frameN;  // exact frame index
      
      text_397.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_397.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_397.setAutoDraw(false);
    }
    
    // *text_398* updates
    if (t >= 2 && text_398.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_398.tStart = t;  // (not accounting for frame time here)
      text_398.frameNStart = frameN;  // exact frame index
      
      text_398.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_398.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_398.setAutoDraw(false);
    }
    
    // *text_399* updates
    if (t >= 3.0 && text_399.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_399.tStart = t;  // (not accounting for frame time here)
      text_399.frameNStart = frameN;  // exact frame index
      
      text_399.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_399.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_399.setAutoDraw(false);
    }
    
    // *text_400* updates
    if (t >= 4.0 && text_400.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_400.tStart = t;  // (not accounting for frame time here)
      text_400.frameNStart = frameN;  // exact frame index
      
      text_400.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_400.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_400.setAutoDraw(false);
    }
    
    // *key_resp_80* updates
    if (t >= 9.0 && key_resp_80.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_80.tStart = t;  // (not accounting for frame time here)
      key_resp_80.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_80.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_80.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_80.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_80.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_80.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_80.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_80.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_80_allKeys = _key_resp_80_allKeys.concat(theseKeys);
      if (_key_resp_80_allKeys.length > 0) {
        key_resp_80.keys = _key_resp_80_allKeys[_key_resp_80_allKeys.length - 1].name;  // just the last key pressed
        key_resp_80.rt = _key_resp_80_allKeys[_key_resp_80_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_80.keys == 'y') {
            key_resp_80.corr = 1;
        } else {
            key_resp_80.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    so_jo_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function so_jo_joRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'so_jo_jo' ---
    so_jo_joComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_80.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_80.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_80.corr = 1;  // correct non-response
      } else {
         key_resp_80.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_80.corr, level);
    }
    psychoJS.experiment.addData('key_resp_80.keys', key_resp_80.keys);
    psychoJS.experiment.addData('key_resp_80.corr', key_resp_80.corr);
    if (typeof key_resp_80.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_80.rt', key_resp_80.rt);
        routineTimer.reset();
        }
    
    key_resp_80.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_46_allKeys;
var sousopsoComponents;
function sousopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sousopso' ---
    t = 0;
    sousopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_46.secs=3.5;
    sound_vowels_46.setVolume(1.0);
    key_resp_46.keys = undefined;
    key_resp_46.rt = undefined;
    _key_resp_46_allKeys = [];
    // keep track of which components have finished
    sousopsoComponents = [];
    sousopsoComponents.push(sound_vowels_46);
    sousopsoComponents.push(text_226);
    sousopsoComponents.push(text_227);
    sousopsoComponents.push(text_228);
    sousopsoComponents.push(text_229);
    sousopsoComponents.push(text_230);
    sousopsoComponents.push(key_resp_46);
    
    sousopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sousopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sousopso' ---
    // get current time
    t = sousopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_46
    if (t >= 5 && sound_vowels_46.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_46.tStart = t;  // (not accounting for frame time here)
      sound_vowels_46.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_46.play(); });  // screen flip
      sound_vowels_46.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_46.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_46.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_46.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_226* updates
    if (t >= 0.0 && text_226.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_226.tStart = t;  // (not accounting for frame time here)
      text_226.frameNStart = frameN;  // exact frame index
      
      text_226.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_226.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_226.setAutoDraw(false);
    }
    
    // *text_227* updates
    if (t >= 9.0 && text_227.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_227.tStart = t;  // (not accounting for frame time here)
      text_227.frameNStart = frameN;  // exact frame index
      
      text_227.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_227.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_227.setAutoDraw(false);
    }
    
    // *text_228* updates
    if (t >= 2 && text_228.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_228.tStart = t;  // (not accounting for frame time here)
      text_228.frameNStart = frameN;  // exact frame index
      
      text_228.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_228.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_228.setAutoDraw(false);
    }
    
    // *text_229* updates
    if (t >= 3.0 && text_229.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_229.tStart = t;  // (not accounting for frame time here)
      text_229.frameNStart = frameN;  // exact frame index
      
      text_229.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_229.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_229.setAutoDraw(false);
    }
    
    // *text_230* updates
    if (t >= 4.0 && text_230.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_230.tStart = t;  // (not accounting for frame time here)
      text_230.frameNStart = frameN;  // exact frame index
      
      text_230.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_230.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_230.setAutoDraw(false);
    }
    
    // *key_resp_46* updates
    if (t >= 9.0 && key_resp_46.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_46.tStart = t;  // (not accounting for frame time here)
      key_resp_46.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_46.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_46.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_46.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_46.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_46.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_46.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_46.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_46_allKeys = _key_resp_46_allKeys.concat(theseKeys);
      if (_key_resp_46_allKeys.length > 0) {
        key_resp_46.keys = _key_resp_46_allKeys[_key_resp_46_allKeys.length - 1].name;  // just the last key pressed
        key_resp_46.rt = _key_resp_46_allKeys[_key_resp_46_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_46.keys == 'n') {
            key_resp_46.corr = 1;
        } else {
            key_resp_46.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sousopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sousopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sousopso' ---
    sousopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_46.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_46.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_46.corr = 1;  // correct non-response
      } else {
         key_resp_46.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_46.corr, level);
    }
    psychoJS.experiment.addData('key_resp_46.keys', key_resp_46.keys);
    psychoJS.experiment.addData('key_resp_46.corr', key_resp_46.corr);
    if (typeof key_resp_46.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_46.rt', key_resp_46.rt);
        routineTimer.reset();
        }
    
    key_resp_46.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_79_allKeys;
var sa_sa_jaComponents;
function sa_sa_jaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_sa_ja' ---
    t = 0;
    sa_sa_jaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_79.secs=3.5;
    sound_vowels_79.setVolume(1.0);
    key_resp_79.keys = undefined;
    key_resp_79.rt = undefined;
    _key_resp_79_allKeys = [];
    // keep track of which components have finished
    sa_sa_jaComponents = [];
    sa_sa_jaComponents.push(sound_vowels_79);
    sa_sa_jaComponents.push(text_391);
    sa_sa_jaComponents.push(text_392);
    sa_sa_jaComponents.push(text_393);
    sa_sa_jaComponents.push(text_394);
    sa_sa_jaComponents.push(text_395);
    sa_sa_jaComponents.push(key_resp_79);
    
    sa_sa_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_sa_jaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_sa_ja' ---
    // get current time
    t = sa_sa_jaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_79
    if (t >= 5 && sound_vowels_79.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_79.tStart = t;  // (not accounting for frame time here)
      sound_vowels_79.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_79.play(); });  // screen flip
      sound_vowels_79.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_79.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_79.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_79.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_391* updates
    if (t >= 0.0 && text_391.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_391.tStart = t;  // (not accounting for frame time here)
      text_391.frameNStart = frameN;  // exact frame index
      
      text_391.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_391.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_391.setAutoDraw(false);
    }
    
    // *text_392* updates
    if (t >= 9.0 && text_392.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_392.tStart = t;  // (not accounting for frame time here)
      text_392.frameNStart = frameN;  // exact frame index
      
      text_392.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_392.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_392.setAutoDraw(false);
    }
    
    // *text_393* updates
    if (t >= 2 && text_393.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_393.tStart = t;  // (not accounting for frame time here)
      text_393.frameNStart = frameN;  // exact frame index
      
      text_393.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_393.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_393.setAutoDraw(false);
    }
    
    // *text_394* updates
    if (t >= 3.0 && text_394.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_394.tStart = t;  // (not accounting for frame time here)
      text_394.frameNStart = frameN;  // exact frame index
      
      text_394.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_394.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_394.setAutoDraw(false);
    }
    
    // *text_395* updates
    if (t >= 4.0 && text_395.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_395.tStart = t;  // (not accounting for frame time here)
      text_395.frameNStart = frameN;  // exact frame index
      
      text_395.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_395.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_395.setAutoDraw(false);
    }
    
    // *key_resp_79* updates
    if (t >= 9.0 && key_resp_79.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_79.tStart = t;  // (not accounting for frame time here)
      key_resp_79.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_79.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_79.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_79.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_79.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_79.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_79.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_79.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_79_allKeys = _key_resp_79_allKeys.concat(theseKeys);
      if (_key_resp_79_allKeys.length > 0) {
        key_resp_79.keys = _key_resp_79_allKeys[_key_resp_79_allKeys.length - 1].name;  // just the last key pressed
        key_resp_79.rt = _key_resp_79_allKeys[_key_resp_79_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_79.keys == 'y') {
            key_resp_79.corr = 1;
        } else {
            key_resp_79.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_sa_jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_sa_jaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_sa_ja' ---
    sa_sa_jaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_79.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_79.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_79.corr = 1;  // correct non-response
      } else {
         key_resp_79.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_79.corr, level);
    }
    psychoJS.experiment.addData('key_resp_79.keys', key_resp_79.keys);
    psychoJS.experiment.addData('key_resp_79.corr', key_resp_79.corr);
    if (typeof key_resp_79.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_79.rt', key_resp_79.rt);
        routineTimer.reset();
        }
    
    key_resp_79.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_42_allKeys;
var joAjopjoComponents;
function joAjopjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'joAjopjo' ---
    t = 0;
    joAjopjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_42.secs=3.5;
    sound_vowels_42.setVolume(1.0);
    key_resp_42.keys = undefined;
    key_resp_42.rt = undefined;
    _key_resp_42_allKeys = [];
    // keep track of which components have finished
    joAjopjoComponents = [];
    joAjopjoComponents.push(sound_vowels_42);
    joAjopjoComponents.push(text_206);
    joAjopjoComponents.push(text_207);
    joAjopjoComponents.push(text_208);
    joAjopjoComponents.push(text_209);
    joAjopjoComponents.push(text_210);
    joAjopjoComponents.push(key_resp_42);
    
    joAjopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function joAjopjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'joAjopjo' ---
    // get current time
    t = joAjopjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_42
    if (t >= 5 && sound_vowels_42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_42.tStart = t;  // (not accounting for frame time here)
      sound_vowels_42.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_42.play(); });  // screen flip
      sound_vowels_42.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_42.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_42.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_42.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_206* updates
    if (t >= 0.0 && text_206.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_206.tStart = t;  // (not accounting for frame time here)
      text_206.frameNStart = frameN;  // exact frame index
      
      text_206.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_206.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_206.setAutoDraw(false);
    }
    
    // *text_207* updates
    if (t >= 9.0 && text_207.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_207.tStart = t;  // (not accounting for frame time here)
      text_207.frameNStart = frameN;  // exact frame index
      
      text_207.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_207.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_207.setAutoDraw(false);
    }
    
    // *text_208* updates
    if (t >= 2 && text_208.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_208.tStart = t;  // (not accounting for frame time here)
      text_208.frameNStart = frameN;  // exact frame index
      
      text_208.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_208.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_208.setAutoDraw(false);
    }
    
    // *text_209* updates
    if (t >= 3.0 && text_209.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_209.tStart = t;  // (not accounting for frame time here)
      text_209.frameNStart = frameN;  // exact frame index
      
      text_209.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_209.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_209.setAutoDraw(false);
    }
    
    // *text_210* updates
    if (t >= 4.0 && text_210.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_210.tStart = t;  // (not accounting for frame time here)
      text_210.frameNStart = frameN;  // exact frame index
      
      text_210.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_210.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_210.setAutoDraw(false);
    }
    
    // *key_resp_42* updates
    if (t >= 9.0 && key_resp_42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_42.tStart = t;  // (not accounting for frame time here)
      key_resp_42.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_42.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_42.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_42.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_42.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_42.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_42.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_42.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_42_allKeys = _key_resp_42_allKeys.concat(theseKeys);
      if (_key_resp_42_allKeys.length > 0) {
        key_resp_42.keys = _key_resp_42_allKeys[_key_resp_42_allKeys.length - 1].name;  // just the last key pressed
        key_resp_42.rt = _key_resp_42_allKeys[_key_resp_42_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_42.keys == 'n') {
            key_resp_42.corr = 1;
        } else {
            key_resp_42.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    joAjopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function joAjopjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'joAjopjo' ---
    joAjopjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_42.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_42.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_42.corr = 1;  // correct non-response
      } else {
         key_resp_42.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_42.corr, level);
    }
    psychoJS.experiment.addData('key_resp_42.keys', key_resp_42.keys);
    psychoJS.experiment.addData('key_resp_42.corr', key_resp_42.corr);
    if (typeof key_resp_42.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_42.rt', key_resp_42.rt);
        routineTimer.reset();
        }
    
    key_resp_42.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_60_allKeys;
var sa_sa_japsaComponents;
function sa_sa_japsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_sa_japsa' ---
    t = 0;
    sa_sa_japsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_60.secs=3.5;
    sound_vowels_60.setVolume(1.0);
    key_resp_60.keys = undefined;
    key_resp_60.rt = undefined;
    _key_resp_60_allKeys = [];
    // keep track of which components have finished
    sa_sa_japsaComponents = [];
    sa_sa_japsaComponents.push(sound_vowels_60);
    sa_sa_japsaComponents.push(text_296);
    sa_sa_japsaComponents.push(text_297);
    sa_sa_japsaComponents.push(text_298);
    sa_sa_japsaComponents.push(text_299);
    sa_sa_japsaComponents.push(text_300);
    sa_sa_japsaComponents.push(key_resp_60);
    
    sa_sa_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_sa_japsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_sa_japsa' ---
    // get current time
    t = sa_sa_japsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_60
    if (t >= 5 && sound_vowels_60.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_60.tStart = t;  // (not accounting for frame time here)
      sound_vowels_60.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_60.play(); });  // screen flip
      sound_vowels_60.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_60.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_60.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_60.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_296* updates
    if (t >= 0.0 && text_296.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_296.tStart = t;  // (not accounting for frame time here)
      text_296.frameNStart = frameN;  // exact frame index
      
      text_296.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_296.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_296.setAutoDraw(false);
    }
    
    // *text_297* updates
    if (t >= 9.0 && text_297.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_297.tStart = t;  // (not accounting for frame time here)
      text_297.frameNStart = frameN;  // exact frame index
      
      text_297.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_297.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_297.setAutoDraw(false);
    }
    
    // *text_298* updates
    if (t >= 2 && text_298.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_298.tStart = t;  // (not accounting for frame time here)
      text_298.frameNStart = frameN;  // exact frame index
      
      text_298.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_298.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_298.setAutoDraw(false);
    }
    
    // *text_299* updates
    if (t >= 3.0 && text_299.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_299.tStart = t;  // (not accounting for frame time here)
      text_299.frameNStart = frameN;  // exact frame index
      
      text_299.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_299.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_299.setAutoDraw(false);
    }
    
    // *text_300* updates
    if (t >= 4.0 && text_300.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_300.tStart = t;  // (not accounting for frame time here)
      text_300.frameNStart = frameN;  // exact frame index
      
      text_300.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_300.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_300.setAutoDraw(false);
    }
    
    // *key_resp_60* updates
    if (t >= 9.0 && key_resp_60.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_60.tStart = t;  // (not accounting for frame time here)
      key_resp_60.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_60.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_60.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_60.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_60.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_60.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_60.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_60.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_60_allKeys = _key_resp_60_allKeys.concat(theseKeys);
      if (_key_resp_60_allKeys.length > 0) {
        key_resp_60.keys = _key_resp_60_allKeys[_key_resp_60_allKeys.length - 1].name;  // just the last key pressed
        key_resp_60.rt = _key_resp_60_allKeys[_key_resp_60_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_60.keys == 'n') {
            key_resp_60.corr = 1;
        } else {
            key_resp_60.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_sa_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_sa_japsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_sa_japsa' ---
    sa_sa_japsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_60.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_60.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_60.corr = 1;  // correct non-response
      } else {
         key_resp_60.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_60.corr, level);
    }
    psychoJS.experiment.addData('key_resp_60.keys', key_resp_60.keys);
    psychoJS.experiment.addData('key_resp_60.corr', key_resp_60.corr);
    if (typeof key_resp_60.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_60.rt', key_resp_60.rt);
        routineTimer.reset();
        }
    
    key_resp_60.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_72_allKeys;
var jo_A_joComponents;
function jo_A_joRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jo_A_jo' ---
    t = 0;
    jo_A_joClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_72.secs=3.5;
    sound_vowels_72.setVolume(1.0);
    key_resp_72.keys = undefined;
    key_resp_72.rt = undefined;
    _key_resp_72_allKeys = [];
    // keep track of which components have finished
    jo_A_joComponents = [];
    jo_A_joComponents.push(sound_vowels_72);
    jo_A_joComponents.push(text_356);
    jo_A_joComponents.push(text_357);
    jo_A_joComponents.push(text_358);
    jo_A_joComponents.push(text_359);
    jo_A_joComponents.push(text_360);
    jo_A_joComponents.push(key_resp_72);
    
    jo_A_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jo_A_joRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jo_A_jo' ---
    // get current time
    t = jo_A_joClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_72
    if (t >= 5 && sound_vowels_72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_72.tStart = t;  // (not accounting for frame time here)
      sound_vowels_72.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_72.play(); });  // screen flip
      sound_vowels_72.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_72.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_72.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_72.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_356* updates
    if (t >= 0.0 && text_356.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_356.tStart = t;  // (not accounting for frame time here)
      text_356.frameNStart = frameN;  // exact frame index
      
      text_356.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_356.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_356.setAutoDraw(false);
    }
    
    // *text_357* updates
    if (t >= 9.0 && text_357.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_357.tStart = t;  // (not accounting for frame time here)
      text_357.frameNStart = frameN;  // exact frame index
      
      text_357.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_357.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_357.setAutoDraw(false);
    }
    
    // *text_358* updates
    if (t >= 2 && text_358.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_358.tStart = t;  // (not accounting for frame time here)
      text_358.frameNStart = frameN;  // exact frame index
      
      text_358.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_358.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_358.setAutoDraw(false);
    }
    
    // *text_359* updates
    if (t >= 3.0 && text_359.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_359.tStart = t;  // (not accounting for frame time here)
      text_359.frameNStart = frameN;  // exact frame index
      
      text_359.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_359.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_359.setAutoDraw(false);
    }
    
    // *text_360* updates
    if (t >= 4.0 && text_360.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_360.tStart = t;  // (not accounting for frame time here)
      text_360.frameNStart = frameN;  // exact frame index
      
      text_360.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_360.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_360.setAutoDraw(false);
    }
    
    // *key_resp_72* updates
    if (t >= 9.0 && key_resp_72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_72.tStart = t;  // (not accounting for frame time here)
      key_resp_72.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_72.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_72.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_72.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_72.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_72.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_72.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_72.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_72_allKeys = _key_resp_72_allKeys.concat(theseKeys);
      if (_key_resp_72_allKeys.length > 0) {
        key_resp_72.keys = _key_resp_72_allKeys[_key_resp_72_allKeys.length - 1].name;  // just the last key pressed
        key_resp_72.rt = _key_resp_72_allKeys[_key_resp_72_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_72.keys == 'y') {
            key_resp_72.corr = 1;
        } else {
            key_resp_72.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jo_A_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jo_A_joRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jo_A_jo' ---
    jo_A_joComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_72.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_72.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_72.corr = 1;  // correct non-response
      } else {
         key_resp_72.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_72.corr, level);
    }
    psychoJS.experiment.addData('key_resp_72.keys', key_resp_72.keys);
    psychoJS.experiment.addData('key_resp_72.corr', key_resp_72.corr);
    if (typeof key_resp_72.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_72.rt', key_resp_72.rt);
        routineTimer.reset();
        }
    
    key_resp_72.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_53_allKeys;
var sojosopjoComponents;
function sojosopjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sojosopjo' ---
    t = 0;
    sojosopjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_53.secs=3.5;
    sound_vowels_53.setVolume(1.0);
    key_resp_53.keys = undefined;
    key_resp_53.rt = undefined;
    _key_resp_53_allKeys = [];
    // keep track of which components have finished
    sojosopjoComponents = [];
    sojosopjoComponents.push(sound_vowels_53);
    sojosopjoComponents.push(text_261);
    sojosopjoComponents.push(text_262);
    sojosopjoComponents.push(text_263);
    sojosopjoComponents.push(text_264);
    sojosopjoComponents.push(text_265);
    sojosopjoComponents.push(key_resp_53);
    
    sojosopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sojosopjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sojosopjo' ---
    // get current time
    t = sojosopjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_53
    if (t >= 5 && sound_vowels_53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_53.tStart = t;  // (not accounting for frame time here)
      sound_vowels_53.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_53.play(); });  // screen flip
      sound_vowels_53.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_53.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_53.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_53.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_261* updates
    if (t >= 0.0 && text_261.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_261.tStart = t;  // (not accounting for frame time here)
      text_261.frameNStart = frameN;  // exact frame index
      
      text_261.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_261.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_261.setAutoDraw(false);
    }
    
    // *text_262* updates
    if (t >= 9.0 && text_262.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_262.tStart = t;  // (not accounting for frame time here)
      text_262.frameNStart = frameN;  // exact frame index
      
      text_262.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_262.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_262.setAutoDraw(false);
    }
    
    // *text_263* updates
    if (t >= 2 && text_263.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_263.tStart = t;  // (not accounting for frame time here)
      text_263.frameNStart = frameN;  // exact frame index
      
      text_263.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_263.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_263.setAutoDraw(false);
    }
    
    // *text_264* updates
    if (t >= 3.0 && text_264.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_264.tStart = t;  // (not accounting for frame time here)
      text_264.frameNStart = frameN;  // exact frame index
      
      text_264.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_264.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_264.setAutoDraw(false);
    }
    
    // *text_265* updates
    if (t >= 4.0 && text_265.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_265.tStart = t;  // (not accounting for frame time here)
      text_265.frameNStart = frameN;  // exact frame index
      
      text_265.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_265.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_265.setAutoDraw(false);
    }
    
    // *key_resp_53* updates
    if (t >= 9.0 && key_resp_53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_53.tStart = t;  // (not accounting for frame time here)
      key_resp_53.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_53.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_53.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_53.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_53.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_53.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_53.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_53.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_53_allKeys = _key_resp_53_allKeys.concat(theseKeys);
      if (_key_resp_53_allKeys.length > 0) {
        key_resp_53.keys = _key_resp_53_allKeys[_key_resp_53_allKeys.length - 1].name;  // just the last key pressed
        key_resp_53.rt = _key_resp_53_allKeys[_key_resp_53_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_53.keys == 'n') {
            key_resp_53.corr = 1;
        } else {
            key_resp_53.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sojosopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sojosopjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sojosopjo' ---
    sojosopjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_53.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_53.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_53.corr = 1;  // correct non-response
      } else {
         key_resp_53.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_53.corr, level);
    }
    psychoJS.experiment.addData('key_resp_53.keys', key_resp_53.keys);
    psychoJS.experiment.addData('key_resp_53.corr', key_resp_53.corr);
    if (typeof key_resp_53.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_53.rt', key_resp_53.rt);
        routineTimer.reset();
        }
    
    key_resp_53.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_62_allKeys;
var sa_ja_japjaComponents;
function sa_ja_japjaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_japja' ---
    t = 0;
    sa_ja_japjaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_62.secs=3.5;
    sound_vowels_62.setVolume(1.0);
    key_resp_62.keys = undefined;
    key_resp_62.rt = undefined;
    _key_resp_62_allKeys = [];
    // keep track of which components have finished
    sa_ja_japjaComponents = [];
    sa_ja_japjaComponents.push(sound_vowels_62);
    sa_ja_japjaComponents.push(text_306);
    sa_ja_japjaComponents.push(text_307);
    sa_ja_japjaComponents.push(text_308);
    sa_ja_japjaComponents.push(text_309);
    sa_ja_japjaComponents.push(text_310);
    sa_ja_japjaComponents.push(key_resp_62);
    
    sa_ja_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_japjaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_japja' ---
    // get current time
    t = sa_ja_japjaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_62
    if (t >= 5 && sound_vowels_62.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_62.tStart = t;  // (not accounting for frame time here)
      sound_vowels_62.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_62.play(); });  // screen flip
      sound_vowels_62.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_62.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_62.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_62.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_306* updates
    if (t >= 0.0 && text_306.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_306.tStart = t;  // (not accounting for frame time here)
      text_306.frameNStart = frameN;  // exact frame index
      
      text_306.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_306.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_306.setAutoDraw(false);
    }
    
    // *text_307* updates
    if (t >= 9.0 && text_307.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_307.tStart = t;  // (not accounting for frame time here)
      text_307.frameNStart = frameN;  // exact frame index
      
      text_307.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_307.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_307.setAutoDraw(false);
    }
    
    // *text_308* updates
    if (t >= 2 && text_308.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_308.tStart = t;  // (not accounting for frame time here)
      text_308.frameNStart = frameN;  // exact frame index
      
      text_308.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_308.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_308.setAutoDraw(false);
    }
    
    // *text_309* updates
    if (t >= 3.0 && text_309.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_309.tStart = t;  // (not accounting for frame time here)
      text_309.frameNStart = frameN;  // exact frame index
      
      text_309.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_309.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_309.setAutoDraw(false);
    }
    
    // *text_310* updates
    if (t >= 4.0 && text_310.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_310.tStart = t;  // (not accounting for frame time here)
      text_310.frameNStart = frameN;  // exact frame index
      
      text_310.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_310.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_310.setAutoDraw(false);
    }
    
    // *key_resp_62* updates
    if (t >= 9.0 && key_resp_62.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_62.tStart = t;  // (not accounting for frame time here)
      key_resp_62.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_62.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_62.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_62.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_62.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_62.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_62.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_62.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_62_allKeys = _key_resp_62_allKeys.concat(theseKeys);
      if (_key_resp_62_allKeys.length > 0) {
        key_resp_62.keys = _key_resp_62_allKeys[_key_resp_62_allKeys.length - 1].name;  // just the last key pressed
        key_resp_62.rt = _key_resp_62_allKeys[_key_resp_62_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_62.keys == 'n') {
            key_resp_62.corr = 1;
        } else {
            key_resp_62.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_japjaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_japja' ---
    sa_ja_japjaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_62.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_62.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_62.corr = 1;  // correct non-response
      } else {
         key_resp_62.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_62.corr, level);
    }
    psychoJS.experiment.addData('key_resp_62.keys', key_resp_62.keys);
    psychoJS.experiment.addData('key_resp_62.corr', key_resp_62.corr);
    if (typeof key_resp_62.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_62.rt', key_resp_62.rt);
        routineTimer.reset();
        }
    
    key_resp_62.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_41_allKeys;
var joAjopAComponents;
function joAjopARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'joAjopA' ---
    t = 0;
    joAjopAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_41.secs=3.5;
    sound_vowels_41.setVolume(1.0);
    key_resp_41.keys = undefined;
    key_resp_41.rt = undefined;
    _key_resp_41_allKeys = [];
    // keep track of which components have finished
    joAjopAComponents = [];
    joAjopAComponents.push(sound_vowels_41);
    joAjopAComponents.push(text_201);
    joAjopAComponents.push(text_202);
    joAjopAComponents.push(text_203);
    joAjopAComponents.push(text_204);
    joAjopAComponents.push(text_205);
    joAjopAComponents.push(key_resp_41);
    
    joAjopAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function joAjopARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'joAjopA' ---
    // get current time
    t = joAjopAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_41
    if (t >= 5 && sound_vowels_41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_41.tStart = t;  // (not accounting for frame time here)
      sound_vowels_41.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_41.play(); });  // screen flip
      sound_vowels_41.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_41.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_41.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_41.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_201* updates
    if (t >= 0.0 && text_201.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_201.tStart = t;  // (not accounting for frame time here)
      text_201.frameNStart = frameN;  // exact frame index
      
      text_201.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_201.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_201.setAutoDraw(false);
    }
    
    // *text_202* updates
    if (t >= 9.0 && text_202.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_202.tStart = t;  // (not accounting for frame time here)
      text_202.frameNStart = frameN;  // exact frame index
      
      text_202.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_202.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_202.setAutoDraw(false);
    }
    
    // *text_203* updates
    if (t >= 2 && text_203.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_203.tStart = t;  // (not accounting for frame time here)
      text_203.frameNStart = frameN;  // exact frame index
      
      text_203.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_203.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_203.setAutoDraw(false);
    }
    
    // *text_204* updates
    if (t >= 3.0 && text_204.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_204.tStart = t;  // (not accounting for frame time here)
      text_204.frameNStart = frameN;  // exact frame index
      
      text_204.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_204.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_204.setAutoDraw(false);
    }
    
    // *text_205* updates
    if (t >= 4.0 && text_205.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_205.tStart = t;  // (not accounting for frame time here)
      text_205.frameNStart = frameN;  // exact frame index
      
      text_205.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_205.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_205.setAutoDraw(false);
    }
    
    // *key_resp_41* updates
    if (t >= 9.0 && key_resp_41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_41.tStart = t;  // (not accounting for frame time here)
      key_resp_41.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_41.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_41.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_41.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_41.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_41.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_41.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_41.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_41_allKeys = _key_resp_41_allKeys.concat(theseKeys);
      if (_key_resp_41_allKeys.length > 0) {
        key_resp_41.keys = _key_resp_41_allKeys[_key_resp_41_allKeys.length - 1].name;  // just the last key pressed
        key_resp_41.rt = _key_resp_41_allKeys[_key_resp_41_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_41.keys == 'n') {
            key_resp_41.corr = 1;
        } else {
            key_resp_41.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    joAjopAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function joAjopARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'joAjopA' ---
    joAjopAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_41.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_41.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_41.corr = 1;  // correct non-response
      } else {
         key_resp_41.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_41.corr, level);
    }
    psychoJS.experiment.addData('key_resp_41.keys', key_resp_41.keys);
    psychoJS.experiment.addData('key_resp_41.corr', key_resp_41.corr);
    if (typeof key_resp_41.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_41.rt', key_resp_41.rt);
        routineTimer.reset();
        }
    
    key_resp_41.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_37_allKeys;
var sapjaComponents;
function sapjaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sapja' ---
    t = 0;
    sapjaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_37.secs=3.5;
    sound_vowels_37.setVolume(1.0);
    key_resp_37.keys = undefined;
    key_resp_37.rt = undefined;
    _key_resp_37_allKeys = [];
    // keep track of which components have finished
    sapjaComponents = [];
    sapjaComponents.push(sound_vowels_37);
    sapjaComponents.push(text_181);
    sapjaComponents.push(text_182);
    sapjaComponents.push(text_183);
    sapjaComponents.push(text_184);
    sapjaComponents.push(text_185);
    sapjaComponents.push(key_resp_37);
    
    sapjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sapjaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sapja' ---
    // get current time
    t = sapjaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_37
    if (t >= 5 && sound_vowels_37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_37.tStart = t;  // (not accounting for frame time here)
      sound_vowels_37.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_37.play(); });  // screen flip
      sound_vowels_37.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_37.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_37.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_37.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_181* updates
    if (t >= 0.0 && text_181.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_181.tStart = t;  // (not accounting for frame time here)
      text_181.frameNStart = frameN;  // exact frame index
      
      text_181.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_181.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_181.setAutoDraw(false);
    }
    
    // *text_182* updates
    if (t >= 9.0 && text_182.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_182.tStart = t;  // (not accounting for frame time here)
      text_182.frameNStart = frameN;  // exact frame index
      
      text_182.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_182.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_182.setAutoDraw(false);
    }
    
    // *text_183* updates
    if (t >= 2 && text_183.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_183.tStart = t;  // (not accounting for frame time here)
      text_183.frameNStart = frameN;  // exact frame index
      
      text_183.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_183.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_183.setAutoDraw(false);
    }
    
    // *text_184* updates
    if (t >= 3.0 && text_184.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_184.tStart = t;  // (not accounting for frame time here)
      text_184.frameNStart = frameN;  // exact frame index
      
      text_184.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_184.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_184.setAutoDraw(false);
    }
    
    // *text_185* updates
    if (t >= 4.0 && text_185.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_185.tStart = t;  // (not accounting for frame time here)
      text_185.frameNStart = frameN;  // exact frame index
      
      text_185.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_185.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_185.setAutoDraw(false);
    }
    
    // *key_resp_37* updates
    if (t >= 9.0 && key_resp_37.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_37.tStart = t;  // (not accounting for frame time here)
      key_resp_37.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_37.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_37.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_37.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_37.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_37.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_37.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_37.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_37_allKeys = _key_resp_37_allKeys.concat(theseKeys);
      if (_key_resp_37_allKeys.length > 0) {
        key_resp_37.keys = _key_resp_37_allKeys[_key_resp_37_allKeys.length - 1].name;  // just the last key pressed
        key_resp_37.rt = _key_resp_37_allKeys[_key_resp_37_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_37.keys == 'n') {
            key_resp_37.corr = 1;
        } else {
            key_resp_37.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sapjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sapjaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sapja' ---
    sapjaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_37.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_37.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_37.corr = 1;  // correct non-response
      } else {
         key_resp_37.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_37.corr, level);
    }
    psychoJS.experiment.addData('key_resp_37.keys', key_resp_37.keys);
    psychoJS.experiment.addData('key_resp_37.corr', key_resp_37.corr);
    if (typeof key_resp_37.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_37.rt', key_resp_37.rt);
        routineTimer.reset();
        }
    
    key_resp_37.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_64_allKeys;
var sa_ja_sa_japjaComponents;
function sa_ja_sa_japjaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_sa_japja' ---
    t = 0;
    sa_ja_sa_japjaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_64.secs=3.5;
    sound_vowels_64.setVolume(1.0);
    key_resp_64.keys = undefined;
    key_resp_64.rt = undefined;
    _key_resp_64_allKeys = [];
    // keep track of which components have finished
    sa_ja_sa_japjaComponents = [];
    sa_ja_sa_japjaComponents.push(sound_vowels_64);
    sa_ja_sa_japjaComponents.push(text_316);
    sa_ja_sa_japjaComponents.push(text_317);
    sa_ja_sa_japjaComponents.push(text_318);
    sa_ja_sa_japjaComponents.push(text_319);
    sa_ja_sa_japjaComponents.push(text_320);
    sa_ja_sa_japjaComponents.push(key_resp_64);
    
    sa_ja_sa_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_sa_japjaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_sa_japja' ---
    // get current time
    t = sa_ja_sa_japjaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_64
    if (t >= 5 && sound_vowels_64.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_64.tStart = t;  // (not accounting for frame time here)
      sound_vowels_64.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_64.play(); });  // screen flip
      sound_vowels_64.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_64.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_64.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_64.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_316* updates
    if (t >= 0.0 && text_316.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_316.tStart = t;  // (not accounting for frame time here)
      text_316.frameNStart = frameN;  // exact frame index
      
      text_316.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_316.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_316.setAutoDraw(false);
    }
    
    // *text_317* updates
    if (t >= 9.0 && text_317.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_317.tStart = t;  // (not accounting for frame time here)
      text_317.frameNStart = frameN;  // exact frame index
      
      text_317.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_317.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_317.setAutoDraw(false);
    }
    
    // *text_318* updates
    if (t >= 2 && text_318.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_318.tStart = t;  // (not accounting for frame time here)
      text_318.frameNStart = frameN;  // exact frame index
      
      text_318.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_318.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_318.setAutoDraw(false);
    }
    
    // *text_319* updates
    if (t >= 3.0 && text_319.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_319.tStart = t;  // (not accounting for frame time here)
      text_319.frameNStart = frameN;  // exact frame index
      
      text_319.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_319.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_319.setAutoDraw(false);
    }
    
    // *text_320* updates
    if (t >= 4.0 && text_320.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_320.tStart = t;  // (not accounting for frame time here)
      text_320.frameNStart = frameN;  // exact frame index
      
      text_320.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_320.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_320.setAutoDraw(false);
    }
    
    // *key_resp_64* updates
    if (t >= 9.0 && key_resp_64.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_64.tStart = t;  // (not accounting for frame time here)
      key_resp_64.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_64.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_64.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_64.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_64.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_64.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_64.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_64.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_64_allKeys = _key_resp_64_allKeys.concat(theseKeys);
      if (_key_resp_64_allKeys.length > 0) {
        key_resp_64.keys = _key_resp_64_allKeys[_key_resp_64_allKeys.length - 1].name;  // just the last key pressed
        key_resp_64.rt = _key_resp_64_allKeys[_key_resp_64_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_64.keys == 'n') {
            key_resp_64.corr = 1;
        } else {
            key_resp_64.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_sa_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_sa_japjaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_sa_japja' ---
    sa_ja_sa_japjaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_64.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_64.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_64.corr = 1;  // correct non-response
      } else {
         key_resp_64.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_64.corr, level);
    }
    psychoJS.experiment.addData('key_resp_64.keys', key_resp_64.keys);
    psychoJS.experiment.addData('key_resp_64.corr', key_resp_64.corr);
    if (typeof key_resp_64.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_64.rt', key_resp_64.rt);
        routineTimer.reset();
        }
    
    key_resp_64.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_57_allKeys;
var josojopsoComponents;
function josojopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'josojopso' ---
    t = 0;
    josojopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_57.secs=3.5;
    sound_vowels_57.setVolume(1.0);
    key_resp_57.keys = undefined;
    key_resp_57.rt = undefined;
    _key_resp_57_allKeys = [];
    // keep track of which components have finished
    josojopsoComponents = [];
    josojopsoComponents.push(sound_vowels_57);
    josojopsoComponents.push(text_281);
    josojopsoComponents.push(text_282);
    josojopsoComponents.push(text_283);
    josojopsoComponents.push(text_284);
    josojopsoComponents.push(text_285);
    josojopsoComponents.push(key_resp_57);
    
    josojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function josojopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'josojopso' ---
    // get current time
    t = josojopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_57
    if (t >= 5 && sound_vowels_57.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_57.tStart = t;  // (not accounting for frame time here)
      sound_vowels_57.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_57.play(); });  // screen flip
      sound_vowels_57.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_57.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_57.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_57.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_281* updates
    if (t >= 0.0 && text_281.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_281.tStart = t;  // (not accounting for frame time here)
      text_281.frameNStart = frameN;  // exact frame index
      
      text_281.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_281.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_281.setAutoDraw(false);
    }
    
    // *text_282* updates
    if (t >= 9.0 && text_282.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_282.tStart = t;  // (not accounting for frame time here)
      text_282.frameNStart = frameN;  // exact frame index
      
      text_282.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_282.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_282.setAutoDraw(false);
    }
    
    // *text_283* updates
    if (t >= 2 && text_283.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_283.tStart = t;  // (not accounting for frame time here)
      text_283.frameNStart = frameN;  // exact frame index
      
      text_283.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_283.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_283.setAutoDraw(false);
    }
    
    // *text_284* updates
    if (t >= 3.0 && text_284.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_284.tStart = t;  // (not accounting for frame time here)
      text_284.frameNStart = frameN;  // exact frame index
      
      text_284.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_284.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_284.setAutoDraw(false);
    }
    
    // *text_285* updates
    if (t >= 4.0 && text_285.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_285.tStart = t;  // (not accounting for frame time here)
      text_285.frameNStart = frameN;  // exact frame index
      
      text_285.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_285.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_285.setAutoDraw(false);
    }
    
    // *key_resp_57* updates
    if (t >= 9.0 && key_resp_57.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_57.tStart = t;  // (not accounting for frame time here)
      key_resp_57.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_57.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_57.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_57.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_57.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_57.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_57.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_57.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_57_allKeys = _key_resp_57_allKeys.concat(theseKeys);
      if (_key_resp_57_allKeys.length > 0) {
        key_resp_57.keys = _key_resp_57_allKeys[_key_resp_57_allKeys.length - 1].name;  // just the last key pressed
        key_resp_57.rt = _key_resp_57_allKeys[_key_resp_57_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_57.keys == 'n') {
            key_resp_57.corr = 1;
        } else {
            key_resp_57.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    josojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function josojopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'josojopso' ---
    josojopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_57.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_57.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_57.corr = 1;  // correct non-response
      } else {
         key_resp_57.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_57.corr, level);
    }
    psychoJS.experiment.addData('key_resp_57.keys', key_resp_57.keys);
    psychoJS.experiment.addData('key_resp_57.corr', key_resp_57.corr);
    if (typeof key_resp_57.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_57.rt', key_resp_57.rt);
        routineTimer.reset();
        }
    
    key_resp_57.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_81_allKeys;
var so_jo_so_joComponents;
function so_jo_so_joRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'so_jo_so_jo' ---
    t = 0;
    so_jo_so_joClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_81.secs=3.5;
    sound_vowels_81.setVolume(1.0);
    key_resp_81.keys = undefined;
    key_resp_81.rt = undefined;
    _key_resp_81_allKeys = [];
    // keep track of which components have finished
    so_jo_so_joComponents = [];
    so_jo_so_joComponents.push(sound_vowels_81);
    so_jo_so_joComponents.push(text_401);
    so_jo_so_joComponents.push(text_402);
    so_jo_so_joComponents.push(text_403);
    so_jo_so_joComponents.push(text_404);
    so_jo_so_joComponents.push(text_405);
    so_jo_so_joComponents.push(key_resp_81);
    
    so_jo_so_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function so_jo_so_joRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'so_jo_so_jo' ---
    // get current time
    t = so_jo_so_joClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_81
    if (t >= 5 && sound_vowels_81.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_81.tStart = t;  // (not accounting for frame time here)
      sound_vowels_81.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_81.play(); });  // screen flip
      sound_vowels_81.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_81.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_81.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_81.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_401* updates
    if (t >= 0.0 && text_401.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_401.tStart = t;  // (not accounting for frame time here)
      text_401.frameNStart = frameN;  // exact frame index
      
      text_401.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_401.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_401.setAutoDraw(false);
    }
    
    // *text_402* updates
    if (t >= 9.0 && text_402.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_402.tStart = t;  // (not accounting for frame time here)
      text_402.frameNStart = frameN;  // exact frame index
      
      text_402.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_402.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_402.setAutoDraw(false);
    }
    
    // *text_403* updates
    if (t >= 2 && text_403.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_403.tStart = t;  // (not accounting for frame time here)
      text_403.frameNStart = frameN;  // exact frame index
      
      text_403.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_403.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_403.setAutoDraw(false);
    }
    
    // *text_404* updates
    if (t >= 3.0 && text_404.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_404.tStart = t;  // (not accounting for frame time here)
      text_404.frameNStart = frameN;  // exact frame index
      
      text_404.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_404.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_404.setAutoDraw(false);
    }
    
    // *text_405* updates
    if (t >= 4.0 && text_405.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_405.tStart = t;  // (not accounting for frame time here)
      text_405.frameNStart = frameN;  // exact frame index
      
      text_405.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_405.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_405.setAutoDraw(false);
    }
    
    // *key_resp_81* updates
    if (t >= 9.0 && key_resp_81.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_81.tStart = t;  // (not accounting for frame time here)
      key_resp_81.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_81.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_81.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_81.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_81.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_81.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_81.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_81.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_81_allKeys = _key_resp_81_allKeys.concat(theseKeys);
      if (_key_resp_81_allKeys.length > 0) {
        key_resp_81.keys = _key_resp_81_allKeys[_key_resp_81_allKeys.length - 1].name;  // just the last key pressed
        key_resp_81.rt = _key_resp_81_allKeys[_key_resp_81_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_81.keys == 'y') {
            key_resp_81.corr = 1;
        } else {
            key_resp_81.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    so_jo_so_joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function so_jo_so_joRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'so_jo_so_jo' ---
    so_jo_so_joComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_81.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_81.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_81.corr = 1;  // correct non-response
      } else {
         key_resp_81.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_81.corr, level);
    }
    psychoJS.experiment.addData('key_resp_81.keys', key_resp_81.keys);
    psychoJS.experiment.addData('key_resp_81.corr', key_resp_81.corr);
    if (typeof key_resp_81.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_81.rt', key_resp_81.rt);
        routineTimer.reset();
        }
    
    key_resp_81.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_61_allKeys;
var sa_sa_japjaComponents;
function sa_sa_japjaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_sa_japja' ---
    t = 0;
    sa_sa_japjaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_61.secs=3.5;
    sound_vowels_61.setVolume(1.0);
    key_resp_61.keys = undefined;
    key_resp_61.rt = undefined;
    _key_resp_61_allKeys = [];
    // keep track of which components have finished
    sa_sa_japjaComponents = [];
    sa_sa_japjaComponents.push(sound_vowels_61);
    sa_sa_japjaComponents.push(text_301);
    sa_sa_japjaComponents.push(text_302);
    sa_sa_japjaComponents.push(text_303);
    sa_sa_japjaComponents.push(text_304);
    sa_sa_japjaComponents.push(text_305);
    sa_sa_japjaComponents.push(key_resp_61);
    
    sa_sa_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_sa_japjaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_sa_japja' ---
    // get current time
    t = sa_sa_japjaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_61
    if (t >= 5 && sound_vowels_61.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_61.tStart = t;  // (not accounting for frame time here)
      sound_vowels_61.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_61.play(); });  // screen flip
      sound_vowels_61.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_61.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_61.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_61.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_301* updates
    if (t >= 0.0 && text_301.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_301.tStart = t;  // (not accounting for frame time here)
      text_301.frameNStart = frameN;  // exact frame index
      
      text_301.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_301.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_301.setAutoDraw(false);
    }
    
    // *text_302* updates
    if (t >= 9.0 && text_302.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_302.tStart = t;  // (not accounting for frame time here)
      text_302.frameNStart = frameN;  // exact frame index
      
      text_302.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_302.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_302.setAutoDraw(false);
    }
    
    // *text_303* updates
    if (t >= 2 && text_303.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_303.tStart = t;  // (not accounting for frame time here)
      text_303.frameNStart = frameN;  // exact frame index
      
      text_303.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_303.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_303.setAutoDraw(false);
    }
    
    // *text_304* updates
    if (t >= 3.0 && text_304.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_304.tStart = t;  // (not accounting for frame time here)
      text_304.frameNStart = frameN;  // exact frame index
      
      text_304.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_304.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_304.setAutoDraw(false);
    }
    
    // *text_305* updates
    if (t >= 4.0 && text_305.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_305.tStart = t;  // (not accounting for frame time here)
      text_305.frameNStart = frameN;  // exact frame index
      
      text_305.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_305.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_305.setAutoDraw(false);
    }
    
    // *key_resp_61* updates
    if (t >= 9.0 && key_resp_61.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_61.tStart = t;  // (not accounting for frame time here)
      key_resp_61.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_61.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_61.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_61.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_61.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_61.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_61.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_61.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_61_allKeys = _key_resp_61_allKeys.concat(theseKeys);
      if (_key_resp_61_allKeys.length > 0) {
        key_resp_61.keys = _key_resp_61_allKeys[_key_resp_61_allKeys.length - 1].name;  // just the last key pressed
        key_resp_61.rt = _key_resp_61_allKeys[_key_resp_61_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_61.keys == 'n') {
            key_resp_61.corr = 1;
        } else {
            key_resp_61.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_sa_japjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_sa_japjaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_sa_japja' ---
    sa_sa_japjaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_61.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_61.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_61.corr = 1;  // correct non-response
      } else {
         key_resp_61.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_61.corr, level);
    }
    psychoJS.experiment.addData('key_resp_61.keys', key_resp_61.keys);
    psychoJS.experiment.addData('key_resp_61.corr', key_resp_61.corr);
    if (typeof key_resp_61.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_61.rt', key_resp_61.rt);
        routineTimer.reset();
        }
    
    key_resp_61.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_52_allKeys;
var sojojopsoComponents;
function sojojopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sojojopso' ---
    t = 0;
    sojojopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_52.secs=3.5;
    sound_vowels_52.setVolume(1.0);
    key_resp_52.keys = undefined;
    key_resp_52.rt = undefined;
    _key_resp_52_allKeys = [];
    // keep track of which components have finished
    sojojopsoComponents = [];
    sojojopsoComponents.push(sound_vowels_52);
    sojojopsoComponents.push(text_256);
    sojojopsoComponents.push(text_257);
    sojojopsoComponents.push(text_258);
    sojojopsoComponents.push(text_259);
    sojojopsoComponents.push(text_260);
    sojojopsoComponents.push(key_resp_52);
    
    sojojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sojojopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sojojopso' ---
    // get current time
    t = sojojopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_52
    if (t >= 5 && sound_vowels_52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_52.tStart = t;  // (not accounting for frame time here)
      sound_vowels_52.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_52.play(); });  // screen flip
      sound_vowels_52.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_52.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_52.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_52.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_256* updates
    if (t >= 0.0 && text_256.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_256.tStart = t;  // (not accounting for frame time here)
      text_256.frameNStart = frameN;  // exact frame index
      
      text_256.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_256.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_256.setAutoDraw(false);
    }
    
    // *text_257* updates
    if (t >= 9.0 && text_257.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_257.tStart = t;  // (not accounting for frame time here)
      text_257.frameNStart = frameN;  // exact frame index
      
      text_257.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_257.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_257.setAutoDraw(false);
    }
    
    // *text_258* updates
    if (t >= 2 && text_258.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_258.tStart = t;  // (not accounting for frame time here)
      text_258.frameNStart = frameN;  // exact frame index
      
      text_258.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_258.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_258.setAutoDraw(false);
    }
    
    // *text_259* updates
    if (t >= 3.0 && text_259.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_259.tStart = t;  // (not accounting for frame time here)
      text_259.frameNStart = frameN;  // exact frame index
      
      text_259.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_259.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_259.setAutoDraw(false);
    }
    
    // *text_260* updates
    if (t >= 4.0 && text_260.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_260.tStart = t;  // (not accounting for frame time here)
      text_260.frameNStart = frameN;  // exact frame index
      
      text_260.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_260.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_260.setAutoDraw(false);
    }
    
    // *key_resp_52* updates
    if (t >= 9.0 && key_resp_52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_52.tStart = t;  // (not accounting for frame time here)
      key_resp_52.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_52.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_52.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_52.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_52.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_52.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_52.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_52.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_52_allKeys = _key_resp_52_allKeys.concat(theseKeys);
      if (_key_resp_52_allKeys.length > 0) {
        key_resp_52.keys = _key_resp_52_allKeys[_key_resp_52_allKeys.length - 1].name;  // just the last key pressed
        key_resp_52.rt = _key_resp_52_allKeys[_key_resp_52_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_52.keys == 'n') {
            key_resp_52.corr = 1;
        } else {
            key_resp_52.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sojojopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sojojopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sojojopso' ---
    sojojopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_52.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_52.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_52.corr = 1;  // correct non-response
      } else {
         key_resp_52.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_52.corr, level);
    }
    psychoJS.experiment.addData('key_resp_52.keys', key_resp_52.keys);
    psychoJS.experiment.addData('key_resp_52.corr', key_resp_52.corr);
    if (typeof key_resp_52.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_52.rt', key_resp_52.rt);
        routineTimer.reset();
        }
    
    key_resp_52.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_43_allKeys;
var jojoApAComponents;
function jojoApARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jojoApA' ---
    t = 0;
    jojoApAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_43.secs=3.5;
    sound_vowels_43.setVolume(1.0);
    key_resp_43.keys = undefined;
    key_resp_43.rt = undefined;
    _key_resp_43_allKeys = [];
    // keep track of which components have finished
    jojoApAComponents = [];
    jojoApAComponents.push(sound_vowels_43);
    jojoApAComponents.push(text_211);
    jojoApAComponents.push(text_212);
    jojoApAComponents.push(text_213);
    jojoApAComponents.push(text_214);
    jojoApAComponents.push(text_215);
    jojoApAComponents.push(key_resp_43);
    
    jojoApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jojoApARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jojoApA' ---
    // get current time
    t = jojoApAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_43
    if (t >= 5 && sound_vowels_43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_43.tStart = t;  // (not accounting for frame time here)
      sound_vowels_43.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_43.play(); });  // screen flip
      sound_vowels_43.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_43.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_43.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_43.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_211* updates
    if (t >= 0.0 && text_211.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_211.tStart = t;  // (not accounting for frame time here)
      text_211.frameNStart = frameN;  // exact frame index
      
      text_211.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_211.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_211.setAutoDraw(false);
    }
    
    // *text_212* updates
    if (t >= 9.0 && text_212.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_212.tStart = t;  // (not accounting for frame time here)
      text_212.frameNStart = frameN;  // exact frame index
      
      text_212.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_212.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_212.setAutoDraw(false);
    }
    
    // *text_213* updates
    if (t >= 2 && text_213.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_213.tStart = t;  // (not accounting for frame time here)
      text_213.frameNStart = frameN;  // exact frame index
      
      text_213.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_213.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_213.setAutoDraw(false);
    }
    
    // *text_214* updates
    if (t >= 3.0 && text_214.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_214.tStart = t;  // (not accounting for frame time here)
      text_214.frameNStart = frameN;  // exact frame index
      
      text_214.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_214.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_214.setAutoDraw(false);
    }
    
    // *text_215* updates
    if (t >= 4.0 && text_215.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_215.tStart = t;  // (not accounting for frame time here)
      text_215.frameNStart = frameN;  // exact frame index
      
      text_215.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_215.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_215.setAutoDraw(false);
    }
    
    // *key_resp_43* updates
    if (t >= 9.0 && key_resp_43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_43.tStart = t;  // (not accounting for frame time here)
      key_resp_43.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_43.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_43.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_43.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_43.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_43.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_43.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_43.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_43_allKeys = _key_resp_43_allKeys.concat(theseKeys);
      if (_key_resp_43_allKeys.length > 0) {
        key_resp_43.keys = _key_resp_43_allKeys[_key_resp_43_allKeys.length - 1].name;  // just the last key pressed
        key_resp_43.rt = _key_resp_43_allKeys[_key_resp_43_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_43.keys == 'n') {
            key_resp_43.corr = 1;
        } else {
            key_resp_43.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jojoApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jojoApARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jojoApA' ---
    jojoApAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_43.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_43.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_43.corr = 1;  // correct non-response
      } else {
         key_resp_43.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_43.corr, level);
    }
    psychoJS.experiment.addData('key_resp_43.keys', key_resp_43.keys);
    psychoJS.experiment.addData('key_resp_43.corr', key_resp_43.corr);
    if (typeof key_resp_43.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_43.rt', key_resp_43.rt);
        routineTimer.reset();
        }
    
    key_resp_43.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_82_allKeys;
var so_jo_soComponents;
function so_jo_soRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'so_jo_so' ---
    t = 0;
    so_jo_soClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_82.secs=3.5;
    sound_vowels_82.setVolume(1.0);
    key_resp_82.keys = undefined;
    key_resp_82.rt = undefined;
    _key_resp_82_allKeys = [];
    // keep track of which components have finished
    so_jo_soComponents = [];
    so_jo_soComponents.push(sound_vowels_82);
    so_jo_soComponents.push(text_406);
    so_jo_soComponents.push(text_407);
    so_jo_soComponents.push(text_408);
    so_jo_soComponents.push(text_409);
    so_jo_soComponents.push(text_410);
    so_jo_soComponents.push(key_resp_82);
    
    so_jo_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function so_jo_soRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'so_jo_so' ---
    // get current time
    t = so_jo_soClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_82
    if (t >= 5 && sound_vowels_82.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_82.tStart = t;  // (not accounting for frame time here)
      sound_vowels_82.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_82.play(); });  // screen flip
      sound_vowels_82.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_82.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_82.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_82.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_406* updates
    if (t >= 0.0 && text_406.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_406.tStart = t;  // (not accounting for frame time here)
      text_406.frameNStart = frameN;  // exact frame index
      
      text_406.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_406.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_406.setAutoDraw(false);
    }
    
    // *text_407* updates
    if (t >= 9.0 && text_407.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_407.tStart = t;  // (not accounting for frame time here)
      text_407.frameNStart = frameN;  // exact frame index
      
      text_407.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_407.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_407.setAutoDraw(false);
    }
    
    // *text_408* updates
    if (t >= 2 && text_408.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_408.tStart = t;  // (not accounting for frame time here)
      text_408.frameNStart = frameN;  // exact frame index
      
      text_408.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_408.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_408.setAutoDraw(false);
    }
    
    // *text_409* updates
    if (t >= 3.0 && text_409.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_409.tStart = t;  // (not accounting for frame time here)
      text_409.frameNStart = frameN;  // exact frame index
      
      text_409.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_409.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_409.setAutoDraw(false);
    }
    
    // *text_410* updates
    if (t >= 4.0 && text_410.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_410.tStart = t;  // (not accounting for frame time here)
      text_410.frameNStart = frameN;  // exact frame index
      
      text_410.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_410.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_410.setAutoDraw(false);
    }
    
    // *key_resp_82* updates
    if (t >= 9.0 && key_resp_82.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_82.tStart = t;  // (not accounting for frame time here)
      key_resp_82.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_82.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_82.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_82.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_82.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_82.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_82.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_82.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_82_allKeys = _key_resp_82_allKeys.concat(theseKeys);
      if (_key_resp_82_allKeys.length > 0) {
        key_resp_82.keys = _key_resp_82_allKeys[_key_resp_82_allKeys.length - 1].name;  // just the last key pressed
        key_resp_82.rt = _key_resp_82_allKeys[_key_resp_82_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_82.keys == 'y') {
            key_resp_82.corr = 1;
        } else {
            key_resp_82.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    so_jo_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function so_jo_soRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'so_jo_so' ---
    so_jo_soComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_82.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_82.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_82.corr = 1;  // correct non-response
      } else {
         key_resp_82.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_82.corr, level);
    }
    psychoJS.experiment.addData('key_resp_82.keys', key_resp_82.keys);
    psychoJS.experiment.addData('key_resp_82.corr', key_resp_82.corr);
    if (typeof key_resp_82.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_82.rt', key_resp_82.rt);
        routineTimer.reset();
        }
    
    key_resp_82.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_38_allKeys;
var joAApAComponents;
function joAApARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'joAApA' ---
    t = 0;
    joAApAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_38.secs=3.5;
    sound_vowels_38.setVolume(1.0);
    key_resp_38.keys = undefined;
    key_resp_38.rt = undefined;
    _key_resp_38_allKeys = [];
    // keep track of which components have finished
    joAApAComponents = [];
    joAApAComponents.push(sound_vowels_38);
    joAApAComponents.push(text_186);
    joAApAComponents.push(text_187);
    joAApAComponents.push(text_188);
    joAApAComponents.push(text_189);
    joAApAComponents.push(text_190);
    joAApAComponents.push(key_resp_38);
    
    joAApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function joAApARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'joAApA' ---
    // get current time
    t = joAApAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_38
    if (t >= 5 && sound_vowels_38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_38.tStart = t;  // (not accounting for frame time here)
      sound_vowels_38.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_38.play(); });  // screen flip
      sound_vowels_38.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_38.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_38.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_38.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_186* updates
    if (t >= 0.0 && text_186.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_186.tStart = t;  // (not accounting for frame time here)
      text_186.frameNStart = frameN;  // exact frame index
      
      text_186.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_186.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_186.setAutoDraw(false);
    }
    
    // *text_187* updates
    if (t >= 9.0 && text_187.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_187.tStart = t;  // (not accounting for frame time here)
      text_187.frameNStart = frameN;  // exact frame index
      
      text_187.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_187.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_187.setAutoDraw(false);
    }
    
    // *text_188* updates
    if (t >= 2 && text_188.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_188.tStart = t;  // (not accounting for frame time here)
      text_188.frameNStart = frameN;  // exact frame index
      
      text_188.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_188.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_188.setAutoDraw(false);
    }
    
    // *text_189* updates
    if (t >= 3.0 && text_189.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_189.tStart = t;  // (not accounting for frame time here)
      text_189.frameNStart = frameN;  // exact frame index
      
      text_189.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_189.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_189.setAutoDraw(false);
    }
    
    // *text_190* updates
    if (t >= 4.0 && text_190.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_190.tStart = t;  // (not accounting for frame time here)
      text_190.frameNStart = frameN;  // exact frame index
      
      text_190.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_190.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_190.setAutoDraw(false);
    }
    
    // *key_resp_38* updates
    if (t >= 9.0 && key_resp_38.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_38.tStart = t;  // (not accounting for frame time here)
      key_resp_38.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_38.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_38.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_38.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_38.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_38.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_38.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_38.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_38_allKeys = _key_resp_38_allKeys.concat(theseKeys);
      if (_key_resp_38_allKeys.length > 0) {
        key_resp_38.keys = _key_resp_38_allKeys[_key_resp_38_allKeys.length - 1].name;  // just the last key pressed
        key_resp_38.rt = _key_resp_38_allKeys[_key_resp_38_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_38.keys == 'n') {
            key_resp_38.corr = 1;
        } else {
            key_resp_38.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    joAApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function joAApARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'joAApA' ---
    joAApAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_38.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_38.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_38.corr = 1;  // correct non-response
      } else {
         key_resp_38.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_38.corr, level);
    }
    psychoJS.experiment.addData('key_resp_38.keys', key_resp_38.keys);
    psychoJS.experiment.addData('key_resp_38.corr', key_resp_38.corr);
    if (typeof key_resp_38.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_38.rt', key_resp_38.rt);
        routineTimer.reset();
        }
    
    key_resp_38.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_55_allKeys;
var sojosopsoComponents;
function sojosopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sojosopso' ---
    t = 0;
    sojosopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_55.secs=3.5;
    sound_vowels_55.setVolume(1.0);
    key_resp_55.keys = undefined;
    key_resp_55.rt = undefined;
    _key_resp_55_allKeys = [];
    // keep track of which components have finished
    sojosopsoComponents = [];
    sojosopsoComponents.push(sound_vowels_55);
    sojosopsoComponents.push(text_271);
    sojosopsoComponents.push(text_272);
    sojosopsoComponents.push(text_273);
    sojosopsoComponents.push(text_274);
    sojosopsoComponents.push(text_275);
    sojosopsoComponents.push(key_resp_55);
    
    sojosopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sojosopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sojosopso' ---
    // get current time
    t = sojosopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_55
    if (t >= 5 && sound_vowels_55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_55.tStart = t;  // (not accounting for frame time here)
      sound_vowels_55.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_55.play(); });  // screen flip
      sound_vowels_55.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_55.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_55.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_55.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_271* updates
    if (t >= 0.0 && text_271.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_271.tStart = t;  // (not accounting for frame time here)
      text_271.frameNStart = frameN;  // exact frame index
      
      text_271.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_271.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_271.setAutoDraw(false);
    }
    
    // *text_272* updates
    if (t >= 9.0 && text_272.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_272.tStart = t;  // (not accounting for frame time here)
      text_272.frameNStart = frameN;  // exact frame index
      
      text_272.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_272.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_272.setAutoDraw(false);
    }
    
    // *text_273* updates
    if (t >= 2 && text_273.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_273.tStart = t;  // (not accounting for frame time here)
      text_273.frameNStart = frameN;  // exact frame index
      
      text_273.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_273.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_273.setAutoDraw(false);
    }
    
    // *text_274* updates
    if (t >= 3.0 && text_274.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_274.tStart = t;  // (not accounting for frame time here)
      text_274.frameNStart = frameN;  // exact frame index
      
      text_274.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_274.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_274.setAutoDraw(false);
    }
    
    // *text_275* updates
    if (t >= 4.0 && text_275.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_275.tStart = t;  // (not accounting for frame time here)
      text_275.frameNStart = frameN;  // exact frame index
      
      text_275.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_275.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_275.setAutoDraw(false);
    }
    
    // *key_resp_55* updates
    if (t >= 9.0 && key_resp_55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_55.tStart = t;  // (not accounting for frame time here)
      key_resp_55.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_55.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_55.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_55.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_55.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_55.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_55.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_55.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_55_allKeys = _key_resp_55_allKeys.concat(theseKeys);
      if (_key_resp_55_allKeys.length > 0) {
        key_resp_55.keys = _key_resp_55_allKeys[_key_resp_55_allKeys.length - 1].name;  // just the last key pressed
        key_resp_55.rt = _key_resp_55_allKeys[_key_resp_55_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_55.keys == 'n') {
            key_resp_55.corr = 1;
        } else {
            key_resp_55.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sojosopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sojosopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sojosopso' ---
    sojosopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_55.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_55.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_55.corr = 1;  // correct non-response
      } else {
         key_resp_55.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_55.corr, level);
    }
    psychoJS.experiment.addData('key_resp_55.keys', key_resp_55.keys);
    psychoJS.experiment.addData('key_resp_55.corr', key_resp_55.corr);
    if (typeof key_resp_55.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_55.rt', key_resp_55.rt);
        routineTimer.reset();
        }
    
    key_resp_55.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_33_allKeys;
var usaComponents;
function usaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'usa' ---
    t = 0;
    usaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_33.secs=3.5;
    sound_vowels_33.setVolume(1.0);
    key_resp_33.keys = undefined;
    key_resp_33.rt = undefined;
    _key_resp_33_allKeys = [];
    // keep track of which components have finished
    usaComponents = [];
    usaComponents.push(sound_vowels_33);
    usaComponents.push(text_161);
    usaComponents.push(text_162);
    usaComponents.push(text_163);
    usaComponents.push(text_164);
    usaComponents.push(text_165);
    usaComponents.push(key_resp_33);
    
    usaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function usaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'usa' ---
    // get current time
    t = usaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_33
    if (t >= 5 && sound_vowels_33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_33.tStart = t;  // (not accounting for frame time here)
      sound_vowels_33.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_33.play(); });  // screen flip
      sound_vowels_33.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_33.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_33.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_33.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_161* updates
    if (t >= 0.0 && text_161.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_161.tStart = t;  // (not accounting for frame time here)
      text_161.frameNStart = frameN;  // exact frame index
      
      text_161.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_161.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_161.setAutoDraw(false);
    }
    
    // *text_162* updates
    if (t >= 9.0 && text_162.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_162.tStart = t;  // (not accounting for frame time here)
      text_162.frameNStart = frameN;  // exact frame index
      
      text_162.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_162.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_162.setAutoDraw(false);
    }
    
    // *text_163* updates
    if (t >= 2 && text_163.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_163.tStart = t;  // (not accounting for frame time here)
      text_163.frameNStart = frameN;  // exact frame index
      
      text_163.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_163.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_163.setAutoDraw(false);
    }
    
    // *text_164* updates
    if (t >= 3.0 && text_164.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_164.tStart = t;  // (not accounting for frame time here)
      text_164.frameNStart = frameN;  // exact frame index
      
      text_164.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_164.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_164.setAutoDraw(false);
    }
    
    // *text_165* updates
    if (t >= 4.0 && text_165.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_165.tStart = t;  // (not accounting for frame time here)
      text_165.frameNStart = frameN;  // exact frame index
      
      text_165.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_165.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_165.setAutoDraw(false);
    }
    
    // *key_resp_33* updates
    if (t >= 9.0 && key_resp_33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_33.tStart = t;  // (not accounting for frame time here)
      key_resp_33.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_33.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_33.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_33.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_33.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_33.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_33.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_33.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_33_allKeys = _key_resp_33_allKeys.concat(theseKeys);
      if (_key_resp_33_allKeys.length > 0) {
        key_resp_33.keys = _key_resp_33_allKeys[_key_resp_33_allKeys.length - 1].name;  // just the last key pressed
        key_resp_33.rt = _key_resp_33_allKeys[_key_resp_33_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_33.keys == 'n') {
            key_resp_33.corr = 1;
        } else {
            key_resp_33.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    usaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function usaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'usa' ---
    usaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_33.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_33.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_33.corr = 1;  // correct non-response
      } else {
         key_resp_33.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_33.corr, level);
    }
    psychoJS.experiment.addData('key_resp_33.keys', key_resp_33.keys);
    psychoJS.experiment.addData('key_resp_33.corr', key_resp_33.corr);
    if (typeof key_resp_33.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_33.rt', key_resp_33.rt);
        routineTimer.reset();
        }
    
    key_resp_33.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_36_allKeys;
var sojaComponents;
function sojaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'soja' ---
    t = 0;
    sojaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_36.secs=3.5;
    sound_vowels_36.setVolume(1.0);
    key_resp_36.keys = undefined;
    key_resp_36.rt = undefined;
    _key_resp_36_allKeys = [];
    // keep track of which components have finished
    sojaComponents = [];
    sojaComponents.push(sound_vowels_36);
    sojaComponents.push(text_176);
    sojaComponents.push(text_177);
    sojaComponents.push(text_178);
    sojaComponents.push(text_179);
    sojaComponents.push(text_180);
    sojaComponents.push(key_resp_36);
    
    sojaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sojaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'soja' ---
    // get current time
    t = sojaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_36
    if (t >= 5 && sound_vowels_36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_36.tStart = t;  // (not accounting for frame time here)
      sound_vowels_36.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_36.play(); });  // screen flip
      sound_vowels_36.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_36.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_36.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_36.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_176* updates
    if (t >= 0.0 && text_176.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_176.tStart = t;  // (not accounting for frame time here)
      text_176.frameNStart = frameN;  // exact frame index
      
      text_176.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_176.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_176.setAutoDraw(false);
    }
    
    // *text_177* updates
    if (t >= 9.0 && text_177.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_177.tStart = t;  // (not accounting for frame time here)
      text_177.frameNStart = frameN;  // exact frame index
      
      text_177.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_177.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_177.setAutoDraw(false);
    }
    
    // *text_178* updates
    if (t >= 2 && text_178.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_178.tStart = t;  // (not accounting for frame time here)
      text_178.frameNStart = frameN;  // exact frame index
      
      text_178.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_178.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_178.setAutoDraw(false);
    }
    
    // *text_179* updates
    if (t >= 3.0 && text_179.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_179.tStart = t;  // (not accounting for frame time here)
      text_179.frameNStart = frameN;  // exact frame index
      
      text_179.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_179.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_179.setAutoDraw(false);
    }
    
    // *text_180* updates
    if (t >= 4.0 && text_180.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_180.tStart = t;  // (not accounting for frame time here)
      text_180.frameNStart = frameN;  // exact frame index
      
      text_180.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_180.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_180.setAutoDraw(false);
    }
    
    // *key_resp_36* updates
    if (t >= 9.0 && key_resp_36.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_36.tStart = t;  // (not accounting for frame time here)
      key_resp_36.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_36.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_36.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_36.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_36.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_36.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_36.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_36.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_36_allKeys = _key_resp_36_allKeys.concat(theseKeys);
      if (_key_resp_36_allKeys.length > 0) {
        key_resp_36.keys = _key_resp_36_allKeys[_key_resp_36_allKeys.length - 1].name;  // just the last key pressed
        key_resp_36.rt = _key_resp_36_allKeys[_key_resp_36_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_36.keys == 'n') {
            key_resp_36.corr = 1;
        } else {
            key_resp_36.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sojaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sojaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'soja' ---
    sojaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_36.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_36.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_36.corr = 1;  // correct non-response
      } else {
         key_resp_36.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_36.corr, level);
    }
    psychoJS.experiment.addData('key_resp_36.keys', key_resp_36.keys);
    psychoJS.experiment.addData('key_resp_36.corr', key_resp_36.corr);
    if (typeof key_resp_36.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_36.rt', key_resp_36.rt);
        routineTimer.reset();
        }
    
    key_resp_36.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_24_allKeys;
var AsaAsapsaComponents;
function AsaAsapsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AsaAsapsa' ---
    t = 0;
    AsaAsapsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_24.secs=3.5;
    sound_vowels_24.setVolume(1.0);
    key_resp_24.keys = undefined;
    key_resp_24.rt = undefined;
    _key_resp_24_allKeys = [];
    // keep track of which components have finished
    AsaAsapsaComponents = [];
    AsaAsapsaComponents.push(sound_vowels_24);
    AsaAsapsaComponents.push(text_116);
    AsaAsapsaComponents.push(text_117);
    AsaAsapsaComponents.push(text_118);
    AsaAsapsaComponents.push(text_119);
    AsaAsapsaComponents.push(text_120);
    AsaAsapsaComponents.push(key_resp_24);
    
    AsaAsapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AsaAsapsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AsaAsapsa' ---
    // get current time
    t = AsaAsapsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_24
    if (t >= 5 && sound_vowels_24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_24.tStart = t;  // (not accounting for frame time here)
      sound_vowels_24.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_24.play(); });  // screen flip
      sound_vowels_24.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_24.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_24.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_24.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_116* updates
    if (t >= 0.0 && text_116.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_116.tStart = t;  // (not accounting for frame time here)
      text_116.frameNStart = frameN;  // exact frame index
      
      text_116.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_116.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_116.setAutoDraw(false);
    }
    
    // *text_117* updates
    if (t >= 9.0 && text_117.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_117.tStart = t;  // (not accounting for frame time here)
      text_117.frameNStart = frameN;  // exact frame index
      
      text_117.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_117.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_117.setAutoDraw(false);
    }
    
    // *text_118* updates
    if (t >= 2 && text_118.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_118.tStart = t;  // (not accounting for frame time here)
      text_118.frameNStart = frameN;  // exact frame index
      
      text_118.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_118.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_118.setAutoDraw(false);
    }
    
    // *text_119* updates
    if (t >= 3.0 && text_119.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_119.tStart = t;  // (not accounting for frame time here)
      text_119.frameNStart = frameN;  // exact frame index
      
      text_119.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_119.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_119.setAutoDraw(false);
    }
    
    // *text_120* updates
    if (t >= 4.0 && text_120.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_120.tStart = t;  // (not accounting for frame time here)
      text_120.frameNStart = frameN;  // exact frame index
      
      text_120.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_120.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_120.setAutoDraw(false);
    }
    
    // *key_resp_24* updates
    if (t >= 9.0 && key_resp_24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_24.tStart = t;  // (not accounting for frame time here)
      key_resp_24.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_24.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_24.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_24.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_24.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_24.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_24.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_24.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_24_allKeys = _key_resp_24_allKeys.concat(theseKeys);
      if (_key_resp_24_allKeys.length > 0) {
        key_resp_24.keys = _key_resp_24_allKeys[_key_resp_24_allKeys.length - 1].name;  // just the last key pressed
        key_resp_24.rt = _key_resp_24_allKeys[_key_resp_24_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_24.keys == 'n') {
            key_resp_24.corr = 1;
        } else {
            key_resp_24.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AsaAsapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AsaAsapsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AsaAsapsa' ---
    AsaAsapsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_24.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_24.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_24.corr = 1;  // correct non-response
      } else {
         key_resp_24.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_24.corr, level);
    }
    psychoJS.experiment.addData('key_resp_24.keys', key_resp_24.keys);
    psychoJS.experiment.addData('key_resp_24.corr', key_resp_24.corr);
    if (typeof key_resp_24.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_24.rt', key_resp_24.rt);
        routineTimer.reset();
        }
    
    key_resp_24.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_34_allKeys;
var ujaComponents;
function ujaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'uja' ---
    t = 0;
    ujaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_34.secs=3.5;
    sound_vowels_34.setVolume(1.0);
    key_resp_34.keys = undefined;
    key_resp_34.rt = undefined;
    _key_resp_34_allKeys = [];
    // keep track of which components have finished
    ujaComponents = [];
    ujaComponents.push(sound_vowels_34);
    ujaComponents.push(text_166);
    ujaComponents.push(text_167);
    ujaComponents.push(text_168);
    ujaComponents.push(text_169);
    ujaComponents.push(text_170);
    ujaComponents.push(key_resp_34);
    
    ujaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function ujaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'uja' ---
    // get current time
    t = ujaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_34
    if (t >= 5 && sound_vowels_34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_34.tStart = t;  // (not accounting for frame time here)
      sound_vowels_34.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_34.play(); });  // screen flip
      sound_vowels_34.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_34.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_34.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_34.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_166* updates
    if (t >= 0.0 && text_166.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_166.tStart = t;  // (not accounting for frame time here)
      text_166.frameNStart = frameN;  // exact frame index
      
      text_166.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_166.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_166.setAutoDraw(false);
    }
    
    // *text_167* updates
    if (t >= 9.0 && text_167.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_167.tStart = t;  // (not accounting for frame time here)
      text_167.frameNStart = frameN;  // exact frame index
      
      text_167.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_167.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_167.setAutoDraw(false);
    }
    
    // *text_168* updates
    if (t >= 2 && text_168.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_168.tStart = t;  // (not accounting for frame time here)
      text_168.frameNStart = frameN;  // exact frame index
      
      text_168.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_168.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_168.setAutoDraw(false);
    }
    
    // *text_169* updates
    if (t >= 3.0 && text_169.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_169.tStart = t;  // (not accounting for frame time here)
      text_169.frameNStart = frameN;  // exact frame index
      
      text_169.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_169.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_169.setAutoDraw(false);
    }
    
    // *text_170* updates
    if (t >= 4.0 && text_170.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_170.tStart = t;  // (not accounting for frame time here)
      text_170.frameNStart = frameN;  // exact frame index
      
      text_170.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_170.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_170.setAutoDraw(false);
    }
    
    // *key_resp_34* updates
    if (t >= 9.0 && key_resp_34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_34.tStart = t;  // (not accounting for frame time here)
      key_resp_34.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_34.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_34.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_34.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_34.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_34.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_34.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_34.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_34_allKeys = _key_resp_34_allKeys.concat(theseKeys);
      if (_key_resp_34_allKeys.length > 0) {
        key_resp_34.keys = _key_resp_34_allKeys[_key_resp_34_allKeys.length - 1].name;  // just the last key pressed
        key_resp_34.rt = _key_resp_34_allKeys[_key_resp_34_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_34.keys == 'n') {
            key_resp_34.corr = 1;
        } else {
            key_resp_34.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    ujaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ujaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'uja' ---
    ujaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_34.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_34.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_34.corr = 1;  // correct non-response
      } else {
         key_resp_34.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_34.corr, level);
    }
    psychoJS.experiment.addData('key_resp_34.keys', key_resp_34.keys);
    psychoJS.experiment.addData('key_resp_34.corr', key_resp_34.corr);
    if (typeof key_resp_34.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_34.rt', key_resp_34.rt);
        routineTimer.reset();
        }
    
    key_resp_34.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_67_allKeys;
var sa_ja_sapsaComponents;
function sa_ja_sapsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_sapsa' ---
    t = 0;
    sa_ja_sapsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_67.secs=3.5;
    sound_vowels_67.setVolume(1.0);
    key_resp_67.keys = undefined;
    key_resp_67.rt = undefined;
    _key_resp_67_allKeys = [];
    // keep track of which components have finished
    sa_ja_sapsaComponents = [];
    sa_ja_sapsaComponents.push(sound_vowels_67);
    sa_ja_sapsaComponents.push(text_331);
    sa_ja_sapsaComponents.push(text_332);
    sa_ja_sapsaComponents.push(text_333);
    sa_ja_sapsaComponents.push(text_334);
    sa_ja_sapsaComponents.push(text_335);
    sa_ja_sapsaComponents.push(key_resp_67);
    
    sa_ja_sapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_sapsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_sapsa' ---
    // get current time
    t = sa_ja_sapsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_67
    if (t >= 5 && sound_vowels_67.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_67.tStart = t;  // (not accounting for frame time here)
      sound_vowels_67.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_67.play(); });  // screen flip
      sound_vowels_67.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_67.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_67.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_67.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_331* updates
    if (t >= 0.0 && text_331.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_331.tStart = t;  // (not accounting for frame time here)
      text_331.frameNStart = frameN;  // exact frame index
      
      text_331.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_331.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_331.setAutoDraw(false);
    }
    
    // *text_332* updates
    if (t >= 9.0 && text_332.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_332.tStart = t;  // (not accounting for frame time here)
      text_332.frameNStart = frameN;  // exact frame index
      
      text_332.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_332.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_332.setAutoDraw(false);
    }
    
    // *text_333* updates
    if (t >= 2 && text_333.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_333.tStart = t;  // (not accounting for frame time here)
      text_333.frameNStart = frameN;  // exact frame index
      
      text_333.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_333.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_333.setAutoDraw(false);
    }
    
    // *text_334* updates
    if (t >= 3.0 && text_334.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_334.tStart = t;  // (not accounting for frame time here)
      text_334.frameNStart = frameN;  // exact frame index
      
      text_334.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_334.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_334.setAutoDraw(false);
    }
    
    // *text_335* updates
    if (t >= 4.0 && text_335.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_335.tStart = t;  // (not accounting for frame time here)
      text_335.frameNStart = frameN;  // exact frame index
      
      text_335.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_335.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_335.setAutoDraw(false);
    }
    
    // *key_resp_67* updates
    if (t >= 9.0 && key_resp_67.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_67.tStart = t;  // (not accounting for frame time here)
      key_resp_67.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_67.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_67.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_67.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_67.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_67.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_67.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_67.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_67_allKeys = _key_resp_67_allKeys.concat(theseKeys);
      if (_key_resp_67_allKeys.length > 0) {
        key_resp_67.keys = _key_resp_67_allKeys[_key_resp_67_allKeys.length - 1].name;  // just the last key pressed
        key_resp_67.rt = _key_resp_67_allKeys[_key_resp_67_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_67.keys == 'n') {
            key_resp_67.corr = 1;
        } else {
            key_resp_67.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_sapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_sapsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_sapsa' ---
    sa_ja_sapsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_67.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_67.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_67.corr = 1;  // correct non-response
      } else {
         key_resp_67.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_67.corr, level);
    }
    psychoJS.experiment.addData('key_resp_67.keys', key_resp_67.keys);
    psychoJS.experiment.addData('key_resp_67.corr', key_resp_67.corr);
    if (typeof key_resp_67.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_67.rt', key_resp_67.rt);
        routineTimer.reset();
        }
    
    key_resp_67.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_31_allKeys;
var uComponents;
function uRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'u' ---
    t = 0;
    uClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_31.secs=3.5;
    sound_vowels_31.setVolume(1.0);
    key_resp_31.keys = undefined;
    key_resp_31.rt = undefined;
    _key_resp_31_allKeys = [];
    // keep track of which components have finished
    uComponents = [];
    uComponents.push(sound_vowels_31);
    uComponents.push(text_151);
    uComponents.push(text_152);
    uComponents.push(text_153);
    uComponents.push(text_154);
    uComponents.push(text_155);
    uComponents.push(key_resp_31);
    
    uComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function uRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'u' ---
    // get current time
    t = uClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_31
    if (t >= 5 && sound_vowels_31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_31.tStart = t;  // (not accounting for frame time here)
      sound_vowels_31.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_31.play(); });  // screen flip
      sound_vowels_31.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_31.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_31.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_31.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_151* updates
    if (t >= 0.0 && text_151.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_151.tStart = t;  // (not accounting for frame time here)
      text_151.frameNStart = frameN;  // exact frame index
      
      text_151.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_151.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_151.setAutoDraw(false);
    }
    
    // *text_152* updates
    if (t >= 9.0 && text_152.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_152.tStart = t;  // (not accounting for frame time here)
      text_152.frameNStart = frameN;  // exact frame index
      
      text_152.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_152.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_152.setAutoDraw(false);
    }
    
    // *text_153* updates
    if (t >= 2 && text_153.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_153.tStart = t;  // (not accounting for frame time here)
      text_153.frameNStart = frameN;  // exact frame index
      
      text_153.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_153.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_153.setAutoDraw(false);
    }
    
    // *text_154* updates
    if (t >= 3.0 && text_154.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_154.tStart = t;  // (not accounting for frame time here)
      text_154.frameNStart = frameN;  // exact frame index
      
      text_154.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_154.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_154.setAutoDraw(false);
    }
    
    // *text_155* updates
    if (t >= 4.0 && text_155.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_155.tStart = t;  // (not accounting for frame time here)
      text_155.frameNStart = frameN;  // exact frame index
      
      text_155.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_155.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_155.setAutoDraw(false);
    }
    
    // *key_resp_31* updates
    if (t >= 9.0 && key_resp_31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_31.tStart = t;  // (not accounting for frame time here)
      key_resp_31.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_31.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_31.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_31.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_31.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_31.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_31.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_31.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_31_allKeys = _key_resp_31_allKeys.concat(theseKeys);
      if (_key_resp_31_allKeys.length > 0) {
        key_resp_31.keys = _key_resp_31_allKeys[_key_resp_31_allKeys.length - 1].name;  // just the last key pressed
        key_resp_31.rt = _key_resp_31_allKeys[_key_resp_31_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_31.keys == 'y') {
            key_resp_31.corr = 1;
        } else {
            key_resp_31.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    uComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function uRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'u' ---
    uComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_31.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_31.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_31.corr = 1;  // correct non-response
      } else {
         key_resp_31.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_31.corr, level);
    }
    psychoJS.experiment.addData('key_resp_31.keys', key_resp_31.keys);
    psychoJS.experiment.addData('key_resp_31.corr', key_resp_31.corr);
    if (typeof key_resp_31.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_31.rt', key_resp_31.rt);
        routineTimer.reset();
        }
    
    key_resp_31.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_66_allKeys;
var sa_ja_sapjaComponents;
function sa_ja_sapjaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_sapja' ---
    t = 0;
    sa_ja_sapjaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_66.secs=3.5;
    sound_vowels_66.setVolume(1.0);
    key_resp_66.keys = undefined;
    key_resp_66.rt = undefined;
    _key_resp_66_allKeys = [];
    // keep track of which components have finished
    sa_ja_sapjaComponents = [];
    sa_ja_sapjaComponents.push(sound_vowels_66);
    sa_ja_sapjaComponents.push(text_326);
    sa_ja_sapjaComponents.push(text_327);
    sa_ja_sapjaComponents.push(text_328);
    sa_ja_sapjaComponents.push(text_329);
    sa_ja_sapjaComponents.push(text_330);
    sa_ja_sapjaComponents.push(key_resp_66);
    
    sa_ja_sapjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_sapjaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_sapja' ---
    // get current time
    t = sa_ja_sapjaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_66
    if (t >= 5 && sound_vowels_66.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_66.tStart = t;  // (not accounting for frame time here)
      sound_vowels_66.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_66.play(); });  // screen flip
      sound_vowels_66.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_66.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_66.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_66.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_326* updates
    if (t >= 0.0 && text_326.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_326.tStart = t;  // (not accounting for frame time here)
      text_326.frameNStart = frameN;  // exact frame index
      
      text_326.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_326.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_326.setAutoDraw(false);
    }
    
    // *text_327* updates
    if (t >= 9.0 && text_327.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_327.tStart = t;  // (not accounting for frame time here)
      text_327.frameNStart = frameN;  // exact frame index
      
      text_327.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_327.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_327.setAutoDraw(false);
    }
    
    // *text_328* updates
    if (t >= 2 && text_328.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_328.tStart = t;  // (not accounting for frame time here)
      text_328.frameNStart = frameN;  // exact frame index
      
      text_328.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_328.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_328.setAutoDraw(false);
    }
    
    // *text_329* updates
    if (t >= 3.0 && text_329.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_329.tStart = t;  // (not accounting for frame time here)
      text_329.frameNStart = frameN;  // exact frame index
      
      text_329.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_329.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_329.setAutoDraw(false);
    }
    
    // *text_330* updates
    if (t >= 4.0 && text_330.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_330.tStart = t;  // (not accounting for frame time here)
      text_330.frameNStart = frameN;  // exact frame index
      
      text_330.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_330.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_330.setAutoDraw(false);
    }
    
    // *key_resp_66* updates
    if (t >= 9.0 && key_resp_66.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_66.tStart = t;  // (not accounting for frame time here)
      key_resp_66.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_66.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_66.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_66.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_66.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_66.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_66.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_66.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_66_allKeys = _key_resp_66_allKeys.concat(theseKeys);
      if (_key_resp_66_allKeys.length > 0) {
        key_resp_66.keys = _key_resp_66_allKeys[_key_resp_66_allKeys.length - 1].name;  // just the last key pressed
        key_resp_66.rt = _key_resp_66_allKeys[_key_resp_66_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_66.keys == 'n') {
            key_resp_66.corr = 1;
        } else {
            key_resp_66.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_sapjaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_sapjaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_sapja' ---
    sa_ja_sapjaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_66.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_66.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_66.corr = 1;  // correct non-response
      } else {
         key_resp_66.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_66.corr, level);
    }
    psychoJS.experiment.addData('key_resp_66.keys', key_resp_66.keys);
    psychoJS.experiment.addData('key_resp_66.corr', key_resp_66.corr);
    if (typeof key_resp_66.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_66.rt', key_resp_66.rt);
        routineTimer.reset();
        }
    
    key_resp_66.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_32_allKeys;
var jopAComponents;
function jopARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jopA' ---
    t = 0;
    jopAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_32.secs=3.5;
    sound_vowels_32.setVolume(1.0);
    key_resp_32.keys = undefined;
    key_resp_32.rt = undefined;
    _key_resp_32_allKeys = [];
    // keep track of which components have finished
    jopAComponents = [];
    jopAComponents.push(sound_vowels_32);
    jopAComponents.push(text_156);
    jopAComponents.push(text_157);
    jopAComponents.push(text_158);
    jopAComponents.push(text_159);
    jopAComponents.push(text_160);
    jopAComponents.push(key_resp_32);
    
    jopAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jopARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jopA' ---
    // get current time
    t = jopAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_32
    if (t >= 5 && sound_vowels_32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_32.tStart = t;  // (not accounting for frame time here)
      sound_vowels_32.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_32.play(); });  // screen flip
      sound_vowels_32.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_32.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_32.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_32.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_156* updates
    if (t >= 0.0 && text_156.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_156.tStart = t;  // (not accounting for frame time here)
      text_156.frameNStart = frameN;  // exact frame index
      
      text_156.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_156.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_156.setAutoDraw(false);
    }
    
    // *text_157* updates
    if (t >= 9.0 && text_157.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_157.tStart = t;  // (not accounting for frame time here)
      text_157.frameNStart = frameN;  // exact frame index
      
      text_157.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_157.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_157.setAutoDraw(false);
    }
    
    // *text_158* updates
    if (t >= 2 && text_158.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_158.tStart = t;  // (not accounting for frame time here)
      text_158.frameNStart = frameN;  // exact frame index
      
      text_158.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_158.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_158.setAutoDraw(false);
    }
    
    // *text_159* updates
    if (t >= 3.0 && text_159.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_159.tStart = t;  // (not accounting for frame time here)
      text_159.frameNStart = frameN;  // exact frame index
      
      text_159.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_159.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_159.setAutoDraw(false);
    }
    
    // *text_160* updates
    if (t >= 4.0 && text_160.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_160.tStart = t;  // (not accounting for frame time here)
      text_160.frameNStart = frameN;  // exact frame index
      
      text_160.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_160.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_160.setAutoDraw(false);
    }
    
    // *key_resp_32* updates
    if (t >= 9.0 && key_resp_32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_32.tStart = t;  // (not accounting for frame time here)
      key_resp_32.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_32.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_32.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_32.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_32.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_32.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_32.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_32.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_32_allKeys = _key_resp_32_allKeys.concat(theseKeys);
      if (_key_resp_32_allKeys.length > 0) {
        key_resp_32.keys = _key_resp_32_allKeys[_key_resp_32_allKeys.length - 1].name;  // just the last key pressed
        key_resp_32.rt = _key_resp_32_allKeys[_key_resp_32_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_32.keys == 'n') {
            key_resp_32.corr = 1;
        } else {
            key_resp_32.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jopAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jopARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jopA' ---
    jopAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_32.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_32.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_32.corr = 1;  // correct non-response
      } else {
         key_resp_32.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_32.corr, level);
    }
    psychoJS.experiment.addData('key_resp_32.keys', key_resp_32.keys);
    psychoJS.experiment.addData('key_resp_32.corr', key_resp_32.corr);
    if (typeof key_resp_32.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_32.rt', key_resp_32.rt);
        routineTimer.reset();
        }
    
    key_resp_32.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_16_allKeys;
var usoupsoComponents;
function usoupsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'usoupso' ---
    t = 0;
    usoupsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_16.secs=3.5;
    sound_vowels_16.setVolume(1.0);
    key_resp_16.keys = undefined;
    key_resp_16.rt = undefined;
    _key_resp_16_allKeys = [];
    // keep track of which components have finished
    usoupsoComponents = [];
    usoupsoComponents.push(sound_vowels_16);
    usoupsoComponents.push(text_76);
    usoupsoComponents.push(text_77);
    usoupsoComponents.push(text_78);
    usoupsoComponents.push(text_79);
    usoupsoComponents.push(text_80);
    usoupsoComponents.push(key_resp_16);
    
    usoupsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function usoupsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'usoupso' ---
    // get current time
    t = usoupsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_16
    if (t >= 5 && sound_vowels_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_16.tStart = t;  // (not accounting for frame time here)
      sound_vowels_16.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_16.play(); });  // screen flip
      sound_vowels_16.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_16.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_16.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_16.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_76* updates
    if (t >= 0.0 && text_76.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_76.tStart = t;  // (not accounting for frame time here)
      text_76.frameNStart = frameN;  // exact frame index
      
      text_76.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_76.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_76.setAutoDraw(false);
    }
    
    // *text_77* updates
    if (t >= 9.0 && text_77.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_77.tStart = t;  // (not accounting for frame time here)
      text_77.frameNStart = frameN;  // exact frame index
      
      text_77.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_77.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_77.setAutoDraw(false);
    }
    
    // *text_78* updates
    if (t >= 2 && text_78.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_78.tStart = t;  // (not accounting for frame time here)
      text_78.frameNStart = frameN;  // exact frame index
      
      text_78.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_78.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_78.setAutoDraw(false);
    }
    
    // *text_79* updates
    if (t >= 3.0 && text_79.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_79.tStart = t;  // (not accounting for frame time here)
      text_79.frameNStart = frameN;  // exact frame index
      
      text_79.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_79.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_79.setAutoDraw(false);
    }
    
    // *text_80* updates
    if (t >= 4.0 && text_80.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_80.tStart = t;  // (not accounting for frame time here)
      text_80.frameNStart = frameN;  // exact frame index
      
      text_80.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_80.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_80.setAutoDraw(false);
    }
    
    // *key_resp_16* updates
    if (t >= 9.0 && key_resp_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_16.tStart = t;  // (not accounting for frame time here)
      key_resp_16.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_16.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_16.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_16.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_16.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_16.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_16.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_16.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_16_allKeys = _key_resp_16_allKeys.concat(theseKeys);
      if (_key_resp_16_allKeys.length > 0) {
        key_resp_16.keys = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].name;  // just the last key pressed
        key_resp_16.rt = _key_resp_16_allKeys[_key_resp_16_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_16.keys == 'n') {
            key_resp_16.corr = 1;
        } else {
            key_resp_16.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    usoupsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function usoupsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'usoupso' ---
    usoupsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_16.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_16.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_16.corr = 1;  // correct non-response
      } else {
         key_resp_16.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_16.corr, level);
    }
    psychoJS.experiment.addData('key_resp_16.keys', key_resp_16.keys);
    psychoJS.experiment.addData('key_resp_16.corr', key_resp_16.corr);
    if (typeof key_resp_16.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_16.rt', key_resp_16.rt);
        routineTimer.reset();
        }
    
    key_resp_16.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_56_allKeys;
var sosojopjoComponents;
function sosojopjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sosojopjo' ---
    t = 0;
    sosojopjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_56.secs=3.5;
    sound_vowels_56.setVolume(1.0);
    key_resp_56.keys = undefined;
    key_resp_56.rt = undefined;
    _key_resp_56_allKeys = [];
    // keep track of which components have finished
    sosojopjoComponents = [];
    sosojopjoComponents.push(sound_vowels_56);
    sosojopjoComponents.push(text_276);
    sosojopjoComponents.push(text_277);
    sosojopjoComponents.push(text_278);
    sosojopjoComponents.push(text_279);
    sosojopjoComponents.push(text_280);
    sosojopjoComponents.push(key_resp_56);
    
    sosojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sosojopjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sosojopjo' ---
    // get current time
    t = sosojopjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_56
    if (t >= 5 && sound_vowels_56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_56.tStart = t;  // (not accounting for frame time here)
      sound_vowels_56.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_56.play(); });  // screen flip
      sound_vowels_56.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_56.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_56.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_56.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_276* updates
    if (t >= 0.0 && text_276.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_276.tStart = t;  // (not accounting for frame time here)
      text_276.frameNStart = frameN;  // exact frame index
      
      text_276.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_276.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_276.setAutoDraw(false);
    }
    
    // *text_277* updates
    if (t >= 9.0 && text_277.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_277.tStart = t;  // (not accounting for frame time here)
      text_277.frameNStart = frameN;  // exact frame index
      
      text_277.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_277.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_277.setAutoDraw(false);
    }
    
    // *text_278* updates
    if (t >= 2 && text_278.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_278.tStart = t;  // (not accounting for frame time here)
      text_278.frameNStart = frameN;  // exact frame index
      
      text_278.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_278.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_278.setAutoDraw(false);
    }
    
    // *text_279* updates
    if (t >= 3.0 && text_279.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_279.tStart = t;  // (not accounting for frame time here)
      text_279.frameNStart = frameN;  // exact frame index
      
      text_279.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_279.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_279.setAutoDraw(false);
    }
    
    // *text_280* updates
    if (t >= 4.0 && text_280.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_280.tStart = t;  // (not accounting for frame time here)
      text_280.frameNStart = frameN;  // exact frame index
      
      text_280.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_280.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_280.setAutoDraw(false);
    }
    
    // *key_resp_56* updates
    if (t >= 9.0 && key_resp_56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_56.tStart = t;  // (not accounting for frame time here)
      key_resp_56.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_56.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_56.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_56.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_56.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_56.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_56.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_56.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_56_allKeys = _key_resp_56_allKeys.concat(theseKeys);
      if (_key_resp_56_allKeys.length > 0) {
        key_resp_56.keys = _key_resp_56_allKeys[_key_resp_56_allKeys.length - 1].name;  // just the last key pressed
        key_resp_56.rt = _key_resp_56_allKeys[_key_resp_56_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_56.keys == 'n') {
            key_resp_56.corr = 1;
        } else {
            key_resp_56.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sosojopjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sosojopjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sosojopjo' ---
    sosojopjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_56.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_56.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_56.corr = 1;  // correct non-response
      } else {
         key_resp_56.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_56.corr, level);
    }
    psychoJS.experiment.addData('key_resp_56.keys', key_resp_56.keys);
    psychoJS.experiment.addData('key_resp_56.corr', key_resp_56.corr);
    if (typeof key_resp_56.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_56.rt', key_resp_56.rt);
        routineTimer.reset();
        }
    
    key_resp_56.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_35_allKeys;
var sosaComponents;
function sosaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sosa' ---
    t = 0;
    sosaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_35.secs=3.5;
    sound_vowels_35.setVolume(1.0);
    key_resp_35.keys = undefined;
    key_resp_35.rt = undefined;
    _key_resp_35_allKeys = [];
    // keep track of which components have finished
    sosaComponents = [];
    sosaComponents.push(sound_vowels_35);
    sosaComponents.push(text_171);
    sosaComponents.push(text_172);
    sosaComponents.push(text_173);
    sosaComponents.push(text_174);
    sosaComponents.push(text_175);
    sosaComponents.push(key_resp_35);
    
    sosaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sosaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sosa' ---
    // get current time
    t = sosaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_35
    if (t >= 5 && sound_vowels_35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_35.tStart = t;  // (not accounting for frame time here)
      sound_vowels_35.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_35.play(); });  // screen flip
      sound_vowels_35.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_35.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_35.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_35.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_171* updates
    if (t >= 0.0 && text_171.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_171.tStart = t;  // (not accounting for frame time here)
      text_171.frameNStart = frameN;  // exact frame index
      
      text_171.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_171.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_171.setAutoDraw(false);
    }
    
    // *text_172* updates
    if (t >= 9.0 && text_172.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_172.tStart = t;  // (not accounting for frame time here)
      text_172.frameNStart = frameN;  // exact frame index
      
      text_172.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_172.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_172.setAutoDraw(false);
    }
    
    // *text_173* updates
    if (t >= 2 && text_173.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_173.tStart = t;  // (not accounting for frame time here)
      text_173.frameNStart = frameN;  // exact frame index
      
      text_173.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_173.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_173.setAutoDraw(false);
    }
    
    // *text_174* updates
    if (t >= 3.0 && text_174.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_174.tStart = t;  // (not accounting for frame time here)
      text_174.frameNStart = frameN;  // exact frame index
      
      text_174.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_174.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_174.setAutoDraw(false);
    }
    
    // *text_175* updates
    if (t >= 4.0 && text_175.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_175.tStart = t;  // (not accounting for frame time here)
      text_175.frameNStart = frameN;  // exact frame index
      
      text_175.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_175.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_175.setAutoDraw(false);
    }
    
    // *key_resp_35* updates
    if (t >= 9.0 && key_resp_35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_35.tStart = t;  // (not accounting for frame time here)
      key_resp_35.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_35.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_35.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_35.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_35.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_35.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_35.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_35.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_35_allKeys = _key_resp_35_allKeys.concat(theseKeys);
      if (_key_resp_35_allKeys.length > 0) {
        key_resp_35.keys = _key_resp_35_allKeys[_key_resp_35_allKeys.length - 1].name;  // just the last key pressed
        key_resp_35.rt = _key_resp_35_allKeys[_key_resp_35_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_35.keys == 'n') {
            key_resp_35.corr = 1;
        } else {
            key_resp_35.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sosaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sosaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sosa' ---
    sosaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_35.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_35.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_35.corr = 1;  // correct non-response
      } else {
         key_resp_35.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_35.corr, level);
    }
    psychoJS.experiment.addData('key_resp_35.keys', key_resp_35.keys);
    psychoJS.experiment.addData('key_resp_35.corr', key_resp_35.corr);
    if (typeof key_resp_35.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_35.rt', key_resp_35.rt);
        routineTimer.reset();
        }
    
    key_resp_35.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_9_allKeys;
var AComponents;
function ARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'A' ---
    t = 0;
    AClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_9.secs=3.5;
    sound_vowels_9.setVolume(1.0);
    key_resp_9.keys = undefined;
    key_resp_9.rt = undefined;
    _key_resp_9_allKeys = [];
    // keep track of which components have finished
    AComponents = [];
    AComponents.push(sound_vowels_9);
    AComponents.push(text_41);
    AComponents.push(text_42);
    AComponents.push(text_43);
    AComponents.push(text_44);
    AComponents.push(text_45);
    AComponents.push(key_resp_9);
    
    AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function ARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'A' ---
    // get current time
    t = AClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_9
    if (t >= 5 && sound_vowels_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_9.tStart = t;  // (not accounting for frame time here)
      sound_vowels_9.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_9.play(); });  // screen flip
      sound_vowels_9.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_9.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_9.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_41* updates
    if (t >= 0.0 && text_41.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_41.tStart = t;  // (not accounting for frame time here)
      text_41.frameNStart = frameN;  // exact frame index
      
      text_41.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_41.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_41.setAutoDraw(false);
    }
    
    // *text_42* updates
    if (t >= 9.0 && text_42.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_42.tStart = t;  // (not accounting for frame time here)
      text_42.frameNStart = frameN;  // exact frame index
      
      text_42.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_42.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_42.setAutoDraw(false);
    }
    
    // *text_43* updates
    if (t >= 2 && text_43.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_43.tStart = t;  // (not accounting for frame time here)
      text_43.frameNStart = frameN;  // exact frame index
      
      text_43.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_43.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_43.setAutoDraw(false);
    }
    
    // *text_44* updates
    if (t >= 3.0 && text_44.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_44.tStart = t;  // (not accounting for frame time here)
      text_44.frameNStart = frameN;  // exact frame index
      
      text_44.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_44.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_44.setAutoDraw(false);
    }
    
    // *text_45* updates
    if (t >= 4.0 && text_45.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_45.tStart = t;  // (not accounting for frame time here)
      text_45.frameNStart = frameN;  // exact frame index
      
      text_45.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_45.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_45.setAutoDraw(false);
    }
    
    // *key_resp_9* updates
    if (t >= 9.0 && key_resp_9.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_9.tStart = t;  // (not accounting for frame time here)
      key_resp_9.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_9.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_9.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_9.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_9.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_9.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_9.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_9.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_9_allKeys = _key_resp_9_allKeys.concat(theseKeys);
      if (_key_resp_9_allKeys.length > 0) {
        key_resp_9.keys = _key_resp_9_allKeys[_key_resp_9_allKeys.length - 1].name;  // just the last key pressed
        key_resp_9.rt = _key_resp_9_allKeys[_key_resp_9_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_9.keys == 'y') {
            key_resp_9.corr = 1;
        } else {
            key_resp_9.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'A' ---
    AComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_9.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_9.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_9.corr = 1;  // correct non-response
      } else {
         key_resp_9.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_9.corr, level);
    }
    psychoJS.experiment.addData('key_resp_9.keys', key_resp_9.keys);
    psychoJS.experiment.addData('key_resp_9.corr', key_resp_9.corr);
    if (typeof key_resp_9.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_9.rt', key_resp_9.rt);
        routineTimer.reset();
        }
    
    key_resp_9.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_63_allKeys;
var sa_ja_japsaComponents;
function sa_ja_japsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_japsa' ---
    t = 0;
    sa_ja_japsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_63.secs=3.5;
    sound_vowels_63.setVolume(1.0);
    key_resp_63.keys = undefined;
    key_resp_63.rt = undefined;
    _key_resp_63_allKeys = [];
    // keep track of which components have finished
    sa_ja_japsaComponents = [];
    sa_ja_japsaComponents.push(sound_vowels_63);
    sa_ja_japsaComponents.push(text_311);
    sa_ja_japsaComponents.push(text_312);
    sa_ja_japsaComponents.push(text_313);
    sa_ja_japsaComponents.push(text_314);
    sa_ja_japsaComponents.push(text_315);
    sa_ja_japsaComponents.push(key_resp_63);
    
    sa_ja_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_japsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_japsa' ---
    // get current time
    t = sa_ja_japsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_63
    if (t >= 5 && sound_vowels_63.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_63.tStart = t;  // (not accounting for frame time here)
      sound_vowels_63.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_63.play(); });  // screen flip
      sound_vowels_63.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_63.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_63.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_63.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_311* updates
    if (t >= 0.0 && text_311.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_311.tStart = t;  // (not accounting for frame time here)
      text_311.frameNStart = frameN;  // exact frame index
      
      text_311.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_311.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_311.setAutoDraw(false);
    }
    
    // *text_312* updates
    if (t >= 9.0 && text_312.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_312.tStart = t;  // (not accounting for frame time here)
      text_312.frameNStart = frameN;  // exact frame index
      
      text_312.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_312.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_312.setAutoDraw(false);
    }
    
    // *text_313* updates
    if (t >= 2 && text_313.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_313.tStart = t;  // (not accounting for frame time here)
      text_313.frameNStart = frameN;  // exact frame index
      
      text_313.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_313.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_313.setAutoDraw(false);
    }
    
    // *text_314* updates
    if (t >= 3.0 && text_314.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_314.tStart = t;  // (not accounting for frame time here)
      text_314.frameNStart = frameN;  // exact frame index
      
      text_314.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_314.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_314.setAutoDraw(false);
    }
    
    // *text_315* updates
    if (t >= 4.0 && text_315.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_315.tStart = t;  // (not accounting for frame time here)
      text_315.frameNStart = frameN;  // exact frame index
      
      text_315.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_315.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_315.setAutoDraw(false);
    }
    
    // *key_resp_63* updates
    if (t >= 9.0 && key_resp_63.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_63.tStart = t;  // (not accounting for frame time here)
      key_resp_63.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_63.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_63.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_63.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_63.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_63.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_63.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_63.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_63_allKeys = _key_resp_63_allKeys.concat(theseKeys);
      if (_key_resp_63_allKeys.length > 0) {
        key_resp_63.keys = _key_resp_63_allKeys[_key_resp_63_allKeys.length - 1].name;  // just the last key pressed
        key_resp_63.rt = _key_resp_63_allKeys[_key_resp_63_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_63.keys == 'n') {
            key_resp_63.corr = 1;
        } else {
            key_resp_63.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_japsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_japsa' ---
    sa_ja_japsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_63.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_63.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_63.corr = 1;  // correct non-response
      } else {
         key_resp_63.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_63.corr, level);
    }
    psychoJS.experiment.addData('key_resp_63.keys', key_resp_63.keys);
    psychoJS.experiment.addData('key_resp_63.corr', key_resp_63.corr);
    if (typeof key_resp_63.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_63.rt', key_resp_63.rt);
        routineTimer.reset();
        }
    
    key_resp_63.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_20_allKeys;
var ApsaComponents;
function ApsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'Apsa' ---
    t = 0;
    ApsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_20.secs=3.5;
    sound_vowels_20.setVolume(1.0);
    key_resp_20.keys = undefined;
    key_resp_20.rt = undefined;
    _key_resp_20_allKeys = [];
    // keep track of which components have finished
    ApsaComponents = [];
    ApsaComponents.push(sound_vowels_20);
    ApsaComponents.push(text_96);
    ApsaComponents.push(text_97);
    ApsaComponents.push(text_98);
    ApsaComponents.push(text_99);
    ApsaComponents.push(text_100);
    ApsaComponents.push(key_resp_20);
    
    ApsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function ApsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'Apsa' ---
    // get current time
    t = ApsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_20
    if (t >= 5 && sound_vowels_20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_20.tStart = t;  // (not accounting for frame time here)
      sound_vowels_20.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_20.play(); });  // screen flip
      sound_vowels_20.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_20.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_20.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_20.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_96* updates
    if (t >= 0.0 && text_96.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_96.tStart = t;  // (not accounting for frame time here)
      text_96.frameNStart = frameN;  // exact frame index
      
      text_96.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_96.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_96.setAutoDraw(false);
    }
    
    // *text_97* updates
    if (t >= 9.0 && text_97.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_97.tStart = t;  // (not accounting for frame time here)
      text_97.frameNStart = frameN;  // exact frame index
      
      text_97.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_97.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_97.setAutoDraw(false);
    }
    
    // *text_98* updates
    if (t >= 2 && text_98.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_98.tStart = t;  // (not accounting for frame time here)
      text_98.frameNStart = frameN;  // exact frame index
      
      text_98.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_98.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_98.setAutoDraw(false);
    }
    
    // *text_99* updates
    if (t >= 3.0 && text_99.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_99.tStart = t;  // (not accounting for frame time here)
      text_99.frameNStart = frameN;  // exact frame index
      
      text_99.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_99.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_99.setAutoDraw(false);
    }
    
    // *text_100* updates
    if (t >= 4.0 && text_100.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_100.tStart = t;  // (not accounting for frame time here)
      text_100.frameNStart = frameN;  // exact frame index
      
      text_100.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_100.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_100.setAutoDraw(false);
    }
    
    // *key_resp_20* updates
    if (t >= 9.0 && key_resp_20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_20.tStart = t;  // (not accounting for frame time here)
      key_resp_20.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_20.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_20.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_20.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_20.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_20.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_20.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_20.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_20_allKeys = _key_resp_20_allKeys.concat(theseKeys);
      if (_key_resp_20_allKeys.length > 0) {
        key_resp_20.keys = _key_resp_20_allKeys[_key_resp_20_allKeys.length - 1].name;  // just the last key pressed
        key_resp_20.rt = _key_resp_20_allKeys[_key_resp_20_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_20.keys == 'n') {
            key_resp_20.corr = 1;
        } else {
            key_resp_20.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    ApsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function ApsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'Apsa' ---
    ApsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_20.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_20.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_20.corr = 1;  // correct non-response
      } else {
         key_resp_20.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_20.corr, level);
    }
    psychoJS.experiment.addData('key_resp_20.keys', key_resp_20.keys);
    psychoJS.experiment.addData('key_resp_20.corr', key_resp_20.corr);
    if (typeof key_resp_20.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_20.rt', key_resp_20.rt);
        routineTimer.reset();
        }
    
    key_resp_20.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_65_allKeys;
var sa_ja_sa_japsaComponents;
function sa_ja_sa_japsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa_ja_sa_japsa' ---
    t = 0;
    sa_ja_sa_japsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_65.secs=3.5;
    sound_vowels_65.setVolume(1.0);
    key_resp_65.keys = undefined;
    key_resp_65.rt = undefined;
    _key_resp_65_allKeys = [];
    // keep track of which components have finished
    sa_ja_sa_japsaComponents = [];
    sa_ja_sa_japsaComponents.push(sound_vowels_65);
    sa_ja_sa_japsaComponents.push(text_321);
    sa_ja_sa_japsaComponents.push(text_322);
    sa_ja_sa_japsaComponents.push(text_323);
    sa_ja_sa_japsaComponents.push(text_324);
    sa_ja_sa_japsaComponents.push(text_325);
    sa_ja_sa_japsaComponents.push(key_resp_65);
    
    sa_ja_sa_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function sa_ja_sa_japsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa_ja_sa_japsa' ---
    // get current time
    t = sa_ja_sa_japsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_65
    if (t >= 5 && sound_vowels_65.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_65.tStart = t;  // (not accounting for frame time here)
      sound_vowels_65.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_65.play(); });  // screen flip
      sound_vowels_65.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_65.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_65.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_65.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_321* updates
    if (t >= 0.0 && text_321.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_321.tStart = t;  // (not accounting for frame time here)
      text_321.frameNStart = frameN;  // exact frame index
      
      text_321.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_321.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_321.setAutoDraw(false);
    }
    
    // *text_322* updates
    if (t >= 9.0 && text_322.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_322.tStart = t;  // (not accounting for frame time here)
      text_322.frameNStart = frameN;  // exact frame index
      
      text_322.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_322.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_322.setAutoDraw(false);
    }
    
    // *text_323* updates
    if (t >= 2 && text_323.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_323.tStart = t;  // (not accounting for frame time here)
      text_323.frameNStart = frameN;  // exact frame index
      
      text_323.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_323.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_323.setAutoDraw(false);
    }
    
    // *text_324* updates
    if (t >= 3.0 && text_324.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_324.tStart = t;  // (not accounting for frame time here)
      text_324.frameNStart = frameN;  // exact frame index
      
      text_324.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_324.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_324.setAutoDraw(false);
    }
    
    // *text_325* updates
    if (t >= 4.0 && text_325.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_325.tStart = t;  // (not accounting for frame time here)
      text_325.frameNStart = frameN;  // exact frame index
      
      text_325.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_325.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_325.setAutoDraw(false);
    }
    
    // *key_resp_65* updates
    if (t >= 9.0 && key_resp_65.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_65.tStart = t;  // (not accounting for frame time here)
      key_resp_65.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_65.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_65.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_65.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_65.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_65.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_65.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_65.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_65_allKeys = _key_resp_65_allKeys.concat(theseKeys);
      if (_key_resp_65_allKeys.length > 0) {
        key_resp_65.keys = _key_resp_65_allKeys[_key_resp_65_allKeys.length - 1].name;  // just the last key pressed
        key_resp_65.rt = _key_resp_65_allKeys[_key_resp_65_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_65.keys == 'n') {
            key_resp_65.corr = 1;
        } else {
            key_resp_65.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    sa_ja_sa_japsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function sa_ja_sa_japsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa_ja_sa_japsa' ---
    sa_ja_sa_japsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_65.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_65.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_65.corr = 1;  // correct non-response
      } else {
         key_resp_65.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_65.corr, level);
    }
    psychoJS.experiment.addData('key_resp_65.keys', key_resp_65.keys);
    psychoJS.experiment.addData('key_resp_65.corr', key_resp_65.corr);
    if (typeof key_resp_65.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_65.rt', key_resp_65.rt);
        routineTimer.reset();
        }
    
    key_resp_65.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_11_allKeys;
var A_jo_AComponents;
function A_jo_ARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'A_jo_A' ---
    t = 0;
    A_jo_AClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_11.secs=3.5;
    sound_vowels_11.setVolume(1.0);
    key_resp_11.keys = undefined;
    key_resp_11.rt = undefined;
    _key_resp_11_allKeys = [];
    // keep track of which components have finished
    A_jo_AComponents = [];
    A_jo_AComponents.push(sound_vowels_11);
    A_jo_AComponents.push(text_51);
    A_jo_AComponents.push(text_52);
    A_jo_AComponents.push(text_53);
    A_jo_AComponents.push(text_54);
    A_jo_AComponents.push(text_55);
    A_jo_AComponents.push(key_resp_11);
    
    A_jo_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function A_jo_ARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'A_jo_A' ---
    // get current time
    t = A_jo_AClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_11
    if (t >= 5 && sound_vowels_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_11.tStart = t;  // (not accounting for frame time here)
      sound_vowels_11.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_11.play(); });  // screen flip
      sound_vowels_11.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_11.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_11.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_51* updates
    if (t >= 0.0 && text_51.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_51.tStart = t;  // (not accounting for frame time here)
      text_51.frameNStart = frameN;  // exact frame index
      
      text_51.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_51.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_51.setAutoDraw(false);
    }
    
    // *text_52* updates
    if (t >= 9.0 && text_52.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_52.tStart = t;  // (not accounting for frame time here)
      text_52.frameNStart = frameN;  // exact frame index
      
      text_52.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_52.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_52.setAutoDraw(false);
    }
    
    // *text_53* updates
    if (t >= 2 && text_53.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_53.tStart = t;  // (not accounting for frame time here)
      text_53.frameNStart = frameN;  // exact frame index
      
      text_53.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_53.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_53.setAutoDraw(false);
    }
    
    // *text_54* updates
    if (t >= 3.0 && text_54.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_54.tStart = t;  // (not accounting for frame time here)
      text_54.frameNStart = frameN;  // exact frame index
      
      text_54.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_54.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_54.setAutoDraw(false);
    }
    
    // *text_55* updates
    if (t >= 4.0 && text_55.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_55.tStart = t;  // (not accounting for frame time here)
      text_55.frameNStart = frameN;  // exact frame index
      
      text_55.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_55.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_55.setAutoDraw(false);
    }
    
    // *key_resp_11* updates
    if (t >= 9.0 && key_resp_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_11.tStart = t;  // (not accounting for frame time here)
      key_resp_11.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_11.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_11.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_11.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_11.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_11.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_11.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_11_allKeys = _key_resp_11_allKeys.concat(theseKeys);
      if (_key_resp_11_allKeys.length > 0) {
        key_resp_11.keys = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].name;  // just the last key pressed
        key_resp_11.rt = _key_resp_11_allKeys[_key_resp_11_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_11.keys == 'y') {
            key_resp_11.corr = 1;
        } else {
            key_resp_11.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    A_jo_AComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function A_jo_ARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'A_jo_A' ---
    A_jo_AComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_11.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_11.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_11.corr = 1;  // correct non-response
      } else {
         key_resp_11.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_11.corr, level);
    }
    psychoJS.experiment.addData('key_resp_11.keys', key_resp_11.keys);
    psychoJS.experiment.addData('key_resp_11.corr', key_resp_11.corr);
    if (typeof key_resp_11.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_11.rt', key_resp_11.rt);
        routineTimer.reset();
        }
    
    key_resp_11.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_27_allKeys;
var joComponents;
function joRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'jo' ---
    t = 0;
    joClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_27.secs=3.5;
    sound_vowels_27.setVolume(1.0);
    key_resp_27.keys = undefined;
    key_resp_27.rt = undefined;
    _key_resp_27_allKeys = [];
    // keep track of which components have finished
    joComponents = [];
    joComponents.push(sound_vowels_27);
    joComponents.push(text_131);
    joComponents.push(text_132);
    joComponents.push(text_133);
    joComponents.push(text_134);
    joComponents.push(text_135);
    joComponents.push(key_resp_27);
    
    joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function joRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'jo' ---
    // get current time
    t = joClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_27
    if (t >= 5 && sound_vowels_27.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_27.tStart = t;  // (not accounting for frame time here)
      sound_vowels_27.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_27.play(); });  // screen flip
      sound_vowels_27.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_27.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_27.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_27.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_131* updates
    if (t >= 0.0 && text_131.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_131.tStart = t;  // (not accounting for frame time here)
      text_131.frameNStart = frameN;  // exact frame index
      
      text_131.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_131.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_131.setAutoDraw(false);
    }
    
    // *text_132* updates
    if (t >= 9.0 && text_132.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_132.tStart = t;  // (not accounting for frame time here)
      text_132.frameNStart = frameN;  // exact frame index
      
      text_132.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_132.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_132.setAutoDraw(false);
    }
    
    // *text_133* updates
    if (t >= 2 && text_133.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_133.tStart = t;  // (not accounting for frame time here)
      text_133.frameNStart = frameN;  // exact frame index
      
      text_133.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_133.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_133.setAutoDraw(false);
    }
    
    // *text_134* updates
    if (t >= 3.0 && text_134.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_134.tStart = t;  // (not accounting for frame time here)
      text_134.frameNStart = frameN;  // exact frame index
      
      text_134.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_134.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_134.setAutoDraw(false);
    }
    
    // *text_135* updates
    if (t >= 4.0 && text_135.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_135.tStart = t;  // (not accounting for frame time here)
      text_135.frameNStart = frameN;  // exact frame index
      
      text_135.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_135.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_135.setAutoDraw(false);
    }
    
    // *key_resp_27* updates
    if (t >= 9.0 && key_resp_27.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_27.tStart = t;  // (not accounting for frame time here)
      key_resp_27.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_27.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_27.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_27.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_27.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_27.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_27.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_27.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_27_allKeys = _key_resp_27_allKeys.concat(theseKeys);
      if (_key_resp_27_allKeys.length > 0) {
        key_resp_27.keys = _key_resp_27_allKeys[_key_resp_27_allKeys.length - 1].name;  // just the last key pressed
        key_resp_27.rt = _key_resp_27_allKeys[_key_resp_27_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_27.keys == 'y') {
            key_resp_27.corr = 1;
        } else {
            key_resp_27.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    joComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function joRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'jo' ---
    joComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_27.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_27.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_27.corr = 1;  // correct non-response
      } else {
         key_resp_27.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_27.corr, level);
    }
    psychoJS.experiment.addData('key_resp_27.keys', key_resp_27.keys);
    psychoJS.experiment.addData('key_resp_27.corr', key_resp_27.corr);
    if (typeof key_resp_27.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_27.rt', key_resp_27.rt);
        routineTimer.reset();
        }
    
    key_resp_27.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_29_allKeys;
var soComponents;
function soRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'so' ---
    t = 0;
    soClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_29.secs=3.5;
    sound_vowels_29.setVolume(1.0);
    key_resp_29.keys = undefined;
    key_resp_29.rt = undefined;
    _key_resp_29_allKeys = [];
    // keep track of which components have finished
    soComponents = [];
    soComponents.push(sound_vowels_29);
    soComponents.push(text_141);
    soComponents.push(text_142);
    soComponents.push(text_143);
    soComponents.push(text_144);
    soComponents.push(text_145);
    soComponents.push(key_resp_29);
    
    soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function soRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'so' ---
    // get current time
    t = soClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_29
    if (t >= 5 && sound_vowels_29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_29.tStart = t;  // (not accounting for frame time here)
      sound_vowels_29.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_29.play(); });  // screen flip
      sound_vowels_29.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_29.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_29.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_29.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_141* updates
    if (t >= 0.0 && text_141.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_141.tStart = t;  // (not accounting for frame time here)
      text_141.frameNStart = frameN;  // exact frame index
      
      text_141.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_141.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_141.setAutoDraw(false);
    }
    
    // *text_142* updates
    if (t >= 9.0 && text_142.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_142.tStart = t;  // (not accounting for frame time here)
      text_142.frameNStart = frameN;  // exact frame index
      
      text_142.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_142.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_142.setAutoDraw(false);
    }
    
    // *text_143* updates
    if (t >= 2 && text_143.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_143.tStart = t;  // (not accounting for frame time here)
      text_143.frameNStart = frameN;  // exact frame index
      
      text_143.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_143.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_143.setAutoDraw(false);
    }
    
    // *text_144* updates
    if (t >= 3.0 && text_144.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_144.tStart = t;  // (not accounting for frame time here)
      text_144.frameNStart = frameN;  // exact frame index
      
      text_144.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_144.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_144.setAutoDraw(false);
    }
    
    // *text_145* updates
    if (t >= 4.0 && text_145.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_145.tStart = t;  // (not accounting for frame time here)
      text_145.frameNStart = frameN;  // exact frame index
      
      text_145.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_145.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_145.setAutoDraw(false);
    }
    
    // *key_resp_29* updates
    if (t >= 9.0 && key_resp_29.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_29.tStart = t;  // (not accounting for frame time here)
      key_resp_29.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_29.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_29.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_29.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_29.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_29.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_29.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_29.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_29_allKeys = _key_resp_29_allKeys.concat(theseKeys);
      if (_key_resp_29_allKeys.length > 0) {
        key_resp_29.keys = _key_resp_29_allKeys[_key_resp_29_allKeys.length - 1].name;  // just the last key pressed
        key_resp_29.rt = _key_resp_29_allKeys[_key_resp_29_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_29.keys == 'y') {
            key_resp_29.corr = 1;
        } else {
            key_resp_29.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function soRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'so' ---
    soComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_29.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_29.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_29.corr = 1;  // correct non-response
      } else {
         key_resp_29.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_29.corr, level);
    }
    psychoJS.experiment.addData('key_resp_29.keys', key_resp_29.keys);
    psychoJS.experiment.addData('key_resp_29.corr', key_resp_29.corr);
    if (typeof key_resp_29.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_29.rt', key_resp_29.rt);
        routineTimer.reset();
        }
    
    key_resp_29.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_28_allKeys;
var jojaComponents;
function jojaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'joja' ---
    t = 0;
    jojaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_28.secs=3.5;
    sound_vowels_28.setVolume(1.0);
    key_resp_28.keys = undefined;
    key_resp_28.rt = undefined;
    _key_resp_28_allKeys = [];
    // keep track of which components have finished
    jojaComponents = [];
    jojaComponents.push(sound_vowels_28);
    jojaComponents.push(text_136);
    jojaComponents.push(text_137);
    jojaComponents.push(text_138);
    jojaComponents.push(text_139);
    jojaComponents.push(text_140);
    jojaComponents.push(key_resp_28);
    
    jojaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jojaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'joja' ---
    // get current time
    t = jojaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_28
    if (t >= 5 && sound_vowels_28.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_28.tStart = t;  // (not accounting for frame time here)
      sound_vowels_28.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_28.play(); });  // screen flip
      sound_vowels_28.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_28.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_28.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_28.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_136* updates
    if (t >= 0.0 && text_136.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_136.tStart = t;  // (not accounting for frame time here)
      text_136.frameNStart = frameN;  // exact frame index
      
      text_136.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_136.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_136.setAutoDraw(false);
    }
    
    // *text_137* updates
    if (t >= 9.0 && text_137.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_137.tStart = t;  // (not accounting for frame time here)
      text_137.frameNStart = frameN;  // exact frame index
      
      text_137.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_137.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_137.setAutoDraw(false);
    }
    
    // *text_138* updates
    if (t >= 2 && text_138.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_138.tStart = t;  // (not accounting for frame time here)
      text_138.frameNStart = frameN;  // exact frame index
      
      text_138.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_138.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_138.setAutoDraw(false);
    }
    
    // *text_139* updates
    if (t >= 3.0 && text_139.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_139.tStart = t;  // (not accounting for frame time here)
      text_139.frameNStart = frameN;  // exact frame index
      
      text_139.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_139.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_139.setAutoDraw(false);
    }
    
    // *text_140* updates
    if (t >= 4.0 && text_140.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_140.tStart = t;  // (not accounting for frame time here)
      text_140.frameNStart = frameN;  // exact frame index
      
      text_140.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_140.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_140.setAutoDraw(false);
    }
    
    // *key_resp_28* updates
    if (t >= 9.0 && key_resp_28.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_28.tStart = t;  // (not accounting for frame time here)
      key_resp_28.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_28.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_28.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_28.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_28.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_28.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_28.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_28.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_28_allKeys = _key_resp_28_allKeys.concat(theseKeys);
      if (_key_resp_28_allKeys.length > 0) {
        key_resp_28.keys = _key_resp_28_allKeys[_key_resp_28_allKeys.length - 1].name;  // just the last key pressed
        key_resp_28.rt = _key_resp_28_allKeys[_key_resp_28_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_28.keys == 'n') {
            key_resp_28.corr = 1;
        } else {
            key_resp_28.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jojaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jojaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'joja' ---
    jojaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_28.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_28.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_28.corr = 1;  // correct non-response
      } else {
         key_resp_28.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_28.corr, level);
    }
    psychoJS.experiment.addData('key_resp_28.keys', key_resp_28.keys);
    psychoJS.experiment.addData('key_resp_28.corr', key_resp_28.corr);
    if (typeof key_resp_28.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_28.rt', key_resp_28.rt);
        routineTimer.reset();
        }
    
    key_resp_28.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_26_allKeys;
var jaComponents;
function jaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'ja' ---
    t = 0;
    jaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_26.secs=3.5;
    sound_vowels_26.setVolume(1.0);
    key_resp_26.keys = undefined;
    key_resp_26.rt = undefined;
    _key_resp_26_allKeys = [];
    // keep track of which components have finished
    jaComponents = [];
    jaComponents.push(sound_vowels_26);
    jaComponents.push(text_126);
    jaComponents.push(text_127);
    jaComponents.push(text_128);
    jaComponents.push(text_129);
    jaComponents.push(text_130);
    jaComponents.push(key_resp_26);
    
    jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function jaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'ja' ---
    // get current time
    t = jaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_26
    if (t >= 5 && sound_vowels_26.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_26.tStart = t;  // (not accounting for frame time here)
      sound_vowels_26.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_26.play(); });  // screen flip
      sound_vowels_26.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_26.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_26.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_26.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_126* updates
    if (t >= 0.0 && text_126.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_126.tStart = t;  // (not accounting for frame time here)
      text_126.frameNStart = frameN;  // exact frame index
      
      text_126.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_126.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_126.setAutoDraw(false);
    }
    
    // *text_127* updates
    if (t >= 9.0 && text_127.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_127.tStart = t;  // (not accounting for frame time here)
      text_127.frameNStart = frameN;  // exact frame index
      
      text_127.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_127.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_127.setAutoDraw(false);
    }
    
    // *text_128* updates
    if (t >= 2 && text_128.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_128.tStart = t;  // (not accounting for frame time here)
      text_128.frameNStart = frameN;  // exact frame index
      
      text_128.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_128.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_128.setAutoDraw(false);
    }
    
    // *text_129* updates
    if (t >= 3.0 && text_129.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_129.tStart = t;  // (not accounting for frame time here)
      text_129.frameNStart = frameN;  // exact frame index
      
      text_129.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_129.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_129.setAutoDraw(false);
    }
    
    // *text_130* updates
    if (t >= 4.0 && text_130.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_130.tStart = t;  // (not accounting for frame time here)
      text_130.frameNStart = frameN;  // exact frame index
      
      text_130.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_130.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_130.setAutoDraw(false);
    }
    
    // *key_resp_26* updates
    if (t >= 9.0 && key_resp_26.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_26.tStart = t;  // (not accounting for frame time here)
      key_resp_26.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_26.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_26.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_26.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_26.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_26.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_26.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_26.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_26_allKeys = _key_resp_26_allKeys.concat(theseKeys);
      if (_key_resp_26_allKeys.length > 0) {
        key_resp_26.keys = _key_resp_26_allKeys[_key_resp_26_allKeys.length - 1].name;  // just the last key pressed
        key_resp_26.rt = _key_resp_26_allKeys[_key_resp_26_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_26.keys == 'y') {
            key_resp_26.corr = 1;
        } else {
            key_resp_26.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    jaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function jaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'ja' ---
    jaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_26.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_26.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_26.corr = 1;  // correct non-response
      } else {
         key_resp_26.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_26.corr, level);
    }
    psychoJS.experiment.addData('key_resp_26.keys', key_resp_26.keys);
    psychoJS.experiment.addData('key_resp_26.corr', key_resp_26.corr);
    if (typeof key_resp_26.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_26.rt', key_resp_26.rt);
        routineTimer.reset();
        }
    
    key_resp_26.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_25_allKeys;
var AsasapAComponents;
function AsasapARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AsasapA' ---
    t = 0;
    AsasapAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_25.secs=3.5;
    sound_vowels_25.setVolume(1.0);
    key_resp_25.keys = undefined;
    key_resp_25.rt = undefined;
    _key_resp_25_allKeys = [];
    // keep track of which components have finished
    AsasapAComponents = [];
    AsasapAComponents.push(sound_vowels_25);
    AsasapAComponents.push(text_121);
    AsasapAComponents.push(text_122);
    AsasapAComponents.push(text_123);
    AsasapAComponents.push(text_124);
    AsasapAComponents.push(text_125);
    AsasapAComponents.push(key_resp_25);
    
    AsasapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AsasapARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AsasapA' ---
    // get current time
    t = AsasapAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_25
    if (t >= 5 && sound_vowels_25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_25.tStart = t;  // (not accounting for frame time here)
      sound_vowels_25.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_25.play(); });  // screen flip
      sound_vowels_25.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_25.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_25.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_25.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_121* updates
    if (t >= 0.0 && text_121.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_121.tStart = t;  // (not accounting for frame time here)
      text_121.frameNStart = frameN;  // exact frame index
      
      text_121.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_121.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_121.setAutoDraw(false);
    }
    
    // *text_122* updates
    if (t >= 9.0 && text_122.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_122.tStart = t;  // (not accounting for frame time here)
      text_122.frameNStart = frameN;  // exact frame index
      
      text_122.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_122.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_122.setAutoDraw(false);
    }
    
    // *text_123* updates
    if (t >= 2 && text_123.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_123.tStart = t;  // (not accounting for frame time here)
      text_123.frameNStart = frameN;  // exact frame index
      
      text_123.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_123.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_123.setAutoDraw(false);
    }
    
    // *text_124* updates
    if (t >= 3.0 && text_124.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_124.tStart = t;  // (not accounting for frame time here)
      text_124.frameNStart = frameN;  // exact frame index
      
      text_124.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_124.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_124.setAutoDraw(false);
    }
    
    // *text_125* updates
    if (t >= 4.0 && text_125.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_125.tStart = t;  // (not accounting for frame time here)
      text_125.frameNStart = frameN;  // exact frame index
      
      text_125.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_125.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_125.setAutoDraw(false);
    }
    
    // *key_resp_25* updates
    if (t >= 9.0 && key_resp_25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_25.tStart = t;  // (not accounting for frame time here)
      key_resp_25.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_25.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_25.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_25.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_25.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_25.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_25.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_25.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_25_allKeys = _key_resp_25_allKeys.concat(theseKeys);
      if (_key_resp_25_allKeys.length > 0) {
        key_resp_25.keys = _key_resp_25_allKeys[_key_resp_25_allKeys.length - 1].name;  // just the last key pressed
        key_resp_25.rt = _key_resp_25_allKeys[_key_resp_25_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_25.keys == 'n') {
            key_resp_25.corr = 1;
        } else {
            key_resp_25.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AsasapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AsasapARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AsasapA' ---
    AsasapAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_25.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_25.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_25.corr = 1;  // correct non-response
      } else {
         key_resp_25.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_25.corr, level);
    }
    psychoJS.experiment.addData('key_resp_25.keys', key_resp_25.keys);
    psychoJS.experiment.addData('key_resp_25.corr', key_resp_25.corr);
    if (typeof key_resp_25.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_25.rt', key_resp_25.rt);
        routineTimer.reset();
        }
    
    key_resp_25.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_14_allKeys;
var AjoApAComponents;
function AjoApARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AjoApA' ---
    t = 0;
    AjoApAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_14.secs=3.5;
    sound_vowels_14.setVolume(1.0);
    key_resp_14.keys = undefined;
    key_resp_14.rt = undefined;
    _key_resp_14_allKeys = [];
    // keep track of which components have finished
    AjoApAComponents = [];
    AjoApAComponents.push(sound_vowels_14);
    AjoApAComponents.push(text_66);
    AjoApAComponents.push(text_67);
    AjoApAComponents.push(text_68);
    AjoApAComponents.push(text_69);
    AjoApAComponents.push(text_70);
    AjoApAComponents.push(key_resp_14);
    
    AjoApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AjoApARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AjoApA' ---
    // get current time
    t = AjoApAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_14
    if (t >= 5 && sound_vowels_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_14.tStart = t;  // (not accounting for frame time here)
      sound_vowels_14.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_14.play(); });  // screen flip
      sound_vowels_14.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_14.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_14.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_14.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_66* updates
    if (t >= 0.0 && text_66.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_66.tStart = t;  // (not accounting for frame time here)
      text_66.frameNStart = frameN;  // exact frame index
      
      text_66.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_66.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_66.setAutoDraw(false);
    }
    
    // *text_67* updates
    if (t >= 9.0 && text_67.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_67.tStart = t;  // (not accounting for frame time here)
      text_67.frameNStart = frameN;  // exact frame index
      
      text_67.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_67.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_67.setAutoDraw(false);
    }
    
    // *text_68* updates
    if (t >= 2 && text_68.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_68.tStart = t;  // (not accounting for frame time here)
      text_68.frameNStart = frameN;  // exact frame index
      
      text_68.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_68.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_68.setAutoDraw(false);
    }
    
    // *text_69* updates
    if (t >= 3.0 && text_69.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_69.tStart = t;  // (not accounting for frame time here)
      text_69.frameNStart = frameN;  // exact frame index
      
      text_69.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_69.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_69.setAutoDraw(false);
    }
    
    // *text_70* updates
    if (t >= 4.0 && text_70.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_70.tStart = t;  // (not accounting for frame time here)
      text_70.frameNStart = frameN;  // exact frame index
      
      text_70.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_70.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_70.setAutoDraw(false);
    }
    
    // *key_resp_14* updates
    if (t >= 9.0 && key_resp_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_14.tStart = t;  // (not accounting for frame time here)
      key_resp_14.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_14.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_14.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_14.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_14.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_14.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_14.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_14.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_14_allKeys = _key_resp_14_allKeys.concat(theseKeys);
      if (_key_resp_14_allKeys.length > 0) {
        key_resp_14.keys = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].name;  // just the last key pressed
        key_resp_14.rt = _key_resp_14_allKeys[_key_resp_14_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_14.keys == 'n') {
            key_resp_14.corr = 1;
        } else {
            key_resp_14.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AjoApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AjoApARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AjoApA' ---
    AjoApAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_14.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_14.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_14.corr = 1;  // correct non-response
      } else {
         key_resp_14.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_14.corr, level);
    }
    psychoJS.experiment.addData('key_resp_14.keys', key_resp_14.keys);
    psychoJS.experiment.addData('key_resp_14.corr', key_resp_14.corr);
    if (typeof key_resp_14.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_14.rt', key_resp_14.rt);
        routineTimer.reset();
        }
    
    key_resp_14.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_10_allKeys;
var A_A_saComponents;
function A_A_saRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'A_A_sa' ---
    t = 0;
    A_A_saClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_10.secs=3.5;
    sound_vowels_10.setVolume(1.0);
    key_resp_10.keys = undefined;
    key_resp_10.rt = undefined;
    _key_resp_10_allKeys = [];
    // keep track of which components have finished
    A_A_saComponents = [];
    A_A_saComponents.push(sound_vowels_10);
    A_A_saComponents.push(text_46);
    A_A_saComponents.push(text_47);
    A_A_saComponents.push(text_48);
    A_A_saComponents.push(text_49);
    A_A_saComponents.push(text_50);
    A_A_saComponents.push(key_resp_10);
    
    A_A_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function A_A_saRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'A_A_sa' ---
    // get current time
    t = A_A_saClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_10
    if (t >= 5 && sound_vowels_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_10.tStart = t;  // (not accounting for frame time here)
      sound_vowels_10.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_10.play(); });  // screen flip
      sound_vowels_10.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_10.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_10.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_46* updates
    if (t >= 0.0 && text_46.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_46.tStart = t;  // (not accounting for frame time here)
      text_46.frameNStart = frameN;  // exact frame index
      
      text_46.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_46.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_46.setAutoDraw(false);
    }
    
    // *text_47* updates
    if (t >= 9.0 && text_47.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_47.tStart = t;  // (not accounting for frame time here)
      text_47.frameNStart = frameN;  // exact frame index
      
      text_47.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_47.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_47.setAutoDraw(false);
    }
    
    // *text_48* updates
    if (t >= 2 && text_48.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_48.tStart = t;  // (not accounting for frame time here)
      text_48.frameNStart = frameN;  // exact frame index
      
      text_48.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_48.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_48.setAutoDraw(false);
    }
    
    // *text_49* updates
    if (t >= 3.0 && text_49.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_49.tStart = t;  // (not accounting for frame time here)
      text_49.frameNStart = frameN;  // exact frame index
      
      text_49.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_49.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_49.setAutoDraw(false);
    }
    
    // *text_50* updates
    if (t >= 4.0 && text_50.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_50.tStart = t;  // (not accounting for frame time here)
      text_50.frameNStart = frameN;  // exact frame index
      
      text_50.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_50.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_50.setAutoDraw(false);
    }
    
    // *key_resp_10* updates
    if (t >= 9.0 && key_resp_10.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_10.tStart = t;  // (not accounting for frame time here)
      key_resp_10.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_10.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_10.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_10.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_10.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_10.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_10.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_10.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_10_allKeys = _key_resp_10_allKeys.concat(theseKeys);
      if (_key_resp_10_allKeys.length > 0) {
        key_resp_10.keys = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].name;  // just the last key pressed
        key_resp_10.rt = _key_resp_10_allKeys[_key_resp_10_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_10.keys == 'y') {
            key_resp_10.corr = 1;
        } else {
            key_resp_10.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    A_A_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function A_A_saRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'A_A_sa' ---
    A_A_saComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_10.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_10.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_10.corr = 1;  // correct non-response
      } else {
         key_resp_10.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_10.corr, level);
    }
    psychoJS.experiment.addData('key_resp_10.keys', key_resp_10.keys);
    psychoJS.experiment.addData('key_resp_10.corr', key_resp_10.corr);
    if (typeof key_resp_10.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_10.rt', key_resp_10.rt);
        routineTimer.reset();
        }
    
    key_resp_10.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_30_allKeys;
var saComponents;
function saRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'sa' ---
    t = 0;
    saClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_30.secs=3.5;
    sound_vowels_30.setVolume(1.0);
    key_resp_30.keys = undefined;
    key_resp_30.rt = undefined;
    _key_resp_30_allKeys = [];
    // keep track of which components have finished
    saComponents = [];
    saComponents.push(sound_vowels_30);
    saComponents.push(text_146);
    saComponents.push(text_147);
    saComponents.push(text_148);
    saComponents.push(text_149);
    saComponents.push(text_150);
    saComponents.push(key_resp_30);
    
    saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function saRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'sa' ---
    // get current time
    t = saClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_30
    if (t >= 5 && sound_vowels_30.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_30.tStart = t;  // (not accounting for frame time here)
      sound_vowels_30.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_30.play(); });  // screen flip
      sound_vowels_30.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_30.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_30.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_30.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_146* updates
    if (t >= 0.0 && text_146.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_146.tStart = t;  // (not accounting for frame time here)
      text_146.frameNStart = frameN;  // exact frame index
      
      text_146.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_146.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_146.setAutoDraw(false);
    }
    
    // *text_147* updates
    if (t >= 9.0 && text_147.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_147.tStart = t;  // (not accounting for frame time here)
      text_147.frameNStart = frameN;  // exact frame index
      
      text_147.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_147.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_147.setAutoDraw(false);
    }
    
    // *text_148* updates
    if (t >= 2 && text_148.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_148.tStart = t;  // (not accounting for frame time here)
      text_148.frameNStart = frameN;  // exact frame index
      
      text_148.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_148.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_148.setAutoDraw(false);
    }
    
    // *text_149* updates
    if (t >= 3.0 && text_149.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_149.tStart = t;  // (not accounting for frame time here)
      text_149.frameNStart = frameN;  // exact frame index
      
      text_149.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_149.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_149.setAutoDraw(false);
    }
    
    // *text_150* updates
    if (t >= 4.0 && text_150.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_150.tStart = t;  // (not accounting for frame time here)
      text_150.frameNStart = frameN;  // exact frame index
      
      text_150.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_150.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_150.setAutoDraw(false);
    }
    
    // *key_resp_30* updates
    if (t >= 9.0 && key_resp_30.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_30.tStart = t;  // (not accounting for frame time here)
      key_resp_30.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_30.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_30.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_30.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_30.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_30.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_30.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_30.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_30_allKeys = _key_resp_30_allKeys.concat(theseKeys);
      if (_key_resp_30_allKeys.length > 0) {
        key_resp_30.keys = _key_resp_30_allKeys[_key_resp_30_allKeys.length - 1].name;  // just the last key pressed
        key_resp_30.rt = _key_resp_30_allKeys[_key_resp_30_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_30.keys == 'y') {
            key_resp_30.corr = 1;
        } else {
            key_resp_30.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function saRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'sa' ---
    saComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_30.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_30.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_30.corr = 1;  // correct non-response
      } else {
         key_resp_30.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_30.corr, level);
    }
    psychoJS.experiment.addData('key_resp_30.keys', key_resp_30.keys);
    psychoJS.experiment.addData('key_resp_30.corr', key_resp_30.corr);
    if (typeof key_resp_30.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_30.rt', key_resp_30.rt);
        routineTimer.reset();
        }
    
    key_resp_30.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_23_allKeys;
var AsaAsapAComponents;
function AsaAsapARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AsaAsapA' ---
    t = 0;
    AsaAsapAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_23.secs=3.5;
    sound_vowels_23.setVolume(1.0);
    key_resp_23.keys = undefined;
    key_resp_23.rt = undefined;
    _key_resp_23_allKeys = [];
    // keep track of which components have finished
    AsaAsapAComponents = [];
    AsaAsapAComponents.push(sound_vowels_23);
    AsaAsapAComponents.push(text_111);
    AsaAsapAComponents.push(text_112);
    AsaAsapAComponents.push(text_113);
    AsaAsapAComponents.push(text_114);
    AsaAsapAComponents.push(text_115);
    AsaAsapAComponents.push(key_resp_23);
    
    AsaAsapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AsaAsapARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AsaAsapA' ---
    // get current time
    t = AsaAsapAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_23
    if (t >= 5 && sound_vowels_23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_23.tStart = t;  // (not accounting for frame time here)
      sound_vowels_23.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_23.play(); });  // screen flip
      sound_vowels_23.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_23.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_23.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_23.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_111* updates
    if (t >= 0.0 && text_111.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_111.tStart = t;  // (not accounting for frame time here)
      text_111.frameNStart = frameN;  // exact frame index
      
      text_111.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_111.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_111.setAutoDraw(false);
    }
    
    // *text_112* updates
    if (t >= 9.0 && text_112.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_112.tStart = t;  // (not accounting for frame time here)
      text_112.frameNStart = frameN;  // exact frame index
      
      text_112.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_112.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_112.setAutoDraw(false);
    }
    
    // *text_113* updates
    if (t >= 2 && text_113.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_113.tStart = t;  // (not accounting for frame time here)
      text_113.frameNStart = frameN;  // exact frame index
      
      text_113.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_113.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_113.setAutoDraw(false);
    }
    
    // *text_114* updates
    if (t >= 3.0 && text_114.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_114.tStart = t;  // (not accounting for frame time here)
      text_114.frameNStart = frameN;  // exact frame index
      
      text_114.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_114.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_114.setAutoDraw(false);
    }
    
    // *text_115* updates
    if (t >= 4.0 && text_115.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_115.tStart = t;  // (not accounting for frame time here)
      text_115.frameNStart = frameN;  // exact frame index
      
      text_115.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_115.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_115.setAutoDraw(false);
    }
    
    // *key_resp_23* updates
    if (t >= 9.0 && key_resp_23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_23.tStart = t;  // (not accounting for frame time here)
      key_resp_23.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_23.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_23.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_23.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_23.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_23.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_23.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_23.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_23_allKeys = _key_resp_23_allKeys.concat(theseKeys);
      if (_key_resp_23_allKeys.length > 0) {
        key_resp_23.keys = _key_resp_23_allKeys[_key_resp_23_allKeys.length - 1].name;  // just the last key pressed
        key_resp_23.rt = _key_resp_23_allKeys[_key_resp_23_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_23.keys == 'n') {
            key_resp_23.corr = 1;
        } else {
            key_resp_23.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AsaAsapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AsaAsapARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AsaAsapA' ---
    AsaAsapAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_23.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_23.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_23.corr = 1;  // correct non-response
      } else {
         key_resp_23.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_23.corr, level);
    }
    psychoJS.experiment.addData('key_resp_23.keys', key_resp_23.keys);
    psychoJS.experiment.addData('key_resp_23.corr', key_resp_23.corr);
    if (typeof key_resp_23.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_23.rt', key_resp_23.rt);
        routineTimer.reset();
        }
    
    key_resp_23.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_15_allKeys;
var usousopsoComponents;
function usousopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'usousopso' ---
    t = 0;
    usousopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_15.secs=3.5;
    sound_vowels_15.setVolume(1.0);
    key_resp_15.keys = undefined;
    key_resp_15.rt = undefined;
    _key_resp_15_allKeys = [];
    // keep track of which components have finished
    usousopsoComponents = [];
    usousopsoComponents.push(sound_vowels_15);
    usousopsoComponents.push(text_71);
    usousopsoComponents.push(text_72);
    usousopsoComponents.push(text_73);
    usousopsoComponents.push(text_74);
    usousopsoComponents.push(text_75);
    usousopsoComponents.push(key_resp_15);
    
    usousopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function usousopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'usousopso' ---
    // get current time
    t = usousopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_15
    if (t >= 5 && sound_vowels_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_15.tStart = t;  // (not accounting for frame time here)
      sound_vowels_15.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_15.play(); });  // screen flip
      sound_vowels_15.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_15.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_15.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_15.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_71* updates
    if (t >= 0.0 && text_71.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_71.tStart = t;  // (not accounting for frame time here)
      text_71.frameNStart = frameN;  // exact frame index
      
      text_71.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_71.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_71.setAutoDraw(false);
    }
    
    // *text_72* updates
    if (t >= 9.0 && text_72.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_72.tStart = t;  // (not accounting for frame time here)
      text_72.frameNStart = frameN;  // exact frame index
      
      text_72.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_72.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_72.setAutoDraw(false);
    }
    
    // *text_73* updates
    if (t >= 2 && text_73.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_73.tStart = t;  // (not accounting for frame time here)
      text_73.frameNStart = frameN;  // exact frame index
      
      text_73.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_73.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_73.setAutoDraw(false);
    }
    
    // *text_74* updates
    if (t >= 3.0 && text_74.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_74.tStart = t;  // (not accounting for frame time here)
      text_74.frameNStart = frameN;  // exact frame index
      
      text_74.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_74.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_74.setAutoDraw(false);
    }
    
    // *text_75* updates
    if (t >= 4.0 && text_75.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_75.tStart = t;  // (not accounting for frame time here)
      text_75.frameNStart = frameN;  // exact frame index
      
      text_75.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_75.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_75.setAutoDraw(false);
    }
    
    // *key_resp_15* updates
    if (t >= 9.0 && key_resp_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_15.tStart = t;  // (not accounting for frame time here)
      key_resp_15.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_15.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_15.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_15.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_15.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_15.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_15.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_15.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_15_allKeys = _key_resp_15_allKeys.concat(theseKeys);
      if (_key_resp_15_allKeys.length > 0) {
        key_resp_15.keys = _key_resp_15_allKeys[_key_resp_15_allKeys.length - 1].name;  // just the last key pressed
        key_resp_15.rt = _key_resp_15_allKeys[_key_resp_15_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_15.keys == 'n') {
            key_resp_15.corr = 1;
        } else {
            key_resp_15.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    usousopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function usousopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'usousopso' ---
    usousopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_15.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_15.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_15.corr = 1;  // correct non-response
      } else {
         key_resp_15.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_15.corr, level);
    }
    psychoJS.experiment.addData('key_resp_15.keys', key_resp_15.keys);
    psychoJS.experiment.addData('key_resp_15.corr', key_resp_15.corr);
    if (typeof key_resp_15.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_15.rt', key_resp_15.rt);
        routineTimer.reset();
        }
    
    key_resp_15.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_12_allKeys;
var AAsapAComponents;
function AAsapARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AAsapA' ---
    t = 0;
    AAsapAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_12.secs=3.5;
    sound_vowels_12.setVolume(1.0);
    key_resp_12.keys = undefined;
    key_resp_12.rt = undefined;
    _key_resp_12_allKeys = [];
    // keep track of which components have finished
    AAsapAComponents = [];
    AAsapAComponents.push(sound_vowels_12);
    AAsapAComponents.push(text_56);
    AAsapAComponents.push(text_57);
    AAsapAComponents.push(text_58);
    AAsapAComponents.push(text_59);
    AAsapAComponents.push(text_60);
    AAsapAComponents.push(key_resp_12);
    
    AAsapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AAsapARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AAsapA' ---
    // get current time
    t = AAsapAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_12
    if (t >= 5 && sound_vowels_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_12.tStart = t;  // (not accounting for frame time here)
      sound_vowels_12.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_12.play(); });  // screen flip
      sound_vowels_12.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_12.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_12.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_56* updates
    if (t >= 0.0 && text_56.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_56.tStart = t;  // (not accounting for frame time here)
      text_56.frameNStart = frameN;  // exact frame index
      
      text_56.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_56.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_56.setAutoDraw(false);
    }
    
    // *text_57* updates
    if (t >= 9.0 && text_57.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_57.tStart = t;  // (not accounting for frame time here)
      text_57.frameNStart = frameN;  // exact frame index
      
      text_57.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_57.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_57.setAutoDraw(false);
    }
    
    // *text_58* updates
    if (t >= 2 && text_58.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_58.tStart = t;  // (not accounting for frame time here)
      text_58.frameNStart = frameN;  // exact frame index
      
      text_58.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_58.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_58.setAutoDraw(false);
    }
    
    // *text_59* updates
    if (t >= 3.0 && text_59.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_59.tStart = t;  // (not accounting for frame time here)
      text_59.frameNStart = frameN;  // exact frame index
      
      text_59.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_59.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_59.setAutoDraw(false);
    }
    
    // *text_60* updates
    if (t >= 4.0 && text_60.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_60.tStart = t;  // (not accounting for frame time here)
      text_60.frameNStart = frameN;  // exact frame index
      
      text_60.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_60.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_60.setAutoDraw(false);
    }
    
    // *key_resp_12* updates
    if (t >= 9.0 && key_resp_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_12.tStart = t;  // (not accounting for frame time here)
      key_resp_12.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_12.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_12.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_12.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_12.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_12.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_12.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_12_allKeys = _key_resp_12_allKeys.concat(theseKeys);
      if (_key_resp_12_allKeys.length > 0) {
        key_resp_12.keys = _key_resp_12_allKeys[_key_resp_12_allKeys.length - 1].name;  // just the last key pressed
        key_resp_12.rt = _key_resp_12_allKeys[_key_resp_12_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_12.keys == 'n') {
            key_resp_12.corr = 1;
        } else {
            key_resp_12.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AAsapAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AAsapARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AAsapA' ---
    AAsapAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_12.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_12.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_12.corr = 1;  // correct non-response
      } else {
         key_resp_12.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_12.corr, level);
    }
    psychoJS.experiment.addData('key_resp_12.keys', key_resp_12.keys);
    psychoJS.experiment.addData('key_resp_12.corr', key_resp_12.corr);
    if (typeof key_resp_12.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_12.rt', key_resp_12.rt);
        routineTimer.reset();
        }
    
    key_resp_12.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_19_allKeys;
var AjoApjoComponents;
function AjoApjoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AjoApjo' ---
    t = 0;
    AjoApjoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_19.secs=3.5;
    sound_vowels_19.setVolume(1.0);
    key_resp_19.keys = undefined;
    key_resp_19.rt = undefined;
    _key_resp_19_allKeys = [];
    // keep track of which components have finished
    AjoApjoComponents = [];
    AjoApjoComponents.push(sound_vowels_19);
    AjoApjoComponents.push(text_91);
    AjoApjoComponents.push(text_92);
    AjoApjoComponents.push(text_93);
    AjoApjoComponents.push(text_94);
    AjoApjoComponents.push(text_95);
    AjoApjoComponents.push(key_resp_19);
    
    AjoApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AjoApjoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AjoApjo' ---
    // get current time
    t = AjoApjoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_19
    if (t >= 5 && sound_vowels_19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_19.tStart = t;  // (not accounting for frame time here)
      sound_vowels_19.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_19.play(); });  // screen flip
      sound_vowels_19.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_19.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_19.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_19.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_91* updates
    if (t >= 0.0 && text_91.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_91.tStart = t;  // (not accounting for frame time here)
      text_91.frameNStart = frameN;  // exact frame index
      
      text_91.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_91.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_91.setAutoDraw(false);
    }
    
    // *text_92* updates
    if (t >= 9.0 && text_92.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_92.tStart = t;  // (not accounting for frame time here)
      text_92.frameNStart = frameN;  // exact frame index
      
      text_92.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_92.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_92.setAutoDraw(false);
    }
    
    // *text_93* updates
    if (t >= 2 && text_93.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_93.tStart = t;  // (not accounting for frame time here)
      text_93.frameNStart = frameN;  // exact frame index
      
      text_93.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_93.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_93.setAutoDraw(false);
    }
    
    // *text_94* updates
    if (t >= 3.0 && text_94.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_94.tStart = t;  // (not accounting for frame time here)
      text_94.frameNStart = frameN;  // exact frame index
      
      text_94.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_94.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_94.setAutoDraw(false);
    }
    
    // *text_95* updates
    if (t >= 4.0 && text_95.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_95.tStart = t;  // (not accounting for frame time here)
      text_95.frameNStart = frameN;  // exact frame index
      
      text_95.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_95.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_95.setAutoDraw(false);
    }
    
    // *key_resp_19* updates
    if (t >= 9.0 && key_resp_19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_19.tStart = t;  // (not accounting for frame time here)
      key_resp_19.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_19.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_19.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_19.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_19.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_19.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_19.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_19.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_19_allKeys = _key_resp_19_allKeys.concat(theseKeys);
      if (_key_resp_19_allKeys.length > 0) {
        key_resp_19.keys = _key_resp_19_allKeys[_key_resp_19_allKeys.length - 1].name;  // just the last key pressed
        key_resp_19.rt = _key_resp_19_allKeys[_key_resp_19_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_19.keys == 'n') {
            key_resp_19.corr = 1;
        } else {
            key_resp_19.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AjoApjoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AjoApjoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AjoApjo' ---
    AjoApjoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_19.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_19.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_19.corr = 1;  // correct non-response
      } else {
         key_resp_19.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_19.corr, level);
    }
    psychoJS.experiment.addData('key_resp_19.keys', key_resp_19.keys);
    psychoJS.experiment.addData('key_resp_19.corr', key_resp_19.corr);
    if (typeof key_resp_19.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_19.rt', key_resp_19.rt);
        routineTimer.reset();
        }
    
    key_resp_19.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_13_allKeys;
var AAsapsaComponents;
function AAsapsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AAsapsa' ---
    t = 0;
    AAsapsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_13.secs=3.5;
    sound_vowels_13.setVolume(1.0);
    key_resp_13.keys = undefined;
    key_resp_13.rt = undefined;
    _key_resp_13_allKeys = [];
    // keep track of which components have finished
    AAsapsaComponents = [];
    AAsapsaComponents.push(sound_vowels_13);
    AAsapsaComponents.push(text_61);
    AAsapsaComponents.push(text_62);
    AAsapsaComponents.push(text_63);
    AAsapsaComponents.push(text_64);
    AAsapsaComponents.push(text_65);
    AAsapsaComponents.push(key_resp_13);
    
    AAsapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AAsapsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AAsapsa' ---
    // get current time
    t = AAsapsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_13
    if (t >= 5 && sound_vowels_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_13.tStart = t;  // (not accounting for frame time here)
      sound_vowels_13.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_13.play(); });  // screen flip
      sound_vowels_13.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_13.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_13.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_61* updates
    if (t >= 0.0 && text_61.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_61.tStart = t;  // (not accounting for frame time here)
      text_61.frameNStart = frameN;  // exact frame index
      
      text_61.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_61.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_61.setAutoDraw(false);
    }
    
    // *text_62* updates
    if (t >= 9.0 && text_62.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_62.tStart = t;  // (not accounting for frame time here)
      text_62.frameNStart = frameN;  // exact frame index
      
      text_62.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_62.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_62.setAutoDraw(false);
    }
    
    // *text_63* updates
    if (t >= 2 && text_63.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_63.tStart = t;  // (not accounting for frame time here)
      text_63.frameNStart = frameN;  // exact frame index
      
      text_63.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_63.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_63.setAutoDraw(false);
    }
    
    // *text_64* updates
    if (t >= 3.0 && text_64.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_64.tStart = t;  // (not accounting for frame time here)
      text_64.frameNStart = frameN;  // exact frame index
      
      text_64.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_64.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_64.setAutoDraw(false);
    }
    
    // *text_65* updates
    if (t >= 4.0 && text_65.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_65.tStart = t;  // (not accounting for frame time here)
      text_65.frameNStart = frameN;  // exact frame index
      
      text_65.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_65.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_65.setAutoDraw(false);
    }
    
    // *key_resp_13* updates
    if (t >= 9.0 && key_resp_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_13.tStart = t;  // (not accounting for frame time here)
      key_resp_13.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_13.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_13.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_13.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_13.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_13.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_13.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_13_allKeys = _key_resp_13_allKeys.concat(theseKeys);
      if (_key_resp_13_allKeys.length > 0) {
        key_resp_13.keys = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].name;  // just the last key pressed
        key_resp_13.rt = _key_resp_13_allKeys[_key_resp_13_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_13.keys == 'n') {
            key_resp_13.corr = 1;
        } else {
            key_resp_13.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AAsapsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AAsapsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AAsapsa' ---
    AAsapsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_13.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_13.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_13.corr = 1;  // correct non-response
      } else {
         key_resp_13.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_13.corr, level);
    }
    psychoJS.experiment.addData('key_resp_13.keys', key_resp_13.keys);
    psychoJS.experiment.addData('key_resp_13.corr', key_resp_13.corr);
    if (typeof key_resp_13.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_13.rt', key_resp_13.rt);
        routineTimer.reset();
        }
    
    key_resp_13.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_17_allKeys;
var usosopsoComponents;
function usosopsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'usosopso' ---
    t = 0;
    usosopsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_17.secs=3.5;
    sound_vowels_17.setVolume(1.0);
    key_resp_17.keys = undefined;
    key_resp_17.rt = undefined;
    _key_resp_17_allKeys = [];
    // keep track of which components have finished
    usosopsoComponents = [];
    usosopsoComponents.push(sound_vowels_17);
    usosopsoComponents.push(text_81);
    usosopsoComponents.push(text_82);
    usosopsoComponents.push(text_83);
    usosopsoComponents.push(text_84);
    usosopsoComponents.push(text_85);
    usosopsoComponents.push(key_resp_17);
    
    usosopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function usosopsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'usosopso' ---
    // get current time
    t = usosopsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_17
    if (t >= 5 && sound_vowels_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_17.tStart = t;  // (not accounting for frame time here)
      sound_vowels_17.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_17.play(); });  // screen flip
      sound_vowels_17.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_17.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_17.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_17.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_81* updates
    if (t >= 0.0 && text_81.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_81.tStart = t;  // (not accounting for frame time here)
      text_81.frameNStart = frameN;  // exact frame index
      
      text_81.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_81.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_81.setAutoDraw(false);
    }
    
    // *text_82* updates
    if (t >= 9.0 && text_82.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_82.tStart = t;  // (not accounting for frame time here)
      text_82.frameNStart = frameN;  // exact frame index
      
      text_82.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_82.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_82.setAutoDraw(false);
    }
    
    // *text_83* updates
    if (t >= 2 && text_83.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_83.tStart = t;  // (not accounting for frame time here)
      text_83.frameNStart = frameN;  // exact frame index
      
      text_83.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_83.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_83.setAutoDraw(false);
    }
    
    // *text_84* updates
    if (t >= 3.0 && text_84.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_84.tStart = t;  // (not accounting for frame time here)
      text_84.frameNStart = frameN;  // exact frame index
      
      text_84.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_84.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_84.setAutoDraw(false);
    }
    
    // *text_85* updates
    if (t >= 4.0 && text_85.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_85.tStart = t;  // (not accounting for frame time here)
      text_85.frameNStart = frameN;  // exact frame index
      
      text_85.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_85.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_85.setAutoDraw(false);
    }
    
    // *key_resp_17* updates
    if (t >= 9.0 && key_resp_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_17.tStart = t;  // (not accounting for frame time here)
      key_resp_17.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_17.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_17.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_17.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_17.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_17.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_17.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_17.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_17_allKeys = _key_resp_17_allKeys.concat(theseKeys);
      if (_key_resp_17_allKeys.length > 0) {
        key_resp_17.keys = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].name;  // just the last key pressed
        key_resp_17.rt = _key_resp_17_allKeys[_key_resp_17_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_17.keys == 'n') {
            key_resp_17.corr = 1;
        } else {
            key_resp_17.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    usosopsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function usosopsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'usosopso' ---
    usosopsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_17.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_17.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_17.corr = 1;  // correct non-response
      } else {
         key_resp_17.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_17.corr, level);
    }
    psychoJS.experiment.addData('key_resp_17.keys', key_resp_17.keys);
    psychoJS.experiment.addData('key_resp_17.corr', key_resp_17.corr);
    if (typeof key_resp_17.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_17.rt', key_resp_17.rt);
        routineTimer.reset();
        }
    
    key_resp_17.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_3_allKeys;
var A_sa_A_Components;
function A_sa_A_RoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'A_sa_A_' ---
    t = 0;
    A_sa_A_Clock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_3.secs=3.5;
    sound_vowels_3.setVolume(1.0);
    key_resp_3.keys = undefined;
    key_resp_3.rt = undefined;
    _key_resp_3_allKeys = [];
    // keep track of which components have finished
    A_sa_A_Components = [];
    A_sa_A_Components.push(sound_vowels_3);
    A_sa_A_Components.push(text_11);
    A_sa_A_Components.push(text_12);
    A_sa_A_Components.push(text_13);
    A_sa_A_Components.push(text_14);
    A_sa_A_Components.push(text_15);
    A_sa_A_Components.push(key_resp_3);
    
    A_sa_A_Components.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function A_sa_A_RoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'A_sa_A_' ---
    // get current time
    t = A_sa_A_Clock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_3
    if (t >= 5 && sound_vowels_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_3.tStart = t;  // (not accounting for frame time here)
      sound_vowels_3.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_3.play(); });  // screen flip
      sound_vowels_3.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_3.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_3.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_11* updates
    if (t >= 0.0 && text_11.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_11.tStart = t;  // (not accounting for frame time here)
      text_11.frameNStart = frameN;  // exact frame index
      
      text_11.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_11.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_11.setAutoDraw(false);
    }
    
    // *text_12* updates
    if (t >= 9.0 && text_12.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_12.tStart = t;  // (not accounting for frame time here)
      text_12.frameNStart = frameN;  // exact frame index
      
      text_12.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_12.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_12.setAutoDraw(false);
    }
    
    // *text_13* updates
    if (t >= 2 && text_13.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_13.tStart = t;  // (not accounting for frame time here)
      text_13.frameNStart = frameN;  // exact frame index
      
      text_13.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_13.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_13.setAutoDraw(false);
    }
    
    // *text_14* updates
    if (t >= 3.0 && text_14.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_14.tStart = t;  // (not accounting for frame time here)
      text_14.frameNStart = frameN;  // exact frame index
      
      text_14.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_14.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_14.setAutoDraw(false);
    }
    
    // *text_15* updates
    if (t >= 4.0 && text_15.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_15.tStart = t;  // (not accounting for frame time here)
      text_15.frameNStart = frameN;  // exact frame index
      
      text_15.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_15.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_15.setAutoDraw(false);
    }
    
    // *key_resp_3* updates
    if (t >= 9.0 && key_resp_3.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_3.tStart = t;  // (not accounting for frame time here)
      key_resp_3.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_3.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_3.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_3.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_3.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_3.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_3.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_3.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_3_allKeys = _key_resp_3_allKeys.concat(theseKeys);
      if (_key_resp_3_allKeys.length > 0) {
        key_resp_3.keys = _key_resp_3_allKeys[_key_resp_3_allKeys.length - 1].name;  // just the last key pressed
        key_resp_3.rt = _key_resp_3_allKeys[_key_resp_3_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_3.keys == 'y') {
            key_resp_3.corr = 1;
        } else {
            key_resp_3.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    A_sa_A_Components.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function A_sa_A_RoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'A_sa_A_' ---
    A_sa_A_Components.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_3.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_3.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_3.corr = 1;  // correct non-response
      } else {
         key_resp_3.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_3.corr, level);
    }
    psychoJS.experiment.addData('key_resp_3.keys', key_resp_3.keys);
    psychoJS.experiment.addData('key_resp_3.corr', key_resp_3.corr);
    if (typeof key_resp_3.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_3.rt', key_resp_3.rt);
        routineTimer.reset();
        }
    
    key_resp_3.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_4_allKeys;
var u_u_soComponents;
function u_u_soRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'u_u_so' ---
    t = 0;
    u_u_soClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_4.secs=3.5;
    sound_vowels_4.setVolume(1.0);
    key_resp_4.keys = undefined;
    key_resp_4.rt = undefined;
    _key_resp_4_allKeys = [];
    // keep track of which components have finished
    u_u_soComponents = [];
    u_u_soComponents.push(sound_vowels_4);
    u_u_soComponents.push(text_16);
    u_u_soComponents.push(text_17);
    u_u_soComponents.push(text_18);
    u_u_soComponents.push(text_19);
    u_u_soComponents.push(text_20);
    u_u_soComponents.push(key_resp_4);
    
    u_u_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function u_u_soRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'u_u_so' ---
    // get current time
    t = u_u_soClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_4
    if (t >= 5 && sound_vowels_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_4.tStart = t;  // (not accounting for frame time here)
      sound_vowels_4.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_4.play(); });  // screen flip
      sound_vowels_4.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_4.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_4.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_16* updates
    if (t >= 0.0 && text_16.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_16.tStart = t;  // (not accounting for frame time here)
      text_16.frameNStart = frameN;  // exact frame index
      
      text_16.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_16.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_16.setAutoDraw(false);
    }
    
    // *text_17* updates
    if (t >= 9.0 && text_17.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_17.tStart = t;  // (not accounting for frame time here)
      text_17.frameNStart = frameN;  // exact frame index
      
      text_17.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_17.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_17.setAutoDraw(false);
    }
    
    // *text_18* updates
    if (t >= 2 && text_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_18.tStart = t;  // (not accounting for frame time here)
      text_18.frameNStart = frameN;  // exact frame index
      
      text_18.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_18.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_18.setAutoDraw(false);
    }
    
    // *text_19* updates
    if (t >= 3.0 && text_19.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_19.tStart = t;  // (not accounting for frame time here)
      text_19.frameNStart = frameN;  // exact frame index
      
      text_19.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_19.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_19.setAutoDraw(false);
    }
    
    // *text_20* updates
    if (t >= 4.0 && text_20.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_20.tStart = t;  // (not accounting for frame time here)
      text_20.frameNStart = frameN;  // exact frame index
      
      text_20.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_20.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_20.setAutoDraw(false);
    }
    
    // *key_resp_4* updates
    if (t >= 9.0 && key_resp_4.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_4.tStart = t;  // (not accounting for frame time here)
      key_resp_4.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_4.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_4.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_4.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_4.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_4.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_4.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_4.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_4_allKeys = _key_resp_4_allKeys.concat(theseKeys);
      if (_key_resp_4_allKeys.length > 0) {
        key_resp_4.keys = _key_resp_4_allKeys[_key_resp_4_allKeys.length - 1].name;  // just the last key pressed
        key_resp_4.rt = _key_resp_4_allKeys[_key_resp_4_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_4.keys == 'y') {
            key_resp_4.corr = 1;
        } else {
            key_resp_4.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    u_u_soComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function u_u_soRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'u_u_so' ---
    u_u_soComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_4.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_4.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_4.corr = 1;  // correct non-response
      } else {
         key_resp_4.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_4.corr, level);
    }
    psychoJS.experiment.addData('key_resp_4.keys', key_resp_4.keys);
    psychoJS.experiment.addData('key_resp_4.corr', key_resp_4.corr);
    if (typeof key_resp_4.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_4.rt', key_resp_4.rt);
        routineTimer.reset();
        }
    
    key_resp_4.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_21_allKeys;
var AsaApAComponents;
function AsaApARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AsaApA' ---
    t = 0;
    AsaApAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_21.secs=3.5;
    sound_vowels_21.setVolume(1.0);
    key_resp_21.keys = undefined;
    key_resp_21.rt = undefined;
    _key_resp_21_allKeys = [];
    // keep track of which components have finished
    AsaApAComponents = [];
    AsaApAComponents.push(sound_vowels_21);
    AsaApAComponents.push(text_101);
    AsaApAComponents.push(text_102);
    AsaApAComponents.push(text_103);
    AsaApAComponents.push(text_104);
    AsaApAComponents.push(text_105);
    AsaApAComponents.push(key_resp_21);
    
    AsaApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AsaApARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AsaApA' ---
    // get current time
    t = AsaApAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_21
    if (t >= 5 && sound_vowels_21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_21.tStart = t;  // (not accounting for frame time here)
      sound_vowels_21.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_21.play(); });  // screen flip
      sound_vowels_21.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_21.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_21.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_21.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_101* updates
    if (t >= 0.0 && text_101.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_101.tStart = t;  // (not accounting for frame time here)
      text_101.frameNStart = frameN;  // exact frame index
      
      text_101.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_101.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_101.setAutoDraw(false);
    }
    
    // *text_102* updates
    if (t >= 9.0 && text_102.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_102.tStart = t;  // (not accounting for frame time here)
      text_102.frameNStart = frameN;  // exact frame index
      
      text_102.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_102.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_102.setAutoDraw(false);
    }
    
    // *text_103* updates
    if (t >= 2 && text_103.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_103.tStart = t;  // (not accounting for frame time here)
      text_103.frameNStart = frameN;  // exact frame index
      
      text_103.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_103.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_103.setAutoDraw(false);
    }
    
    // *text_104* updates
    if (t >= 3.0 && text_104.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_104.tStart = t;  // (not accounting for frame time here)
      text_104.frameNStart = frameN;  // exact frame index
      
      text_104.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_104.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_104.setAutoDraw(false);
    }
    
    // *text_105* updates
    if (t >= 4.0 && text_105.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_105.tStart = t;  // (not accounting for frame time here)
      text_105.frameNStart = frameN;  // exact frame index
      
      text_105.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_105.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_105.setAutoDraw(false);
    }
    
    // *key_resp_21* updates
    if (t >= 9.0 && key_resp_21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_21.tStart = t;  // (not accounting for frame time here)
      key_resp_21.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_21.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_21.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_21.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_21.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_21.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_21.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_21.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_21_allKeys = _key_resp_21_allKeys.concat(theseKeys);
      if (_key_resp_21_allKeys.length > 0) {
        key_resp_21.keys = _key_resp_21_allKeys[_key_resp_21_allKeys.length - 1].name;  // just the last key pressed
        key_resp_21.rt = _key_resp_21_allKeys[_key_resp_21_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_21.keys == 'n') {
            key_resp_21.corr = 1;
        } else {
            key_resp_21.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AsaApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AsaApARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AsaApA' ---
    AsaApAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_21.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_21.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_21.corr = 1;  // correct non-response
      } else {
         key_resp_21.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_21.corr, level);
    }
    psychoJS.experiment.addData('key_resp_21.keys', key_resp_21.keys);
    psychoJS.experiment.addData('key_resp_21.corr', key_resp_21.corr);
    if (typeof key_resp_21.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_21.rt', key_resp_21.rt);
        routineTimer.reset();
        }
    
    key_resp_21.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_18_allKeys;
var upsoComponents;
function upsoRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'upso' ---
    t = 0;
    upsoClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_18.secs=3.5;
    sound_vowels_18.setVolume(1.0);
    key_resp_18.keys = undefined;
    key_resp_18.rt = undefined;
    _key_resp_18_allKeys = [];
    // keep track of which components have finished
    upsoComponents = [];
    upsoComponents.push(sound_vowels_18);
    upsoComponents.push(text_86);
    upsoComponents.push(text_87);
    upsoComponents.push(text_88);
    upsoComponents.push(text_89);
    upsoComponents.push(text_90);
    upsoComponents.push(key_resp_18);
    
    upsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function upsoRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'upso' ---
    // get current time
    t = upsoClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_18
    if (t >= 5 && sound_vowels_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_18.tStart = t;  // (not accounting for frame time here)
      sound_vowels_18.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_18.play(); });  // screen flip
      sound_vowels_18.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_18.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_18.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_18.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_86* updates
    if (t >= 0.0 && text_86.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_86.tStart = t;  // (not accounting for frame time here)
      text_86.frameNStart = frameN;  // exact frame index
      
      text_86.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_86.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_86.setAutoDraw(false);
    }
    
    // *text_87* updates
    if (t >= 9.0 && text_87.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_87.tStart = t;  // (not accounting for frame time here)
      text_87.frameNStart = frameN;  // exact frame index
      
      text_87.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_87.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_87.setAutoDraw(false);
    }
    
    // *text_88* updates
    if (t >= 2 && text_88.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_88.tStart = t;  // (not accounting for frame time here)
      text_88.frameNStart = frameN;  // exact frame index
      
      text_88.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_88.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_88.setAutoDraw(false);
    }
    
    // *text_89* updates
    if (t >= 3.0 && text_89.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_89.tStart = t;  // (not accounting for frame time here)
      text_89.frameNStart = frameN;  // exact frame index
      
      text_89.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_89.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_89.setAutoDraw(false);
    }
    
    // *text_90* updates
    if (t >= 4.0 && text_90.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_90.tStart = t;  // (not accounting for frame time here)
      text_90.frameNStart = frameN;  // exact frame index
      
      text_90.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_90.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_90.setAutoDraw(false);
    }
    
    // *key_resp_18* updates
    if (t >= 9.0 && key_resp_18.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_18.tStart = t;  // (not accounting for frame time here)
      key_resp_18.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_18.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_18.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_18.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_18.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_18.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_18.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_18.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_18_allKeys = _key_resp_18_allKeys.concat(theseKeys);
      if (_key_resp_18_allKeys.length > 0) {
        key_resp_18.keys = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].name;  // just the last key pressed
        key_resp_18.rt = _key_resp_18_allKeys[_key_resp_18_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_18.keys == 'n') {
            key_resp_18.corr = 1;
        } else {
            key_resp_18.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    upsoComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function upsoRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'upso' ---
    upsoComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_18.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_18.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_18.corr = 1;  // correct non-response
      } else {
         key_resp_18.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_18.corr, level);
    }
    psychoJS.experiment.addData('key_resp_18.keys', key_resp_18.keys);
    psychoJS.experiment.addData('key_resp_18.corr', key_resp_18.corr);
    if (typeof key_resp_18.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_18.rt', key_resp_18.rt);
        routineTimer.reset();
        }
    
    key_resp_18.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_22_allKeys;
var AsaApsaComponents;
function AsaApsaRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'AsaApsa' ---
    t = 0;
    AsaApsaClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_22.secs=3.5;
    sound_vowels_22.setVolume(1.0);
    key_resp_22.keys = undefined;
    key_resp_22.rt = undefined;
    _key_resp_22_allKeys = [];
    // keep track of which components have finished
    AsaApsaComponents = [];
    AsaApsaComponents.push(sound_vowels_22);
    AsaApsaComponents.push(text_106);
    AsaApsaComponents.push(text_107);
    AsaApsaComponents.push(text_108);
    AsaApsaComponents.push(text_109);
    AsaApsaComponents.push(text_110);
    AsaApsaComponents.push(key_resp_22);
    
    AsaApsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function AsaApsaRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'AsaApsa' ---
    // get current time
    t = AsaApsaClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_22
    if (t >= 5 && sound_vowels_22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_22.tStart = t;  // (not accounting for frame time here)
      sound_vowels_22.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_22.play(); });  // screen flip
      sound_vowels_22.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_22.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_22.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_22.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_106* updates
    if (t >= 0.0 && text_106.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_106.tStart = t;  // (not accounting for frame time here)
      text_106.frameNStart = frameN;  // exact frame index
      
      text_106.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_106.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_106.setAutoDraw(false);
    }
    
    // *text_107* updates
    if (t >= 9.0 && text_107.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_107.tStart = t;  // (not accounting for frame time here)
      text_107.frameNStart = frameN;  // exact frame index
      
      text_107.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_107.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_107.setAutoDraw(false);
    }
    
    // *text_108* updates
    if (t >= 2 && text_108.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_108.tStart = t;  // (not accounting for frame time here)
      text_108.frameNStart = frameN;  // exact frame index
      
      text_108.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_108.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_108.setAutoDraw(false);
    }
    
    // *text_109* updates
    if (t >= 3.0 && text_109.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_109.tStart = t;  // (not accounting for frame time here)
      text_109.frameNStart = frameN;  // exact frame index
      
      text_109.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_109.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_109.setAutoDraw(false);
    }
    
    // *text_110* updates
    if (t >= 4.0 && text_110.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_110.tStart = t;  // (not accounting for frame time here)
      text_110.frameNStart = frameN;  // exact frame index
      
      text_110.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_110.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_110.setAutoDraw(false);
    }
    
    // *key_resp_22* updates
    if (t >= 9.0 && key_resp_22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_22.tStart = t;  // (not accounting for frame time here)
      key_resp_22.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_22.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_22.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_22.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_22.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_22.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_22.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_22.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_22_allKeys = _key_resp_22_allKeys.concat(theseKeys);
      if (_key_resp_22_allKeys.length > 0) {
        key_resp_22.keys = _key_resp_22_allKeys[_key_resp_22_allKeys.length - 1].name;  // just the last key pressed
        key_resp_22.rt = _key_resp_22_allKeys[_key_resp_22_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_22.keys == 'n') {
            key_resp_22.corr = 1;
        } else {
            key_resp_22.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    AsaApsaComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function AsaApsaRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'AsaApsa' ---
    AsaApsaComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_22.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_22.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_22.corr = 1;  // correct non-response
      } else {
         key_resp_22.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_22.corr, level);
    }
    psychoJS.experiment.addData('key_resp_22.keys', key_resp_22.keys);
    psychoJS.experiment.addData('key_resp_22.corr', key_resp_22.corr);
    if (typeof key_resp_22.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_22.rt', key_resp_22.rt);
        routineTimer.reset();
        }
    
    key_resp_22.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_5_allKeys;
var joAjoApAComponents;
function joAjoApARoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'joAjoApA' ---
    t = 0;
    joAjoApAClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_5.secs=3.5;
    sound_vowels_5.setVolume(1.0);
    key_resp_5.keys = undefined;
    key_resp_5.rt = undefined;
    _key_resp_5_allKeys = [];
    // keep track of which components have finished
    joAjoApAComponents = [];
    joAjoApAComponents.push(sound_vowels_5);
    joAjoApAComponents.push(text_21);
    joAjoApAComponents.push(text_22);
    joAjoApAComponents.push(text_23);
    joAjoApAComponents.push(text_24);
    joAjoApAComponents.push(text_25);
    joAjoApAComponents.push(key_resp_5);
    
    joAjoApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function joAjoApARoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'joAjoApA' ---
    // get current time
    t = joAjoApAClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_5
    if (t >= 5 && sound_vowels_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_5.tStart = t;  // (not accounting for frame time here)
      sound_vowels_5.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_5.play(); });  // screen flip
      sound_vowels_5.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_5.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_5.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_21* updates
    if (t >= 0.0 && text_21.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_21.tStart = t;  // (not accounting for frame time here)
      text_21.frameNStart = frameN;  // exact frame index
      
      text_21.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_21.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_21.setAutoDraw(false);
    }
    
    // *text_22* updates
    if (t >= 9.0 && text_22.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_22.tStart = t;  // (not accounting for frame time here)
      text_22.frameNStart = frameN;  // exact frame index
      
      text_22.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_22.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_22.setAutoDraw(false);
    }
    
    // *text_23* updates
    if (t >= 2 && text_23.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_23.tStart = t;  // (not accounting for frame time here)
      text_23.frameNStart = frameN;  // exact frame index
      
      text_23.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_23.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_23.setAutoDraw(false);
    }
    
    // *text_24* updates
    if (t >= 3.0 && text_24.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_24.tStart = t;  // (not accounting for frame time here)
      text_24.frameNStart = frameN;  // exact frame index
      
      text_24.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_24.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_24.setAutoDraw(false);
    }
    
    // *text_25* updates
    if (t >= 4.0 && text_25.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_25.tStart = t;  // (not accounting for frame time here)
      text_25.frameNStart = frameN;  // exact frame index
      
      text_25.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_25.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_25.setAutoDraw(false);
    }
    
    // *key_resp_5* updates
    if (t >= 9.0 && key_resp_5.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_5.tStart = t;  // (not accounting for frame time here)
      key_resp_5.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_5.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_5.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_5.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_5.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_5.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_5.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_5.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_5_allKeys = _key_resp_5_allKeys.concat(theseKeys);
      if (_key_resp_5_allKeys.length > 0) {
        key_resp_5.keys = _key_resp_5_allKeys[_key_resp_5_allKeys.length - 1].name;  // just the last key pressed
        key_resp_5.rt = _key_resp_5_allKeys[_key_resp_5_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_5.keys == 'n') {
            key_resp_5.corr = 1;
        } else {
            key_resp_5.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    joAjoApAComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function joAjoApARoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'joAjoApA' ---
    joAjoApAComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_5.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_5.keys === undefined) {
      if (['None','none',undefined].includes('n')) {
         key_resp_5.corr = 1;  // correct non-response
      } else {
         key_resp_5.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_5.corr, level);
    }
    psychoJS.experiment.addData('key_resp_5.keys', key_resp_5.keys);
    psychoJS.experiment.addData('key_resp_5.corr', key_resp_5.corr);
    if (typeof key_resp_5.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_5.rt', key_resp_5.rt);
        routineTimer.reset();
        }
    
    key_resp_5.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


var _key_resp_7_allKeys;
var A_sa_saComponents;
function A_sa_saRoutineBegin(snapshot) {
  return async function () {
    TrialHandler.fromSnapshot(snapshot); // ensure that .thisN vals are up to date
    
    //--- Prepare to start Routine 'A_sa_sa' ---
    t = 0;
    A_sa_saClock.reset(); // clock
    frameN = -1;
    continueRoutine = true; // until we're told otherwise
    routineTimer.add(19.000000);
    // update component parameters for each repeat
    sound_vowels_7.secs=3.5;
    sound_vowels_7.setVolume(1.0);
    key_resp_7.keys = undefined;
    key_resp_7.rt = undefined;
    _key_resp_7_allKeys = [];
    // keep track of which components have finished
    A_sa_saComponents = [];
    A_sa_saComponents.push(sound_vowels_7);
    A_sa_saComponents.push(text_31);
    A_sa_saComponents.push(text_32);
    A_sa_saComponents.push(text_33);
    A_sa_saComponents.push(text_34);
    A_sa_saComponents.push(text_35);
    A_sa_saComponents.push(key_resp_7);
    
    A_sa_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent)
        thisComponent.status = PsychoJS.Status.NOT_STARTED;
       });
    return Scheduler.Event.NEXT;
  }
}


function A_sa_saRoutineEachFrame() {
  return async function () {
    //--- Loop for each frame of Routine 'A_sa_sa' ---
    // get current time
    t = A_sa_saClock.getTime();
    frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
    // update/draw components on each frame
    // start/stop sound_vowels_7
    if (t >= 5 && sound_vowels_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      sound_vowels_7.tStart = t;  // (not accounting for frame time here)
      sound_vowels_7.frameNStart = frameN;  // exact frame index
      
      psychoJS.window.callOnFlip(function(){ sound_vowels_7.play(); });  // screen flip
      sound_vowels_7.status = PsychoJS.Status.STARTED;
    }
    frameRemains = 5 + 3.5 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (sound_vowels_7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      if (3.5 > 0.5) {
        sound_vowels_7.stop();  // stop the sound (if longer than duration)
      }
      sound_vowels_7.status = PsychoJS.Status.FINISHED;
    }
    
    // *text_31* updates
    if (t >= 0.0 && text_31.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_31.tStart = t;  // (not accounting for frame time here)
      text_31.frameNStart = frameN;  // exact frame index
      
      text_31.setAutoDraw(true);
    }

    frameRemains = 0.0 + 2.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_31.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_31.setAutoDraw(false);
    }
    
    // *text_32* updates
    if (t >= 9.0 && text_32.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_32.tStart = t;  // (not accounting for frame time here)
      text_32.frameNStart = frameN;  // exact frame index
      
      text_32.setAutoDraw(true);
    }

    frameRemains = 9.0 + 10.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_32.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_32.setAutoDraw(false);
    }
    
    // *text_33* updates
    if (t >= 2 && text_33.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_33.tStart = t;  // (not accounting for frame time here)
      text_33.frameNStart = frameN;  // exact frame index
      
      text_33.setAutoDraw(true);
    }

    frameRemains = 2 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_33.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_33.setAutoDraw(false);
    }
    
    // *text_34* updates
    if (t >= 3.0 && text_34.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_34.tStart = t;  // (not accounting for frame time here)
      text_34.frameNStart = frameN;  // exact frame index
      
      text_34.setAutoDraw(true);
    }

    frameRemains = 3.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_34.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_34.setAutoDraw(false);
    }
    
    // *text_35* updates
    if (t >= 4.0 && text_35.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      text_35.tStart = t;  // (not accounting for frame time here)
      text_35.frameNStart = frameN;  // exact frame index
      
      text_35.setAutoDraw(true);
    }

    frameRemains = 4.0 + 1.0 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (text_35.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      text_35.setAutoDraw(false);
    }
    
    // *key_resp_7* updates
    if (t >= 9.0 && key_resp_7.status === PsychoJS.Status.NOT_STARTED) {
      // keep track of start time/frame for later
      key_resp_7.tStart = t;  // (not accounting for frame time here)
      key_resp_7.frameNStart = frameN;  // exact frame index
      
      // keyboard checking is just starting
      psychoJS.window.callOnFlip(function() { key_resp_7.clock.reset(); });  // t=0 on next screen flip
      psychoJS.window.callOnFlip(function() { key_resp_7.start(); }); // start on screen flip
      psychoJS.window.callOnFlip(function() { key_resp_7.clearEvents(); });
    }

    frameRemains = 9.0 + 10 - psychoJS.window.monitorFramePeriod * 0.75;  // most of one frame period left
    if (key_resp_7.status === PsychoJS.Status.STARTED && t >= frameRemains) {
      key_resp_7.status = PsychoJS.Status.FINISHED;
  }

    if (key_resp_7.status === PsychoJS.Status.STARTED) {
      let theseKeys = key_resp_7.getKeys({keyList: ['y', 'n'], waitRelease: false});
      _key_resp_7_allKeys = _key_resp_7_allKeys.concat(theseKeys);
      if (_key_resp_7_allKeys.length > 0) {
        key_resp_7.keys = _key_resp_7_allKeys[_key_resp_7_allKeys.length - 1].name;  // just the last key pressed
        key_resp_7.rt = _key_resp_7_allKeys[_key_resp_7_allKeys.length - 1].rt;
        // was this correct?
        if (key_resp_7.keys == 'y') {
            key_resp_7.corr = 1;
        } else {
            key_resp_7.corr = 0;
        }
        // a response ends the routine
        continueRoutine = false;
      }
    }
    
    // check for quit (typically the Esc key)
    if (psychoJS.experiment.experimentEnded || psychoJS.eventManager.getKeys({keyList:['escape']}).length > 0) {
      return quitPsychoJS('The [Escape] key was pressed. Goodbye!', false);
    }
    
    // check if the Routine should terminate
    if (!continueRoutine) {  // a component has requested a forced-end of Routine
      return Scheduler.Event.NEXT;
    }
    
    continueRoutine = false;  // reverts to True if at least one component still running
    A_sa_saComponents.forEach( function(thisComponent) {
      if ('status' in thisComponent && thisComponent.status !== PsychoJS.Status.FINISHED) {
        continueRoutine = true;
      }
    });
    
    // refresh the screen if continuing
    if (continueRoutine && routineTimer.getTime() > 0) {
      return Scheduler.Event.FLIP_REPEAT;
    } else {
      return Scheduler.Event.NEXT;
    }
  };
}


function A_sa_saRoutineEnd(snapshot) {
  return async function () {
    //--- Ending Routine 'A_sa_sa' ---
    A_sa_saComponents.forEach( function(thisComponent) {
      if (typeof thisComponent.setAutoDraw === 'function') {
        thisComponent.setAutoDraw(false);
      }
    });
    sound_vowels_7.stop();  // ensure sound has stopped at end of routine
    // was no response the correct answer?!
    if (key_resp_7.keys === undefined) {
      if (['None','none',undefined].includes('y')) {
         key_resp_7.corr = 1;  // correct non-response
      } else {
         key_resp_7.corr = 0;  // failed to respond (incorrectly)
      }
    }
    // store data for current loop
    // update the trial handler
    if (currentLoop instanceof MultiStairHandler) {
      currentLoop.addResponse(key_resp_7.corr, level);
    }
    psychoJS.experiment.addData('key_resp_7.keys', key_resp_7.keys);
    psychoJS.experiment.addData('key_resp_7.corr', key_resp_7.corr);
    if (typeof key_resp_7.keys !== 'undefined') {  // we had a response
        psychoJS.experiment.addData('key_resp_7.rt', key_resp_7.rt);
        routineTimer.reset();
        }
    
    key_resp_7.stop();
    // Routines running outside a loop should always advance the datafile row
    if (currentLoop === psychoJS.experiment) {
      psychoJS.experiment.nextEntry(snapshot);
    }
    return Scheduler.Event.NEXT;
  }
}


function importConditions(currentLoop) {
  return async function () {
    psychoJS.importAttributes(currentLoop.getCurrentTrial());
    return Scheduler.Event.NEXT;
    };
}


async function quitPsychoJS(message, isCompleted) {
  // Check for and save orphaned data
  if (psychoJS.experiment.isEntryEmpty()) {
    psychoJS.experiment.nextEntry();
  }
  psychoJS.window.close();
  psychoJS.quit({message: message, isCompleted: isCompleted});
  
  return Scheduler.Event.QUIT;
}
